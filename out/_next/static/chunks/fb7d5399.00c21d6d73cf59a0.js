"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[737],{9477:function(a,b,c){c.d(b,{m7l:function(){return Sea},"N$j":function(){return QU},ZzF:function(){return Tm},TlE:function(){return TA},u9r:function(){return MC},uWy:function(){return j},Ilk:function(){return Dd},Ox3:function(){return Aia},ehD:function(){return h},pBf:function(){return y},hH6:function(){return Lga},Wl3:function(){return f},ZAu:function(){return bR},QRU:function(){return Wja},vpT:function(){return DS},kB5:function(){return WS},"_C8":function(){return Mba},Syv:function(){return r},NMF:function(){return s},x12:function(){return GW},nls:function(){return yW},blk:function(){return JX},ejS:function(){return BX},wem:function(){return o},D1R:function(){return q},qyh:function(){return p},aNw:function(){return Aga},Zp0:function(){return Kja},RsA:function(){return d},F5T:function(){return wA},M8C:function(){return aa},yGw:function(){return Hq},Kj0:function(){return vG},vBJ:function(){return OA},EJi:function(){return nba},Wid:function(){return kba},OoA:function(){return k},TyD:function(){return l},aH4:function(){return n},YLQ:function(){return m},dUE:function(){return yea},Tme:function(){return Sw},iKG:function(){return lM},cPb:function(){return nI},cek:function(){return sia},woe:function(){return TX},UY4:function(){return MX},iUV:function(){return ama},"_fP":function(){return Ih},iLg:function(){return Oea},rpg:function(){return i},xsS:function(){return yS},OdW:function(){return eV},TUv:function(){return xU},aLr:function(){return Eo},"$V":function(){return sua},PMe:function(){return aia},QmN:function(){return e},IOt:function(){return w},xEZ:function(){return df},dpR:function(){return sha},"z$h":function(){return u},UlW:function(){return t},FM8:function(){return ba},Pa4:function(){return nk},yC1:function(){return Rea},CP7:function(){return qS},knz:function(){return v}});const d={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},e={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},f=0,g=1,h=2,i=1e3,j=1001,k=1002,l=1003,m=1004,n=1005,o=1006,p=1007,q=1008,r=2300,s=2301,t=1,u=2,v=3001,w=0,x="300 es";class y{addEventListener(z,A){void 0===this._listeners&&(this._listeners={});const B=this._listeners;void 0===B[z]&&(B[z]=[]),-1===B[z].indexOf(A)&&B[z].push(A)}hasEventListener(C,D){if(void 0===this._listeners)return!1;const E=this._listeners;return void 0!==E[C]&& -1!==E[C].indexOf(D)}removeEventListener(F,G){if(void 0===this._listeners)return;const H=this._listeners,I=H[F];if(void 0!==I){const J=I.indexOf(G);-1!==J&&I.splice(J,1)}}dispatchEvent(K){if(void 0===this._listeners)return;const L=this._listeners,M=L[K.type];if(void 0!==M){K.target=this;const N=M.slice(0);for(let O=0,P=N.length;O<P;O++)N[O].call(this,K);K.target=null}}}const Q=[];for(let R=0;R<256;R++)Q[R]=(R<16?"0":"")+R.toString(16);let S=1234567;const T=Math.PI/180,U=180/Math.PI;function V(){const a=4294967295*Math.random()|0,b=4294967295*Math.random()|0,c=4294967295*Math.random()|0,d=4294967295*Math.random()|0,e=Q[255&a]+Q[a>>8&255]+Q[a>>16&255]+Q[a>>24&255]+"-"+Q[255&b]+Q[b>>8&255]+"-"+Q[b>>16&15|64]+Q[b>>24&255]+"-"+Q[63&c|128]+Q[c>>8&255]+"-"+Q[c>>16&255]+Q[c>>24&255]+Q[255&d]+Q[d>>8&255]+Q[d>>16&255]+Q[d>>24&255];return e.toUpperCase()}function W(a,b,c){return Math.max(b,Math.min(c,a))}function X(a,b){return(a%b+b)%b}function Y(a,b,c){return(1-c)*a+c*b}function Z(a){return(a&a-1)==0&&0!==a}function $(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function _(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}var aa=Object.freeze({__proto__:null,DEG2RAD:T,RAD2DEG:U,generateUUID:V,clamp:W,euclideanModulo:X,mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},inverseLerp:function(a,b,c){return a!==b?(c-a)/(b-a):0},lerp:Y,damp:function(a,b,c,d){return Y(a,b,1-Math.exp(-c*d))},pingpong:function(a,b=1){return b-Math.abs(X(a,2*b)-b)},smoothstep:function(a,b,c){return a<=b?0:a>=c?1:(a=(a-b)/(c-b))*a*(3-2*a)},smootherstep:function(a,b,c){return a<=b?0:a>=c?1:(a=(a-b)/(c-b))*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},seededRandom:function(a){return void 0!==a&&(S=a%2147483647),((S=16807*S%2147483647)-1)/2147483646},degToRad:function(a){return a*T},radToDeg:function(a){return a*U},isPowerOfTwo:Z,ceilPowerOfTwo:$,floorPowerOfTwo:_,setQuaternionFromProperEuler:function(a,b,c,d,e){const f=Math.cos,g=Math.sin,h=f(c/2),i=g(c/2),j=f((b+d)/2),k=g((b+d)/2),l=f((b-d)/2),m=g((b-d)/2),n=f((d-b)/2),o=g((d-b)/2);switch(e){case"XYX":a.set(h*k,i*l,i*m,h*j);break;case"YZY":a.set(i*m,h*k,i*l,h*j);break;case"ZXZ":a.set(i*l,i*m,h*k,h*j);break;case"XZX":a.set(h*k,i*o,i*n,h*j);break;case"YXY":a.set(i*n,h*k,i*o,h*j);break;case"ZYZ":a.set(i*o,i*n,h*k,h*j);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+e)}}});class ba{constructor(ca=0,da=0){this.x=ca,this.y=da}get width(){return this.x}set width(ea){this.x=ea}get height(){return this.y}set height(fa){this.y=fa}set(ga,ha){return this.x=ga,this.y=ha,this}setScalar(ia){return this.x=ia,this.y=ia,this}setX(ja){return this.x=ja,this}setY(ka){return this.y=ka,this}setComponent(la,ma){switch(la){case 0:this.x=ma;break;case 1:this.y=ma;break;default:throw new Error("index is out of range: "+la)}return this}getComponent(na){switch(na){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+na)}}clone(){return new this.constructor(this.x,this.y)}copy(oa){return this.x=oa.x,this.y=oa.y,this}add(pa,qa){return void 0!==qa?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(pa,qa)):(this.x+=pa.x,this.y+=pa.y,this)}addScalar(ra){return this.x+=ra,this.y+=ra,this}addVectors(sa,ta){return this.x=sa.x+ta.x,this.y=sa.y+ta.y,this}addScaledVector(ua,va){return this.x+=ua.x*va,this.y+=ua.y*va,this}sub(wa,xa){return void 0!==xa?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(wa,xa)):(this.x-=wa.x,this.y-=wa.y,this)}subScalar(ya){return this.x-=ya,this.y-=ya,this}subVectors(za,Aa){return this.x=za.x-Aa.x,this.y=za.y-Aa.y,this}multiply(Ba){return this.x*=Ba.x,this.y*=Ba.y,this}multiplyScalar(Ca){return this.x*=Ca,this.y*=Ca,this}divide(Da){return this.x/=Da.x,this.y/=Da.y,this}divideScalar(Ea){return this.multiplyScalar(1/Ea)}applyMatrix3(Fa){const Ga=this.x,Ha=this.y,Ia=Fa.elements;return this.x=Ia[0]*Ga+Ia[3]*Ha+Ia[6],this.y=Ia[1]*Ga+Ia[4]*Ha+Ia[7],this}min(Ja){return this.x=Math.min(this.x,Ja.x),this.y=Math.min(this.y,Ja.y),this}max(Ka){return this.x=Math.max(this.x,Ka.x),this.y=Math.max(this.y,Ka.y),this}clamp(La,Ma){return this.x=Math.max(La.x,Math.min(Ma.x,this.x)),this.y=Math.max(La.y,Math.min(Ma.y,this.y)),this}clampScalar(Na,Oa){return this.x=Math.max(Na,Math.min(Oa,this.x)),this.y=Math.max(Na,Math.min(Oa,this.y)),this}clampLength(Pa,Qa){const Ra=this.length();return this.divideScalar(Ra||1).multiplyScalar(Math.max(Pa,Math.min(Qa,Ra)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(Sa){return this.x*Sa.x+this.y*Sa.y}cross(Ta){return this.x*Ta.y-this.y*Ta.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){const Ua=Math.atan2(-this.y,-this.x)+Math.PI;return Ua}distanceTo(Va){return Math.sqrt(this.distanceToSquared(Va))}distanceToSquared(Wa){const Xa=this.x-Wa.x,Ya=this.y-Wa.y;return Xa*Xa+Ya*Ya}manhattanDistanceTo(Za){return Math.abs(this.x-Za.x)+Math.abs(this.y-Za.y)}setLength($a){return this.normalize().multiplyScalar($a)}lerp(_a,ab){return this.x+=(_a.x-this.x)*ab,this.y+=(_a.y-this.y)*ab,this}lerpVectors(bb,cb,db){return this.x=bb.x+(cb.x-bb.x)*db,this.y=bb.y+(cb.y-bb.y)*db,this}equals(eb){return eb.x===this.x&&eb.y===this.y}fromArray(fb,gb=0){return this.x=fb[gb],this.y=fb[gb+1],this}toArray(hb=[],ib=0){return hb[ib]=this.x,hb[ib+1]=this.y,hb}fromBufferAttribute(jb,kb,lb){return void 0!==lb&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=jb.getX(kb),this.y=jb.getY(kb),this}rotateAround(mb,nb){const ob=Math.cos(nb),pb=Math.sin(nb),qb=this.x-mb.x,rb=this.y-mb.y;return this.x=qb*ob-rb*pb+mb.x,this.y=qb*pb+rb*ob+mb.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}ba.prototype.isVector2=!0;class sb{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(tb,ub,vb,wb,xb,yb,zb,Ab,Bb){const Cb=this.elements;return Cb[0]=tb,Cb[1]=wb,Cb[2]=zb,Cb[3]=ub,Cb[4]=xb,Cb[5]=Ab,Cb[6]=vb,Cb[7]=yb,Cb[8]=Bb,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(Db){const Eb=this.elements,Fb=Db.elements;return Eb[0]=Fb[0],Eb[1]=Fb[1],Eb[2]=Fb[2],Eb[3]=Fb[3],Eb[4]=Fb[4],Eb[5]=Fb[5],Eb[6]=Fb[6],Eb[7]=Fb[7],Eb[8]=Fb[8],this}extractBasis(Gb,Hb,Ib){return Gb.setFromMatrix3Column(this,0),Hb.setFromMatrix3Column(this,1),Ib.setFromMatrix3Column(this,2),this}setFromMatrix4(Jb){const Kb=Jb.elements;return this.set(Kb[0],Kb[4],Kb[8],Kb[1],Kb[5],Kb[9],Kb[2],Kb[6],Kb[10]),this}multiply(Lb){return this.multiplyMatrices(this,Lb)}premultiply(Mb){return this.multiplyMatrices(Mb,this)}multiplyMatrices(Nb,Ob){const Pb=Nb.elements,Qb=Ob.elements,Rb=this.elements,Sb=Pb[0],Tb=Pb[3],Ub=Pb[6],Vb=Pb[1],Wb=Pb[4],Xb=Pb[7],Yb=Pb[2],Zb=Pb[5],$b=Pb[8],_b=Qb[0],ac=Qb[3],bc=Qb[6],cc=Qb[1],dc=Qb[4],ec=Qb[7],fc=Qb[2],gc=Qb[5],hc=Qb[8];return Rb[0]=Sb*_b+Tb*cc+Ub*fc,Rb[3]=Sb*ac+Tb*dc+Ub*gc,Rb[6]=Sb*bc+Tb*ec+Ub*hc,Rb[1]=Vb*_b+Wb*cc+Xb*fc,Rb[4]=Vb*ac+Wb*dc+Xb*gc,Rb[7]=Vb*bc+Wb*ec+Xb*hc,Rb[2]=Yb*_b+Zb*cc+$b*fc,Rb[5]=Yb*ac+Zb*dc+$b*gc,Rb[8]=Yb*bc+Zb*ec+$b*hc,this}multiplyScalar(ic){const jc=this.elements;return jc[0]*=ic,jc[3]*=ic,jc[6]*=ic,jc[1]*=ic,jc[4]*=ic,jc[7]*=ic,jc[2]*=ic,jc[5]*=ic,jc[8]*=ic,this}determinant(){const kc=this.elements,lc=kc[0],mc=kc[1],nc=kc[2],oc=kc[3],pc=kc[4],qc=kc[5],rc=kc[6],sc=kc[7],tc=kc[8];return lc*pc*tc-lc*qc*sc-mc*oc*tc+mc*qc*rc+nc*oc*sc-nc*pc*rc}invert(){const uc=this.elements,vc=uc[0],wc=uc[1],xc=uc[2],yc=uc[3],zc=uc[4],Ac=uc[5],Bc=uc[6],Cc=uc[7],Dc=uc[8],Ec=Dc*zc-Ac*Cc,Fc=Ac*Bc-Dc*yc,Gc=Cc*yc-zc*Bc,Hc=vc*Ec+wc*Fc+xc*Gc;if(0===Hc)return this.set(0,0,0,0,0,0,0,0,0);const Ic=1/Hc;return uc[0]=Ec*Ic,uc[1]=(xc*Cc-Dc*wc)*Ic,uc[2]=(Ac*wc-xc*zc)*Ic,uc[3]=Fc*Ic,uc[4]=(Dc*vc-xc*Bc)*Ic,uc[5]=(xc*yc-Ac*vc)*Ic,uc[6]=Gc*Ic,uc[7]=(wc*Bc-Cc*vc)*Ic,uc[8]=(zc*vc-wc*yc)*Ic,this}transpose(){let Jc;const Kc=this.elements;return Jc=Kc[1],Kc[1]=Kc[3],Kc[3]=Jc,Jc=Kc[2],Kc[2]=Kc[6],Kc[6]=Jc,Jc=Kc[5],Kc[5]=Kc[7],Kc[7]=Jc,this}getNormalMatrix(Lc){return this.setFromMatrix4(Lc).invert().transpose()}transposeIntoArray(Mc){const Nc=this.elements;return Mc[0]=Nc[0],Mc[1]=Nc[3],Mc[2]=Nc[6],Mc[3]=Nc[1],Mc[4]=Nc[4],Mc[5]=Nc[7],Mc[6]=Nc[2],Mc[7]=Nc[5],Mc[8]=Nc[8],this}setUvTransform(Oc,Pc,Qc,Rc,Sc,Tc,Uc){const Vc=Math.cos(Sc),Wc=Math.sin(Sc);return this.set(Qc*Vc,Qc*Wc,-Qc*(Vc*Tc+Wc*Uc)+Tc+Oc,-Rc*Wc,Rc*Vc,-Rc*(-Wc*Tc+Vc*Uc)+Uc+Pc,0,0,1),this}scale(Xc,Yc){const Zc=this.elements;return Zc[0]*=Xc,Zc[3]*=Xc,Zc[6]*=Xc,Zc[1]*=Yc,Zc[4]*=Yc,Zc[7]*=Yc,this}rotate($c){const _c=Math.cos($c),ad=Math.sin($c),bd=this.elements,cd=bd[0],dd=bd[3],ed=bd[6],fd=bd[1],gd=bd[4],hd=bd[7];return bd[0]=_c*cd+ad*fd,bd[3]=_c*dd+ad*gd,bd[6]=_c*ed+ad*hd,bd[1]=-ad*cd+_c*fd,bd[4]=-ad*dd+_c*gd,bd[7]=-ad*ed+_c*hd,this}translate(id,jd){const kd=this.elements;return kd[0]+=id*kd[2],kd[3]+=id*kd[5],kd[6]+=id*kd[8],kd[1]+=jd*kd[2],kd[4]+=jd*kd[5],kd[7]+=jd*kd[8],this}equals(ld){const md=this.elements,nd=ld.elements;for(let od=0;od<9;od++)if(md[od]!==nd[od])return!1;return!0}fromArray(pd,qd=0){for(let rd=0;rd<9;rd++)this.elements[rd]=pd[rd+qd];return this}toArray(sd=[],td=0){const ud=this.elements;return sd[td]=ud[0],sd[td+1]=ud[1],sd[td+2]=ud[2],sd[td+3]=ud[3],sd[td+4]=ud[4],sd[td+5]=ud[5],sd[td+6]=ud[6],sd[td+7]=ud[7],sd[td+8]=ud[8],sd}clone(){return new this.constructor().fromArray(this.elements)}}function vd(a){for(let b=a.length-1;b>=0;--b)if(a[b]>65535)return!0;return!1}function wd(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}sb.prototype.isMatrix3=!0;const xd={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yd={h:0,s:0,l:0},zd={h:0,s:0,l:0};function Ad(a,b,c){return(c<0&&(c+=1),c>1&&(c-=1),c<1/6)?a+(b-a)*6*c:c<.5?b:c<2/3?a+(b-a)*6*(2/3-c):a}function Bd(a){return a<.04045?.0773993808*a:Math.pow(.9478672986*a+.0521327014,2.4)}function Cd(a){return a<.0031308?12.92*a:1.055*Math.pow(a,.41666)-.055}class Dd{constructor(Ed,Fd,Gd){if(void 0===Fd&& void 0===Gd)return this.set(Ed);return this.setRGB(Ed,Fd,Gd)}set(Hd){return Hd&&Hd.isColor?this.copy(Hd):"number"==typeof Hd?this.setHex(Hd):"string"==typeof Hd&&this.setStyle(Hd),this}setScalar(Id){return this.r=Id,this.g=Id,this.b=Id,this}setHex(Jd){return Jd=Math.floor(Jd),this.r=(Jd>>16&255)/255,this.g=(Jd>>8&255)/255,this.b=(255&Jd)/255,this}setRGB(Kd,Ld,Md){return this.r=Kd,this.g=Ld,this.b=Md,this}setHSL(Nd,Od,Pd){if(Nd=X(Nd,1),Od=W(Od,0,1),Pd=W(Pd,0,1),0===Od)this.r=this.g=this.b=Pd;else{const Qd=Pd<=.5?Pd*(1+Od):Pd+Od-Pd*Od,Rd=2*Pd-Qd;this.r=Ad(Rd,Qd,Nd+1/3),this.g=Ad(Rd,Qd,Nd),this.b=Ad(Rd,Qd,Nd-1/3)}return this}setStyle(Sd){function Td(a){void 0!==a&&1>parseFloat(a)&&console.warn("THREE.Color: Alpha component of "+Sd+" will be ignored.")}let Ud;if(Ud=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(Sd)){let Vd;const Wd=Ud[1],Xd=Ud[2];switch(Wd){case"rgb":case"rgba":if(Vd=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Xd))return this.r=Math.min(255,parseInt(Vd[1],10))/255,this.g=Math.min(255,parseInt(Vd[2],10))/255,this.b=Math.min(255,parseInt(Vd[3],10))/255,Td(Vd[4]),this;if(Vd=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Xd))return this.r=Math.min(100,parseInt(Vd[1],10))/100,this.g=Math.min(100,parseInt(Vd[2],10))/100,this.b=Math.min(100,parseInt(Vd[3],10))/100,Td(Vd[4]),this;break;case"hsl":case"hsla":if(Vd=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Xd)){const Yd=parseFloat(Vd[1])/360,Zd=parseInt(Vd[2],10)/100,$d=parseInt(Vd[3],10)/100;return Td(Vd[4]),this.setHSL(Yd,Zd,$d)}break}}else if(Ud=/^\#([A-Fa-f\d]+)$/.exec(Sd)){const _d=Ud[1],ae=_d.length;if(3===ae)return this.r=parseInt(_d.charAt(0)+_d.charAt(0),16)/255,this.g=parseInt(_d.charAt(1)+_d.charAt(1),16)/255,this.b=parseInt(_d.charAt(2)+_d.charAt(2),16)/255,this;if(6===ae)return this.r=parseInt(_d.charAt(0)+_d.charAt(1),16)/255,this.g=parseInt(_d.charAt(2)+_d.charAt(3),16)/255,this.b=parseInt(_d.charAt(4)+_d.charAt(5),16)/255,this}return Sd&&Sd.length>0?this.setColorName(Sd):this}setColorName(be){const ce=xd[be.toLowerCase()];return void 0!==ce?this.setHex(ce):console.warn("THREE.Color: Unknown color "+be),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(de){return this.r=de.r,this.g=de.g,this.b=de.b,this}copySRGBToLinear(ee){return this.r=Bd(ee.r),this.g=Bd(ee.g),this.b=Bd(ee.b),this}copyLinearToSRGB(fe){return this.r=Cd(fe.r),this.g=Cd(fe.g),this.b=Cd(fe.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(ge){const he=this.r,ie=this.g,je=this.b,ke=Math.max(he,ie,je),le=Math.min(he,ie,je);let me,ne;const oe=(le+ke)/2;if(le===ke)me=0,ne=0;else{const pe=ke-le;switch(ne=oe<=.5?pe/(ke+le):pe/(2-ke-le),ke){case he:me=(ie-je)/pe+(ie<je?6:0);break;case ie:me=(je-he)/pe+2;break;case je:me=(he-ie)/pe+4;break}me/=6}return ge.h=me,ge.s=ne,ge.l=oe,ge}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(qe,re,se){return this.getHSL(yd),yd.h+=qe,yd.s+=re,yd.l+=se,this.setHSL(yd.h,yd.s,yd.l),this}add(te){return this.r+=te.r,this.g+=te.g,this.b+=te.b,this}addColors(ue,ve){return this.r=ue.r+ve.r,this.g=ue.g+ve.g,this.b=ue.b+ve.b,this}addScalar(we){return this.r+=we,this.g+=we,this.b+=we,this}sub(xe){return this.r=Math.max(0,this.r-xe.r),this.g=Math.max(0,this.g-xe.g),this.b=Math.max(0,this.b-xe.b),this}multiply(ye){return this.r*=ye.r,this.g*=ye.g,this.b*=ye.b,this}multiplyScalar(ze){return this.r*=ze,this.g*=ze,this.b*=ze,this}lerp(Ae,Be){return this.r+=(Ae.r-this.r)*Be,this.g+=(Ae.g-this.g)*Be,this.b+=(Ae.b-this.b)*Be,this}lerpColors(Ce,De,Ee){return this.r=Ce.r+(De.r-Ce.r)*Ee,this.g=Ce.g+(De.g-Ce.g)*Ee,this.b=Ce.b+(De.b-Ce.b)*Ee,this}lerpHSL(Fe,Ge){this.getHSL(yd),Fe.getHSL(zd);const He=Y(yd.h,zd.h,Ge),Ie=Y(yd.s,zd.s,Ge),Je=Y(yd.l,zd.l,Ge);return this.setHSL(He,Ie,Je),this}equals(Ke){return Ke.r===this.r&&Ke.g===this.g&&Ke.b===this.b}fromArray(Le,Me=0){return this.r=Le[Me],this.g=Le[Me+1],this.b=Le[Me+2],this}toArray(Ne=[],Oe=0){return Ne[Oe]=this.r,Ne[Oe+1]=this.g,Ne[Oe+2]=this.b,Ne}fromBufferAttribute(Pe,Qe){return this.r=Pe.getX(Qe),this.g=Pe.getY(Qe),this.b=Pe.getZ(Qe),!0===Pe.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Dd.NAMES=xd,Dd.prototype.isColor=!0,Dd.prototype.r=1,Dd.prototype.g=1,Dd.prototype.b=1;let Re;class Se{static getDataURL(Te){if(/^data:/i.test(Te.src))return Te.src;if("undefined"==typeof HTMLCanvasElement)return Te.src;let Ue;if(Te instanceof HTMLCanvasElement)Ue=Te;else{void 0===Re&&(Re=wd("canvas")),Re.width=Te.width,Re.height=Te.height;const Ve=Re.getContext("2d");Te instanceof ImageData?Ve.putImageData(Te,0,0):Ve.drawImage(Te,0,0,Te.width,Te.height),Ue=Re}return Ue.width>2048||Ue.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",Te),Ue.toDataURL("image/jpeg",.6)):Ue.toDataURL("image/png")}static sRGBToLinear(We){if("undefined"!=typeof HTMLImageElement&&We instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&We instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&We instanceof ImageBitmap){const Xe=wd("canvas");Xe.width=We.width,Xe.height=We.height;const Ye=Xe.getContext("2d");Ye.drawImage(We,0,0,We.width,We.height);const Ze=Ye.getImageData(0,0,We.width,We.height),$e=Ze.data;for(let _e=0;_e<$e.length;_e++)$e[_e]=255*Bd($e[_e]/255);return Ye.putImageData(Ze,0,0),Xe}{if(!We.data)return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),We;const af=We.data.slice(0);for(let bf=0;bf<af.length;bf++)af instanceof Uint8Array||af instanceof Uint8ClampedArray?af[bf]=Math.floor(255*Bd(af[bf]/255)):af[bf]=Bd(af[bf]);return{data:af,width:We.width,height:We.height}}}}let cf=0;class df extends y{constructor(ef=df.DEFAULT_IMAGE,ff=df.DEFAULT_MAPPING,gf=j,hf=j,jf=o,kf=q,lf=1023,mf=1009,nf=1,of=3e3){super(),Object.defineProperty(this,"id",{value:cf++}),this.uuid=V(),this.name="",this.image=ef,this.mipmaps=[],this.mapping=ff,this.wrapS=gf,this.wrapT=hf,this.magFilter=jf,this.minFilter=kf,this.anisotropy=nf,this.format=lf,this.internalFormat=null,this.type=mf,this.offset=new ba(0,0),this.repeat=new ba(1,1),this.center=new ba(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new sb(),this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=of,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(pf){return this.name=pf.name,this.image=pf.image,this.mipmaps=pf.mipmaps.slice(0),this.mapping=pf.mapping,this.wrapS=pf.wrapS,this.wrapT=pf.wrapT,this.magFilter=pf.magFilter,this.minFilter=pf.minFilter,this.anisotropy=pf.anisotropy,this.format=pf.format,this.internalFormat=pf.internalFormat,this.type=pf.type,this.offset.copy(pf.offset),this.repeat.copy(pf.repeat),this.center.copy(pf.center),this.rotation=pf.rotation,this.matrixAutoUpdate=pf.matrixAutoUpdate,this.matrix.copy(pf.matrix),this.generateMipmaps=pf.generateMipmaps,this.premultiplyAlpha=pf.premultiplyAlpha,this.flipY=pf.flipY,this.unpackAlignment=pf.unpackAlignment,this.encoding=pf.encoding,this.userData=JSON.parse(JSON.stringify(pf.userData)),this}toJSON(qf){const rf=void 0===qf||"string"==typeof qf;if(!rf&& void 0!==qf.textures[this.uuid])return qf.textures[this.uuid];const sf={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const tf=this.image;if(void 0===tf.uuid&&(tf.uuid=V()),!rf&& void 0===qf.images[tf.uuid]){let uf;if(Array.isArray(tf)){uf=[];for(let vf=0,wf=tf.length;vf<wf;vf++)tf[vf].isDataTexture?uf.push(zf(tf[vf].image)):uf.push(zf(tf[vf]))}else uf=zf(tf);qf.images[tf.uuid]={uuid:tf.uuid,url:uf}}sf.image=tf.uuid}return"{}"!==JSON.stringify(this.userData)&&(sf.userData=this.userData),rf||(qf.textures[this.uuid]=sf),sf}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(xf){if(300!==this.mapping)return xf;if(xf.applyMatrix3(this.matrix),xf.x<0||xf.x>1)switch(this.wrapS){case i:xf.x=xf.x-Math.floor(xf.x);break;case j:xf.x=xf.x<0?0:1;break;case k:1===Math.abs(Math.floor(xf.x)%2)?xf.x=Math.ceil(xf.x)-xf.x:xf.x=xf.x-Math.floor(xf.x);break}if(xf.y<0||xf.y>1)switch(this.wrapT){case i:xf.y=xf.y-Math.floor(xf.y);break;case j:xf.y=xf.y<0?0:1;break;case k:1===Math.abs(Math.floor(xf.y)%2)?xf.y=Math.ceil(xf.y)-xf.y:xf.y=xf.y-Math.floor(xf.y);break}return this.flipY&&(xf.y=1-xf.y),xf}set needsUpdate(yf){!0===yf&&this.version++}}function zf(a){return"undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap?Se.getDataURL(a):a.data?{data:Array.prototype.slice.call(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}df.DEFAULT_IMAGE=void 0,df.DEFAULT_MAPPING=300,df.prototype.isTexture=!0;class Af{constructor(Bf=0,Cf=0,Df=0,Ef=1){this.x=Bf,this.y=Cf,this.z=Df,this.w=Ef}get width(){return this.z}set width(Ff){this.z=Ff}get height(){return this.w}set height(Gf){this.w=Gf}set(Hf,If,Jf,Kf){return this.x=Hf,this.y=If,this.z=Jf,this.w=Kf,this}setScalar(Lf){return this.x=Lf,this.y=Lf,this.z=Lf,this.w=Lf,this}setX(Mf){return this.x=Mf,this}setY(Nf){return this.y=Nf,this}setZ(Of){return this.z=Of,this}setW(Pf){return this.w=Pf,this}setComponent(Qf,Rf){switch(Qf){case 0:this.x=Rf;break;case 1:this.y=Rf;break;case 2:this.z=Rf;break;case 3:this.w=Rf;break;default:throw new Error("index is out of range: "+Qf)}return this}getComponent(Sf){switch(Sf){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+Sf)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(Tf){return this.x=Tf.x,this.y=Tf.y,this.z=Tf.z,this.w=void 0!==Tf.w?Tf.w:1,this}add(Uf,Vf){return void 0!==Vf?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(Uf,Vf)):(this.x+=Uf.x,this.y+=Uf.y,this.z+=Uf.z,this.w+=Uf.w,this)}addScalar(Wf){return this.x+=Wf,this.y+=Wf,this.z+=Wf,this.w+=Wf,this}addVectors(Xf,Yf){return this.x=Xf.x+Yf.x,this.y=Xf.y+Yf.y,this.z=Xf.z+Yf.z,this.w=Xf.w+Yf.w,this}addScaledVector(Zf,$f){return this.x+=Zf.x*$f,this.y+=Zf.y*$f,this.z+=Zf.z*$f,this.w+=Zf.w*$f,this}sub(_f,ag){return void 0!==ag?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(_f,ag)):(this.x-=_f.x,this.y-=_f.y,this.z-=_f.z,this.w-=_f.w,this)}subScalar(bg){return this.x-=bg,this.y-=bg,this.z-=bg,this.w-=bg,this}subVectors(cg,dg){return this.x=cg.x-dg.x,this.y=cg.y-dg.y,this.z=cg.z-dg.z,this.w=cg.w-dg.w,this}multiply(eg){return this.x*=eg.x,this.y*=eg.y,this.z*=eg.z,this.w*=eg.w,this}multiplyScalar(fg){return this.x*=fg,this.y*=fg,this.z*=fg,this.w*=fg,this}applyMatrix4(gg){const hg=this.x,ig=this.y,jg=this.z,kg=this.w,lg=gg.elements;return this.x=lg[0]*hg+lg[4]*ig+lg[8]*jg+lg[12]*kg,this.y=lg[1]*hg+lg[5]*ig+lg[9]*jg+lg[13]*kg,this.z=lg[2]*hg+lg[6]*ig+lg[10]*jg+lg[14]*kg,this.w=lg[3]*hg+lg[7]*ig+lg[11]*jg+lg[15]*kg,this}divideScalar(mg){return this.multiplyScalar(1/mg)}setAxisAngleFromQuaternion(ng){this.w=2*Math.acos(ng.w);const og=Math.sqrt(1-ng.w*ng.w);return og<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=ng.x/og,this.y=ng.y/og,this.z=ng.z/og),this}setAxisAngleFromRotationMatrix(pg){let qg,rg,sg,tg;const ug=pg.elements,vg=ug[0],wg=ug[4],xg=ug[8],yg=ug[1],zg=ug[5],Ag=ug[9],Bg=ug[2],Cg=ug[6],Dg=ug[10];if(.01>Math.abs(wg-yg)&&.01>Math.abs(xg-Bg)&&.01>Math.abs(Ag-Cg)){if(.1>Math.abs(wg+yg)&&.1>Math.abs(xg+Bg)&&.1>Math.abs(Ag+Cg)&&.1>Math.abs(vg+zg+Dg-3))return this.set(1,0,0,0),this;qg=Math.PI;const Eg=(vg+1)/2,Fg=(zg+1)/2,Gg=(Dg+1)/2,Hg=(wg+yg)/4,Ig=(xg+Bg)/4,Jg=(Ag+Cg)/4;return Eg>Fg&&Eg>Gg?Eg<.01?(rg=0,sg=.707106781,tg=.707106781):(sg=Hg/(rg=Math.sqrt(Eg)),tg=Ig/rg):Fg>Gg?Fg<.01?(rg=.707106781,sg=0,tg=.707106781):(rg=Hg/(sg=Math.sqrt(Fg)),tg=Jg/sg):Gg<.01?(rg=.707106781,sg=.707106781,tg=0):(rg=Ig/(tg=Math.sqrt(Gg)),sg=Jg/tg),this.set(rg,sg,tg,qg),this}let Kg=Math.sqrt((Cg-Ag)*(Cg-Ag)+(xg-Bg)*(xg-Bg)+(yg-wg)*(yg-wg));return .001>Math.abs(Kg)&&(Kg=1),this.x=(Cg-Ag)/Kg,this.y=(xg-Bg)/Kg,this.z=(yg-wg)/Kg,this.w=Math.acos((vg+zg+Dg-1)/2),this}min(Lg){return this.x=Math.min(this.x,Lg.x),this.y=Math.min(this.y,Lg.y),this.z=Math.min(this.z,Lg.z),this.w=Math.min(this.w,Lg.w),this}max(Mg){return this.x=Math.max(this.x,Mg.x),this.y=Math.max(this.y,Mg.y),this.z=Math.max(this.z,Mg.z),this.w=Math.max(this.w,Mg.w),this}clamp(Ng,Og){return this.x=Math.max(Ng.x,Math.min(Og.x,this.x)),this.y=Math.max(Ng.y,Math.min(Og.y,this.y)),this.z=Math.max(Ng.z,Math.min(Og.z,this.z)),this.w=Math.max(Ng.w,Math.min(Og.w,this.w)),this}clampScalar(Pg,Qg){return this.x=Math.max(Pg,Math.min(Qg,this.x)),this.y=Math.max(Pg,Math.min(Qg,this.y)),this.z=Math.max(Pg,Math.min(Qg,this.z)),this.w=Math.max(Pg,Math.min(Qg,this.w)),this}clampLength(Rg,Sg){const Tg=this.length();return this.divideScalar(Tg||1).multiplyScalar(Math.max(Rg,Math.min(Sg,Tg)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(Ug){return this.x*Ug.x+this.y*Ug.y+this.z*Ug.z+this.w*Ug.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(Vg){return this.normalize().multiplyScalar(Vg)}lerp(Wg,Xg){return this.x+=(Wg.x-this.x)*Xg,this.y+=(Wg.y-this.y)*Xg,this.z+=(Wg.z-this.z)*Xg,this.w+=(Wg.w-this.w)*Xg,this}lerpVectors(Yg,Zg,$g){return this.x=Yg.x+(Zg.x-Yg.x)*$g,this.y=Yg.y+(Zg.y-Yg.y)*$g,this.z=Yg.z+(Zg.z-Yg.z)*$g,this.w=Yg.w+(Zg.w-Yg.w)*$g,this}equals(_g){return _g.x===this.x&&_g.y===this.y&&_g.z===this.z&&_g.w===this.w}fromArray(ah,bh=0){return this.x=ah[bh],this.y=ah[bh+1],this.z=ah[bh+2],this.w=ah[bh+3],this}toArray(ch=[],dh=0){return ch[dh]=this.x,ch[dh+1]=this.y,ch[dh+2]=this.z,ch[dh+3]=this.w,ch}fromBufferAttribute(eh,fh,gh){return void 0!==gh&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=eh.getX(fh),this.y=eh.getY(fh),this.z=eh.getZ(fh),this.w=eh.getW(fh),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}Af.prototype.isVector4=!0;class hh extends y{constructor(ih,jh,kh={}){super(),this.width=ih,this.height=jh,this.depth=1,this.scissor=new Af(0,0,ih,jh),this.scissorTest=!1,this.viewport=new Af(0,0,ih,jh),this.texture=new df(void 0,kh.mapping,kh.wrapS,kh.wrapT,kh.magFilter,kh.minFilter,kh.format,kh.type,kh.anisotropy,kh.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:ih,height:jh,depth:1},this.texture.generateMipmaps=void 0!==kh.generateMipmaps&&kh.generateMipmaps,this.texture.internalFormat=void 0!==kh.internalFormat?kh.internalFormat:null,this.texture.minFilter=void 0!==kh.minFilter?kh.minFilter:o,this.depthBuffer=void 0===kh.depthBuffer||kh.depthBuffer,this.stencilBuffer=void 0!==kh.stencilBuffer&&kh.stencilBuffer,this.depthTexture=void 0!==kh.depthTexture?kh.depthTexture:null}setTexture(lh){lh.image={width:this.width,height:this.height,depth:this.depth},this.texture=lh}setSize(mh,nh,oh=1){(this.width!==mh||this.height!==nh||this.depth!==oh)&&(this.width=mh,this.height=nh,this.depth=oh,this.texture.image.width=mh,this.texture.image.height=nh,this.texture.image.depth=oh,this.dispose()),this.viewport.set(0,0,mh,nh),this.scissor.set(0,0,mh,nh)}clone(){return new this.constructor().copy(this)}copy(ph){return this.width=ph.width,this.height=ph.height,this.depth=ph.depth,this.viewport.copy(ph.viewport),this.texture=ph.texture.clone(),this.texture.image=Object.assign({},ph.texture.image),this.depthBuffer=ph.depthBuffer,this.stencilBuffer=ph.stencilBuffer,this.depthTexture=ph.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}hh.prototype.isWebGLRenderTarget=!0,(class extends hh{constructor(qh,rh,sh){super(qh,rh);const th=this.texture;this.texture=[];for(let uh=0;uh<sh;uh++)this.texture[uh]=th.clone()}setSize(vh,wh,xh=1){if(this.width!==vh||this.height!==wh||this.depth!==xh){this.width=vh,this.height=wh,this.depth=xh;for(let yh=0,zh=this.texture.length;yh<zh;yh++)this.texture[yh].image.width=vh,this.texture[yh].image.height=wh,this.texture[yh].image.depth=xh;this.dispose()}return this.viewport.set(0,0,vh,wh),this.scissor.set(0,0,vh,wh),this}copy(Ah){this.dispose(),this.width=Ah.width,this.height=Ah.height,this.depth=Ah.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=Ah.depthBuffer,this.stencilBuffer=Ah.stencilBuffer,this.depthTexture=Ah.depthTexture,this.texture.length=0;for(let Bh=0,Ch=Ah.texture.length;Bh<Ch;Bh++)this.texture[Bh]=Ah.texture[Bh].clone();return this}}).prototype.isWebGLMultipleRenderTargets=!0;class Dh extends hh{constructor(Eh,Fh,Gh={}){super(Eh,Fh,Gh),this.samples=4,this.ignoreDepthForMultisampleCopy=void 0===Gh.ignoreDepth||Gh.ignoreDepth,this.useRenderToTexture=void 0!==Gh.useRenderToTexture&&Gh.useRenderToTexture,this.useRenderbuffer=!1===this.useRenderToTexture}copy(Hh){return super.copy.call(this,Hh),this.samples=Hh.samples,this.useRenderToTexture=Hh.useRenderToTexture,this.useRenderbuffer=Hh.useRenderbuffer,this}}Dh.prototype.isWebGLMultisampleRenderTarget=!0;class Ih{constructor(Jh=0,Kh=0,Lh=0,Mh=1){this._x=Jh,this._y=Kh,this._z=Lh,this._w=Mh}static slerp(Nh,Oh,Ph,Qh){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),Ph.slerpQuaternions(Nh,Oh,Qh)}static slerpFlat(Rh,Sh,Th,Uh,Vh,Wh,Xh){let Yh=Th[Uh+0],Zh=Th[Uh+1],$h=Th[Uh+2],_h=Th[Uh+3];const ai=Vh[Wh+0],bi=Vh[Wh+1],ci=Vh[Wh+2],di=Vh[Wh+3];if(0===Xh){Rh[Sh+0]=Yh,Rh[Sh+1]=Zh,Rh[Sh+2]=$h,Rh[Sh+3]=_h;return}if(1===Xh){Rh[Sh+0]=ai,Rh[Sh+1]=bi,Rh[Sh+2]=ci,Rh[Sh+3]=di;return}if(_h!==di||Yh!==ai||Zh!==bi||$h!==ci){let ei=1-Xh;const fi=Yh*ai+Zh*bi+$h*ci+_h*di,gi=fi>=0?1:-1,hi=1-fi*fi;if(hi>Number.EPSILON){const ii=Math.sqrt(hi),ji=Math.atan2(ii,fi*gi);ei=Math.sin(ei*ji)/ii,Xh=Math.sin(Xh*ji)/ii}const ki=Xh*gi;if(Yh=Yh*ei+ai*ki,Zh=Zh*ei+bi*ki,$h=$h*ei+ci*ki,_h=_h*ei+di*ki,ei===1-Xh){const li=1/Math.sqrt(Yh*Yh+Zh*Zh+$h*$h+_h*_h);Yh*=li,Zh*=li,$h*=li,_h*=li}}Rh[Sh]=Yh,Rh[Sh+1]=Zh,Rh[Sh+2]=$h,Rh[Sh+3]=_h}static multiplyQuaternionsFlat(mi,ni,oi,pi,qi,ri){const si=oi[pi],ti=oi[pi+1],ui=oi[pi+2],vi=oi[pi+3],wi=qi[ri],xi=qi[ri+1],yi=qi[ri+2],zi=qi[ri+3];return mi[ni]=si*zi+vi*wi+ti*yi-ui*xi,mi[ni+1]=ti*zi+vi*xi+ui*wi-si*yi,mi[ni+2]=ui*zi+vi*yi+si*xi-ti*wi,mi[ni+3]=vi*zi-si*wi-ti*xi-ui*yi,mi}get x(){return this._x}set x(Ai){this._x=Ai,this._onChangeCallback()}get y(){return this._y}set y(Bi){this._y=Bi,this._onChangeCallback()}get z(){return this._z}set z(Ci){this._z=Ci,this._onChangeCallback()}get w(){return this._w}set w(Di){this._w=Di,this._onChangeCallback()}set(Ei,Fi,Gi,Hi){return this._x=Ei,this._y=Fi,this._z=Gi,this._w=Hi,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(Ii){return this._x=Ii.x,this._y=Ii.y,this._z=Ii.z,this._w=Ii.w,this._onChangeCallback(),this}setFromEuler(Ji,Ki){if(!(Ji&&Ji.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const Li=Ji._x,Mi=Ji._y,Ni=Ji._z,Oi=Ji._order,Pi=Math.cos,Qi=Math.sin,Ri=Pi(Li/2),Si=Pi(Mi/2),Ti=Pi(Ni/2),Ui=Qi(Li/2),Vi=Qi(Mi/2),Wi=Qi(Ni/2);switch(Oi){case"XYZ":this._x=Ui*Si*Ti+Ri*Vi*Wi,this._y=Ri*Vi*Ti-Ui*Si*Wi,this._z=Ri*Si*Wi+Ui*Vi*Ti,this._w=Ri*Si*Ti-Ui*Vi*Wi;break;case"YXZ":this._x=Ui*Si*Ti+Ri*Vi*Wi,this._y=Ri*Vi*Ti-Ui*Si*Wi,this._z=Ri*Si*Wi-Ui*Vi*Ti,this._w=Ri*Si*Ti+Ui*Vi*Wi;break;case"ZXY":this._x=Ui*Si*Ti-Ri*Vi*Wi,this._y=Ri*Vi*Ti+Ui*Si*Wi,this._z=Ri*Si*Wi+Ui*Vi*Ti,this._w=Ri*Si*Ti-Ui*Vi*Wi;break;case"ZYX":this._x=Ui*Si*Ti-Ri*Vi*Wi,this._y=Ri*Vi*Ti+Ui*Si*Wi,this._z=Ri*Si*Wi-Ui*Vi*Ti,this._w=Ri*Si*Ti+Ui*Vi*Wi;break;case"YZX":this._x=Ui*Si*Ti+Ri*Vi*Wi,this._y=Ri*Vi*Ti+Ui*Si*Wi,this._z=Ri*Si*Wi-Ui*Vi*Ti,this._w=Ri*Si*Ti-Ui*Vi*Wi;break;case"XZY":this._x=Ui*Si*Ti-Ri*Vi*Wi,this._y=Ri*Vi*Ti-Ui*Si*Wi,this._z=Ri*Si*Wi+Ui*Vi*Ti,this._w=Ri*Si*Ti+Ui*Vi*Wi;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+Oi)}return!1!==Ki&&this._onChangeCallback(),this}setFromAxisAngle(Xi,Yi){const Zi=Yi/2,$i=Math.sin(Zi);return this._x=Xi.x*$i,this._y=Xi.y*$i,this._z=Xi.z*$i,this._w=Math.cos(Zi),this._onChangeCallback(),this}setFromRotationMatrix(_i){const aj=_i.elements,bj=aj[0],cj=aj[4],dj=aj[8],ej=aj[1],fj=aj[5],gj=aj[9],hj=aj[2],ij=aj[6],jj=aj[10],kj=bj+fj+jj;if(kj>0){const lj=.5/Math.sqrt(kj+1);this._w=.25/lj,this._x=(ij-gj)*lj,this._y=(dj-hj)*lj,this._z=(ej-cj)*lj}else if(bj>fj&&bj>jj){const mj=2*Math.sqrt(1+bj-fj-jj);this._w=(ij-gj)/mj,this._x=.25*mj,this._y=(cj+ej)/mj,this._z=(dj+hj)/mj}else if(fj>jj){const nj=2*Math.sqrt(1+fj-bj-jj);this._w=(dj-hj)/nj,this._x=(cj+ej)/nj,this._y=.25*nj,this._z=(gj+ij)/nj}else{const oj=2*Math.sqrt(1+jj-bj-fj);this._w=(ej-cj)/oj,this._x=(dj+hj)/oj,this._y=(gj+ij)/oj,this._z=.25*oj}return this._onChangeCallback(),this}setFromUnitVectors(pj,qj){let rj=pj.dot(qj)+1;return rj<Number.EPSILON?(rj=0,Math.abs(pj.x)>Math.abs(pj.z)?(this._x=-pj.y,this._y=pj.x,this._z=0,this._w=rj):(this._x=0,this._y=-pj.z,this._z=pj.y,this._w=rj)):(this._x=pj.y*qj.z-pj.z*qj.y,this._y=pj.z*qj.x-pj.x*qj.z,this._z=pj.x*qj.y-pj.y*qj.x,this._w=rj),this.normalize()}angleTo(sj){return 2*Math.acos(Math.abs(W(this.dot(sj),-1,1)))}rotateTowards(tj,uj){const vj=this.angleTo(tj);if(0===vj)return this;const wj=Math.min(1,uj/vj);return this.slerp(tj,wj),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(xj){return this._x*xj._x+this._y*xj._y+this._z*xj._z+this._w*xj._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let yj=this.length();return 0===yj?(this._x=0,this._y=0,this._z=0,this._w=1):(yj=1/yj,this._x=this._x*yj,this._y=this._y*yj,this._z=this._z*yj,this._w=this._w*yj),this._onChangeCallback(),this}multiply(zj,Aj){return void 0!==Aj?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(zj,Aj)):this.multiplyQuaternions(this,zj)}premultiply(Bj){return this.multiplyQuaternions(Bj,this)}multiplyQuaternions(Cj,Dj){const Ej=Cj._x,Fj=Cj._y,Gj=Cj._z,Hj=Cj._w,Ij=Dj._x,Jj=Dj._y,Kj=Dj._z,Lj=Dj._w;return this._x=Ej*Lj+Hj*Ij+Fj*Kj-Gj*Jj,this._y=Fj*Lj+Hj*Jj+Gj*Ij-Ej*Kj,this._z=Gj*Lj+Hj*Kj+Ej*Jj-Fj*Ij,this._w=Hj*Lj-Ej*Ij-Fj*Jj-Gj*Kj,this._onChangeCallback(),this}slerp(Mj,Nj){if(0===Nj)return this;if(1===Nj)return this.copy(Mj);const Oj=this._x,Pj=this._y,Qj=this._z,Rj=this._w;let Sj=Rj*Mj._w+Oj*Mj._x+Pj*Mj._y+Qj*Mj._z;if(Sj<0?(this._w=-Mj._w,this._x=-Mj._x,this._y=-Mj._y,this._z=-Mj._z,Sj=-Sj):this.copy(Mj),Sj>=1)return this._w=Rj,this._x=Oj,this._y=Pj,this._z=Qj,this;const Tj=1-Sj*Sj;if(Tj<=Number.EPSILON){const Uj=1-Nj;return this._w=Uj*Rj+Nj*this._w,this._x=Uj*Oj+Nj*this._x,this._y=Uj*Pj+Nj*this._y,this._z=Uj*Qj+Nj*this._z,this.normalize(),this._onChangeCallback(),this}const Vj=Math.sqrt(Tj),Wj=Math.atan2(Vj,Sj),Xj=Math.sin((1-Nj)*Wj)/Vj,Yj=Math.sin(Nj*Wj)/Vj;return this._w=Rj*Xj+this._w*Yj,this._x=Oj*Xj+this._x*Yj,this._y=Pj*Xj+this._y*Yj,this._z=Qj*Xj+this._z*Yj,this._onChangeCallback(),this}slerpQuaternions(Zj,$j,_j){return this.copy(Zj).slerp($j,_j)}random(){const ak=Math.random(),bk=Math.sqrt(1-ak),ck=Math.sqrt(ak),dk=2*Math.PI*Math.random(),ek=2*Math.PI*Math.random();return this.set(bk*Math.cos(dk),ck*Math.sin(ek),ck*Math.cos(ek),bk*Math.sin(dk))}equals(fk){return fk._x===this._x&&fk._y===this._y&&fk._z===this._z&&fk._w===this._w}fromArray(gk,hk=0){return this._x=gk[hk],this._y=gk[hk+1],this._z=gk[hk+2],this._w=gk[hk+3],this._onChangeCallback(),this}toArray(ik=[],jk=0){return ik[jk]=this._x,ik[jk+1]=this._y,ik[jk+2]=this._z,ik[jk+3]=this._w,ik}fromBufferAttribute(kk,lk){return this._x=kk.getX(lk),this._y=kk.getY(lk),this._z=kk.getZ(lk),this._w=kk.getW(lk),this}_onChange(mk){return this._onChangeCallback=mk,this}_onChangeCallback(){}}Ih.prototype.isQuaternion=!0;class nk{constructor(ok=0,pk=0,qk=0){this.x=ok,this.y=pk,this.z=qk}set(rk,sk,tk){return void 0===tk&&(tk=this.z),this.x=rk,this.y=sk,this.z=tk,this}setScalar(uk){return this.x=uk,this.y=uk,this.z=uk,this}setX(vk){return this.x=vk,this}setY(wk){return this.y=wk,this}setZ(xk){return this.z=xk,this}setComponent(yk,zk){switch(yk){case 0:this.x=zk;break;case 1:this.y=zk;break;case 2:this.z=zk;break;default:throw new Error("index is out of range: "+yk)}return this}getComponent(Ak){switch(Ak){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+Ak)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(Bk){return this.x=Bk.x,this.y=Bk.y,this.z=Bk.z,this}add(Ck,Dk){return void 0!==Dk?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(Ck,Dk)):(this.x+=Ck.x,this.y+=Ck.y,this.z+=Ck.z,this)}addScalar(Ek){return this.x+=Ek,this.y+=Ek,this.z+=Ek,this}addVectors(Fk,Gk){return this.x=Fk.x+Gk.x,this.y=Fk.y+Gk.y,this.z=Fk.z+Gk.z,this}addScaledVector(Hk,Ik){return this.x+=Hk.x*Ik,this.y+=Hk.y*Ik,this.z+=Hk.z*Ik,this}sub(Jk,Kk){return void 0!==Kk?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(Jk,Kk)):(this.x-=Jk.x,this.y-=Jk.y,this.z-=Jk.z,this)}subScalar(Lk){return this.x-=Lk,this.y-=Lk,this.z-=Lk,this}subVectors(Mk,Nk){return this.x=Mk.x-Nk.x,this.y=Mk.y-Nk.y,this.z=Mk.z-Nk.z,this}multiply(Ok,Pk){return void 0!==Pk?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(Ok,Pk)):(this.x*=Ok.x,this.y*=Ok.y,this.z*=Ok.z,this)}multiplyScalar(Qk){return this.x*=Qk,this.y*=Qk,this.z*=Qk,this}multiplyVectors(Rk,Sk){return this.x=Rk.x*Sk.x,this.y=Rk.y*Sk.y,this.z=Rk.z*Sk.z,this}applyEuler(Tk){return Tk&&Tk.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Sm.setFromEuler(Tk))}applyAxisAngle(Uk,Vk){return this.applyQuaternion(Sm.setFromAxisAngle(Uk,Vk))}applyMatrix3(Wk){const Xk=this.x,Yk=this.y,Zk=this.z,$k=Wk.elements;return this.x=$k[0]*Xk+$k[3]*Yk+$k[6]*Zk,this.y=$k[1]*Xk+$k[4]*Yk+$k[7]*Zk,this.z=$k[2]*Xk+$k[5]*Yk+$k[8]*Zk,this}applyNormalMatrix(_k){return this.applyMatrix3(_k).normalize()}applyMatrix4(al){const bl=this.x,cl=this.y,dl=this.z,el=al.elements,fl=1/(el[3]*bl+el[7]*cl+el[11]*dl+el[15]);return this.x=(el[0]*bl+el[4]*cl+el[8]*dl+el[12])*fl,this.y=(el[1]*bl+el[5]*cl+el[9]*dl+el[13])*fl,this.z=(el[2]*bl+el[6]*cl+el[10]*dl+el[14])*fl,this}applyQuaternion(gl){const hl=this.x,il=this.y,jl=this.z,kl=gl.x,ll=gl.y,ml=gl.z,nl=gl.w,ol=nl*hl+ll*jl-ml*il,pl=nl*il+ml*hl-kl*jl,ql=nl*jl+kl*il-ll*hl,rl=-kl*hl-ll*il-ml*jl;return this.x=ol*nl+ -(rl*kl)+ -(pl*ml)- -(ql*ll),this.y=pl*nl+ -(rl*ll)+ -(ql*kl)- -(ol*ml),this.z=ql*nl+ -(rl*ml)+ -(ol*ll)- -(pl*kl),this}project(sl){return this.applyMatrix4(sl.matrixWorldInverse).applyMatrix4(sl.projectionMatrix)}unproject(tl){return this.applyMatrix4(tl.projectionMatrixInverse).applyMatrix4(tl.matrixWorld)}transformDirection(ul){const vl=this.x,wl=this.y,xl=this.z,yl=ul.elements;return this.x=yl[0]*vl+yl[4]*wl+yl[8]*xl,this.y=yl[1]*vl+yl[5]*wl+yl[9]*xl,this.z=yl[2]*vl+yl[6]*wl+yl[10]*xl,this.normalize()}divide(zl){return this.x/=zl.x,this.y/=zl.y,this.z/=zl.z,this}divideScalar(Al){return this.multiplyScalar(1/Al)}min(Bl){return this.x=Math.min(this.x,Bl.x),this.y=Math.min(this.y,Bl.y),this.z=Math.min(this.z,Bl.z),this}max(Cl){return this.x=Math.max(this.x,Cl.x),this.y=Math.max(this.y,Cl.y),this.z=Math.max(this.z,Cl.z),this}clamp(Dl,El){return this.x=Math.max(Dl.x,Math.min(El.x,this.x)),this.y=Math.max(Dl.y,Math.min(El.y,this.y)),this.z=Math.max(Dl.z,Math.min(El.z,this.z)),this}clampScalar(Fl,Gl){return this.x=Math.max(Fl,Math.min(Gl,this.x)),this.y=Math.max(Fl,Math.min(Gl,this.y)),this.z=Math.max(Fl,Math.min(Gl,this.z)),this}clampLength(Hl,Il){const Jl=this.length();return this.divideScalar(Jl||1).multiplyScalar(Math.max(Hl,Math.min(Il,Jl)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(Kl){return this.x*Kl.x+this.y*Kl.y+this.z*Kl.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(Ll){return this.normalize().multiplyScalar(Ll)}lerp(Ml,Nl){return this.x+=(Ml.x-this.x)*Nl,this.y+=(Ml.y-this.y)*Nl,this.z+=(Ml.z-this.z)*Nl,this}lerpVectors(Ol,Pl,Ql){return this.x=Ol.x+(Pl.x-Ol.x)*Ql,this.y=Ol.y+(Pl.y-Ol.y)*Ql,this.z=Ol.z+(Pl.z-Ol.z)*Ql,this}cross(Rl,Sl){return void 0!==Sl?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(Rl,Sl)):this.crossVectors(this,Rl)}crossVectors(Tl,Ul){const Vl=Tl.x,Wl=Tl.y,Xl=Tl.z,Yl=Ul.x,Zl=Ul.y,$l=Ul.z;return this.x=Wl*$l-Xl*Zl,this.y=Xl*Yl-Vl*$l,this.z=Vl*Zl-Wl*Yl,this}projectOnVector(_l){const am=_l.lengthSq();if(0===am)return this.set(0,0,0);const bm=_l.dot(this)/am;return this.copy(_l).multiplyScalar(bm)}projectOnPlane(cm){return Rm.copy(this).projectOnVector(cm),this.sub(Rm)}reflect(dm){return this.sub(Rm.copy(dm).multiplyScalar(2*this.dot(dm)))}angleTo(em){const fm=Math.sqrt(this.lengthSq()*em.lengthSq());if(0===fm)return Math.PI/2;const gm=this.dot(em)/fm;return Math.acos(W(gm,-1,1))}distanceTo(hm){return Math.sqrt(this.distanceToSquared(hm))}distanceToSquared(im){const jm=this.x-im.x,km=this.y-im.y,lm=this.z-im.z;return jm*jm+km*km+lm*lm}manhattanDistanceTo(mm){return Math.abs(this.x-mm.x)+Math.abs(this.y-mm.y)+Math.abs(this.z-mm.z)}setFromSpherical(nm){return this.setFromSphericalCoords(nm.radius,nm.phi,nm.theta)}setFromSphericalCoords(om,pm,qm){const rm=Math.sin(pm)*om;return this.x=rm*Math.sin(qm),this.y=Math.cos(pm)*om,this.z=rm*Math.cos(qm),this}setFromCylindrical(sm){return this.setFromCylindricalCoords(sm.radius,sm.theta,sm.y)}setFromCylindricalCoords(tm,um,vm){return this.x=tm*Math.sin(um),this.y=vm,this.z=tm*Math.cos(um),this}setFromMatrixPosition(wm){const xm=wm.elements;return this.x=xm[12],this.y=xm[13],this.z=xm[14],this}setFromMatrixScale(ym){const zm=this.setFromMatrixColumn(ym,0).length(),Am=this.setFromMatrixColumn(ym,1).length(),Bm=this.setFromMatrixColumn(ym,2).length();return this.x=zm,this.y=Am,this.z=Bm,this}setFromMatrixColumn(Cm,Dm){return this.fromArray(Cm.elements,4*Dm)}setFromMatrix3Column(Em,Fm){return this.fromArray(Em.elements,3*Fm)}equals(Gm){return Gm.x===this.x&&Gm.y===this.y&&Gm.z===this.z}fromArray(Hm,Im=0){return this.x=Hm[Im],this.y=Hm[Im+1],this.z=Hm[Im+2],this}toArray(Jm=[],Km=0){return Jm[Km]=this.x,Jm[Km+1]=this.y,Jm[Km+2]=this.z,Jm}fromBufferAttribute(Lm,Mm,Nm){return void 0!==Nm&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=Lm.getX(Mm),this.y=Lm.getY(Mm),this.z=Lm.getZ(Mm),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const Om=(Math.random()-.5)*2,Pm=Math.random()*Math.PI*2,Qm=Math.sqrt(1-Om**2);return this.x=Qm*Math.cos(Pm),this.y=Qm*Math.sin(Pm),this.z=Om,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}nk.prototype.isVector3=!0;const Rm=new nk(),Sm=new Ih();class Tm{constructor(Um=new nk(Infinity,Infinity,Infinity),Vm=new nk(-1/0,-1/0,-1/0)){this.min=Um,this.max=Vm}set(Wm,Xm){return this.min.copy(Wm),this.max.copy(Xm),this}setFromArray(Ym){let Zm=Infinity,$m=Infinity,_m=Infinity,an=-1/0,bn=-1/0,cn=-1/0;for(let dn=0,en=Ym.length;dn<en;dn+=3){const fn=Ym[dn],gn=Ym[dn+1],hn=Ym[dn+2];fn<Zm&&(Zm=fn),gn<$m&&($m=gn),hn<_m&&(_m=hn),fn>an&&(an=fn),gn>bn&&(bn=gn),hn>cn&&(cn=hn)}return this.min.set(Zm,$m,_m),this.max.set(an,bn,cn),this}setFromBufferAttribute(jn){let kn=Infinity,ln=Infinity,mn=Infinity,nn=-1/0,on=-1/0,pn=-1/0;for(let qn=0,rn=jn.count;qn<rn;qn++){const sn=jn.getX(qn),tn=jn.getY(qn),un=jn.getZ(qn);sn<kn&&(kn=sn),tn<ln&&(ln=tn),un<mn&&(mn=un),sn>nn&&(nn=sn),tn>on&&(on=tn),un>pn&&(pn=un)}return this.min.set(kn,ln,mn),this.max.set(nn,on,pn),this}setFromPoints(vn){this.makeEmpty();for(let wn=0,xn=vn.length;wn<xn;wn++)this.expandByPoint(vn[wn]);return this}setFromCenterAndSize(yn,zn){const An=no.copy(zn).multiplyScalar(.5);return this.min.copy(yn).sub(An),this.max.copy(yn).add(An),this}setFromObject(Bn,Cn=!1){return this.makeEmpty(),this.expandByObject(Bn,Cn)}clone(){return new this.constructor().copy(this)}copy(Dn){return this.min.copy(Dn.min),this.max.copy(Dn.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=Infinity,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(En){return this.isEmpty()?En.set(0,0,0):En.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(Fn){return this.isEmpty()?Fn.set(0,0,0):Fn.subVectors(this.max,this.min)}expandByPoint(Gn){return this.min.min(Gn),this.max.max(Gn),this}expandByVector(Hn){return this.min.sub(Hn),this.max.add(Hn),this}expandByScalar(In){return this.min.addScalar(-In),this.max.addScalar(In),this}expandByObject(Jn,Kn=!1){Jn.updateWorldMatrix(!1,!1);const Ln=Jn.geometry;if(void 0!==Ln)if(Kn&& void 0!=Ln.attributes&& void 0!==Ln.attributes.position){const Mn=Ln.attributes.position;for(let Nn=0,On=Mn.count;Nn<On;Nn++)no.fromBufferAttribute(Mn,Nn).applyMatrix4(Jn.matrixWorld),this.expandByPoint(no)}else null===Ln.boundingBox&&Ln.computeBoundingBox(),oo.copy(Ln.boundingBox),oo.applyMatrix4(Jn.matrixWorld),this.union(oo);const Pn=Jn.children;for(let Qn=0,Rn=Pn.length;Qn<Rn;Qn++)this.expandByObject(Pn[Qn],Kn);return this}containsPoint(Sn){return!(Sn.x<this.min.x)&&!(Sn.x>this.max.x)&&!(Sn.y<this.min.y)&&!(Sn.y>this.max.y)&&!(Sn.z<this.min.z)&&!(Sn.z>this.max.z)}containsBox(Tn){return this.min.x<=Tn.min.x&&Tn.max.x<=this.max.x&&this.min.y<=Tn.min.y&&Tn.max.y<=this.max.y&&this.min.z<=Tn.min.z&&Tn.max.z<=this.max.z}getParameter(Un,Vn){return Vn.set((Un.x-this.min.x)/(this.max.x-this.min.x),(Un.y-this.min.y)/(this.max.y-this.min.y),(Un.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(Wn){return!(Wn.max.x<this.min.x)&&!(Wn.min.x>this.max.x)&&!(Wn.max.y<this.min.y)&&!(Wn.min.y>this.max.y)&&!(Wn.max.z<this.min.z)&&!(Wn.min.z>this.max.z)}intersectsSphere(Xn){return this.clampPoint(Xn.center,no),no.distanceToSquared(Xn.center)<=Xn.radius*Xn.radius}intersectsPlane(Yn){let Zn,$n;return Yn.normal.x>0?(Zn=Yn.normal.x*this.min.x,$n=Yn.normal.x*this.max.x):(Zn=Yn.normal.x*this.max.x,$n=Yn.normal.x*this.min.x),Yn.normal.y>0?(Zn+=Yn.normal.y*this.min.y,$n+=Yn.normal.y*this.max.y):(Zn+=Yn.normal.y*this.max.y,$n+=Yn.normal.y*this.min.y),Yn.normal.z>0?(Zn+=Yn.normal.z*this.min.z,$n+=Yn.normal.z*this.max.z):(Zn+=Yn.normal.z*this.max.z,$n+=Yn.normal.z*this.min.z),Zn<= -Yn.constant&&$n>= -Yn.constant}intersectsTriangle(_n){if(this.isEmpty())return!1;this.getCenter(vo),wo.subVectors(this.max,vo),po.subVectors(_n.a,vo),qo.subVectors(_n.b,vo),ro.subVectors(_n.c,vo),so.subVectors(qo,po),to.subVectors(ro,qo),uo.subVectors(po,ro);let ao=[0,-so.z,so.y,0,-to.z,to.y,0,-uo.z,uo.y,so.z,0,-so.x,to.z,0,-to.x,uo.z,0,-uo.x,-so.y,so.x,0,-to.y,to.x,0,-uo.y,uo.x,0];return!!zo(ao,po,qo,ro,wo)&& !!zo(ao=[1,0,0,0,1,0,0,0,1],po,qo,ro,wo)&&(xo.crossVectors(so,to),zo(ao=[xo.x,xo.y,xo.z],po,qo,ro,wo))}clampPoint(bo,co){return co.copy(bo).clamp(this.min,this.max)}distanceToPoint(eo){const fo=no.copy(eo).clamp(this.min,this.max);return fo.sub(eo).length()}getBoundingSphere(go){return this.getCenter(go.center),go.radius=.5*this.getSize(no).length(),go}intersect(ho){return this.min.max(ho.min),this.max.min(ho.max),this.isEmpty()&&this.makeEmpty(),this}union(io){return this.min.min(io.min),this.max.max(io.max),this}applyMatrix4(jo){return this.isEmpty()||(mo[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(jo),mo[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(jo),mo[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(jo),mo[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(jo),mo[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(jo),mo[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(jo),mo[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(jo),mo[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(jo),this.setFromPoints(mo)),this}translate(ko){return this.min.add(ko),this.max.add(ko),this}equals(lo){return lo.min.equals(this.min)&&lo.max.equals(this.max)}}Tm.prototype.isBox3=!0;const mo=[new nk(),new nk(),new nk(),new nk(),new nk(),new nk(),new nk(),new nk()],no=new nk(),oo=new Tm(),po=new nk(),qo=new nk(),ro=new nk(),so=new nk(),to=new nk(),uo=new nk(),vo=new nk(),wo=new nk(),xo=new nk(),yo=new nk();function zo(a,b,c,d,e){for(let f=0,g=a.length-3;f<=g;f+=3){yo.fromArray(a,f);const h=e.x*Math.abs(yo.x)+e.y*Math.abs(yo.y)+e.z*Math.abs(yo.z),i=b.dot(yo),j=c.dot(yo),k=d.dot(yo);if(Math.max(-Math.max(i,j,k),Math.min(i,j,k))>h)return!1}return!0}const Ao=new Tm(),Bo=new nk(),Co=new nk(),Do=new nk();class Eo{constructor(Fo=new nk(),Go=-1){this.center=Fo,this.radius=Go}set(Ho,Io){return this.center.copy(Ho),this.radius=Io,this}setFromPoints(Jo,Ko){const Lo=this.center;void 0!==Ko?Lo.copy(Ko):Ao.setFromPoints(Jo).getCenter(Lo);let Mo=0;for(let No=0,Oo=Jo.length;No<Oo;No++)Mo=Math.max(Mo,Lo.distanceToSquared(Jo[No]));return this.radius=Math.sqrt(Mo),this}copy(Po){return this.center.copy(Po.center),this.radius=Po.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(Qo){return Qo.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(Ro){return Ro.distanceTo(this.center)-this.radius}intersectsSphere(So){const To=this.radius+So.radius;return So.center.distanceToSquared(this.center)<=To*To}intersectsBox(Uo){return Uo.intersectsSphere(this)}intersectsPlane(Vo){return Math.abs(Vo.distanceToPoint(this.center))<=this.radius}clampPoint(Wo,Xo){const Yo=this.center.distanceToSquared(Wo);return Xo.copy(Wo),Yo>this.radius*this.radius&&(Xo.sub(this.center).normalize(),Xo.multiplyScalar(this.radius).add(this.center)),Xo}getBoundingBox(Zo){return this.isEmpty()?(Zo.makeEmpty(),Zo):(Zo.set(this.center,this.center),Zo.expandByScalar(this.radius),Zo)}applyMatrix4($o){return this.center.applyMatrix4($o),this.radius=this.radius*$o.getMaxScaleOnAxis(),this}translate(_o){return this.center.add(_o),this}expandByPoint(ap){Do.subVectors(ap,this.center);const bp=Do.lengthSq();if(bp>this.radius*this.radius){const cp=Math.sqrt(bp),dp=(cp-this.radius)*.5;this.center.add(Do.multiplyScalar(dp/cp)),this.radius+=dp}return this}union(ep){return!0===this.center.equals(ep.center)?Co.set(0,0,1).multiplyScalar(ep.radius):Co.subVectors(ep.center,this.center).normalize().multiplyScalar(ep.radius),this.expandByPoint(Bo.copy(ep.center).add(Co)),this.expandByPoint(Bo.copy(ep.center).sub(Co)),this}equals(fp){return fp.center.equals(this.center)&&fp.radius===this.radius}clone(){return new this.constructor().copy(this)}}const gp=new nk(),hp=new nk(),ip=new nk(),jp=new nk(),kp=new nk(),lp=new nk(),mp=new nk();class np{constructor(op=new nk(),pp=new nk(0,0,-1)){this.origin=op,this.direction=pp}set(qp,rp){return this.origin.copy(qp),this.direction.copy(rp),this}copy(sp){return this.origin.copy(sp.origin),this.direction.copy(sp.direction),this}at(tp,up){return up.copy(this.direction).multiplyScalar(tp).add(this.origin)}lookAt(vp){return this.direction.copy(vp).sub(this.origin).normalize(),this}recast(wp){return this.origin.copy(this.at(wp,gp)),this}closestPointToPoint(xp,yp){yp.subVectors(xp,this.origin);const zp=yp.dot(this.direction);return zp<0?yp.copy(this.origin):yp.copy(this.direction).multiplyScalar(zp).add(this.origin)}distanceToPoint(Ap){return Math.sqrt(this.distanceSqToPoint(Ap))}distanceSqToPoint(Bp){const Cp=gp.subVectors(Bp,this.origin).dot(this.direction);return Cp<0?this.origin.distanceToSquared(Bp):(gp.copy(this.direction).multiplyScalar(Cp).add(this.origin),gp.distanceToSquared(Bp))}distanceSqToSegment(Dp,Ep,Fp,Gp){hp.copy(Dp).add(Ep).multiplyScalar(.5),ip.copy(Ep).sub(Dp).normalize(),jp.copy(this.origin).sub(hp);const Hp=.5*Dp.distanceTo(Ep),Ip=-this.direction.dot(ip),Jp=jp.dot(this.direction),Kp=-jp.dot(ip),Lp=jp.lengthSq(),Mp=Math.abs(1-Ip*Ip);let Np,Op,Pp,Qp;if(Mp>0)if(Np=Ip*Kp-Jp,Op=Ip*Jp-Kp,Qp=Hp*Mp,Np>=0)if(Op>= -Qp)if(Op<=Qp){const Rp=1/Mp;Np*=Rp,Op*=Rp,Pp=Np*(Np+Ip*Op+2*Jp)+Op*(Ip*Np+Op+2*Kp)+Lp}else Pp=-(Np=Math.max(0,-(Ip*(Op=Hp)+Jp)))*Np+Op*(Op+2*Kp)+Lp;else Pp=-(Np=Math.max(0,-(Ip*(Op=-Hp)+Jp)))*Np+Op*(Op+2*Kp)+Lp;else Op<= -Qp?(Op=(Np=Math.max(0,-(-Ip*Hp+Jp)))>0?-Hp:Math.min(Math.max(-Hp,-Kp),Hp),Pp=-Np*Np+Op*(Op+2*Kp)+Lp):Op<=Qp?(Np=0,Pp=(Op=Math.min(Math.max(-Hp,-Kp),Hp))*(Op+2*Kp)+Lp):(Op=(Np=Math.max(0,-(Ip*Hp+Jp)))>0?Hp:Math.min(Math.max(-Hp,-Kp),Hp),Pp=-Np*Np+Op*(Op+2*Kp)+Lp);else Op=Ip>0?-Hp:Hp,Np=Math.max(0,-(Ip*Op+Jp)),Pp=-Np*Np+Op*(Op+2*Kp)+Lp;return Fp&&Fp.copy(this.direction).multiplyScalar(Np).add(this.origin),Gp&&Gp.copy(ip).multiplyScalar(Op).add(hp),Pp}intersectSphere(Sp,Tp){gp.subVectors(Sp.center,this.origin);const Up=gp.dot(this.direction),Vp=gp.dot(gp)-Up*Up,Wp=Sp.radius*Sp.radius;if(Vp>Wp)return null;const Xp=Math.sqrt(Wp-Vp),Yp=Up-Xp,Zp=Up+Xp;return Yp<0&&Zp<0?null:Yp<0?this.at(Zp,Tp):this.at(Yp,Tp)}intersectsSphere($p){return this.distanceSqToPoint($p.center)<=$p.radius*$p.radius}distanceToPlane(_p){const aq=_p.normal.dot(this.direction);if(0===aq)return 0===_p.distanceToPoint(this.origin)?0:null;const bq=-(this.origin.dot(_p.normal)+_p.constant)/aq;return bq>=0?bq:null}intersectPlane(cq,dq){const eq=this.distanceToPlane(cq);return null===eq?null:this.at(eq,dq)}intersectsPlane(fq){const gq=fq.distanceToPoint(this.origin);if(0===gq)return!0;const hq=fq.normal.dot(this.direction);return hq*gq<0}intersectBox(iq,jq){let kq,lq,mq,nq,oq,pq;const qq=1/this.direction.x,rq=1/this.direction.y,sq=1/this.direction.z,tq=this.origin;return(qq>=0?(kq=(iq.min.x-tq.x)*qq,lq=(iq.max.x-tq.x)*qq):(kq=(iq.max.x-tq.x)*qq,lq=(iq.min.x-tq.x)*qq),rq>=0?(mq=(iq.min.y-tq.y)*rq,nq=(iq.max.y-tq.y)*rq):(mq=(iq.max.y-tq.y)*rq,nq=(iq.min.y-tq.y)*rq),kq>nq||mq>lq)?null:((mq>kq||kq!=kq)&&(kq=mq),(nq<lq||lq!=lq)&&(lq=nq),sq>=0?(oq=(iq.min.z-tq.z)*sq,pq=(iq.max.z-tq.z)*sq):(oq=(iq.max.z-tq.z)*sq,pq=(iq.min.z-tq.z)*sq),kq>pq||oq>lq)?null:((oq>kq||kq!=kq)&&(kq=oq),(pq<lq||lq!=lq)&&(lq=pq),lq<0)?null:this.at(kq>=0?kq:lq,jq)}intersectsBox(uq){return null!==this.intersectBox(uq,gp)}intersectTriangle(vq,wq,xq,yq,zq){kp.subVectors(wq,vq),lp.subVectors(xq,vq),mp.crossVectors(kp,lp);let Aq=this.direction.dot(mp),Bq;if(Aq>0){if(yq)return null;Bq=1}else{if(!(Aq<0))return null;Bq=-1,Aq=-Aq}jp.subVectors(this.origin,vq);const Cq=Bq*this.direction.dot(lp.crossVectors(jp,lp));if(Cq<0)return null;const Dq=Bq*this.direction.dot(kp.cross(jp));if(Dq<0)return null;if(Cq+Dq>Aq)return null;const Eq=-Bq*jp.dot(mp);return Eq<0?null:this.at(Eq/Aq,zq)}applyMatrix4(Fq){return this.origin.applyMatrix4(Fq),this.direction.transformDirection(Fq),this}equals(Gq){return Gq.origin.equals(this.origin)&&Gq.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Hq{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(Iq,Jq,Kq,Lq,Mq,Nq,Oq,Pq,Qq,Rq,Sq,Tq,Uq,Vq,Wq,Xq){const Yq=this.elements;return Yq[0]=Iq,Yq[4]=Jq,Yq[8]=Kq,Yq[12]=Lq,Yq[1]=Mq,Yq[5]=Nq,Yq[9]=Oq,Yq[13]=Pq,Yq[2]=Qq,Yq[6]=Rq,Yq[10]=Sq,Yq[14]=Tq,Yq[3]=Uq,Yq[7]=Vq,Yq[11]=Wq,Yq[15]=Xq,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Hq().fromArray(this.elements)}copy(Zq){const $q=this.elements,_q=Zq.elements;return $q[0]=_q[0],$q[1]=_q[1],$q[2]=_q[2],$q[3]=_q[3],$q[4]=_q[4],$q[5]=_q[5],$q[6]=_q[6],$q[7]=_q[7],$q[8]=_q[8],$q[9]=_q[9],$q[10]=_q[10],$q[11]=_q[11],$q[12]=_q[12],$q[13]=_q[13],$q[14]=_q[14],$q[15]=_q[15],this}copyPosition(ar){const br=this.elements,cr=ar.elements;return br[12]=cr[12],br[13]=cr[13],br[14]=cr[14],this}setFromMatrix3(dr){const er=dr.elements;return this.set(er[0],er[3],er[6],0,er[1],er[4],er[7],0,er[2],er[5],er[8],0,0,0,0,1),this}extractBasis(fr,gr,hr){return fr.setFromMatrixColumn(this,0),gr.setFromMatrixColumn(this,1),hr.setFromMatrixColumn(this,2),this}makeBasis(ir,jr,kr){return this.set(ir.x,jr.x,kr.x,0,ir.y,jr.y,kr.y,0,ir.z,jr.z,kr.z,0,0,0,0,1),this}extractRotation(lr){const mr=this.elements,nr=lr.elements,or=1/Ev.setFromMatrixColumn(lr,0).length(),pr=1/Ev.setFromMatrixColumn(lr,1).length(),qr=1/Ev.setFromMatrixColumn(lr,2).length();return mr[0]=nr[0]*or,mr[1]=nr[1]*or,mr[2]=nr[2]*or,mr[3]=0,mr[4]=nr[4]*pr,mr[5]=nr[5]*pr,mr[6]=nr[6]*pr,mr[7]=0,mr[8]=nr[8]*qr,mr[9]=nr[9]*qr,mr[10]=nr[10]*qr,mr[11]=0,mr[12]=0,mr[13]=0,mr[14]=0,mr[15]=1,this}makeRotationFromEuler(rr){rr&&rr.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const sr=this.elements,tr=rr.x,ur=rr.y,vr=rr.z,wr=Math.cos(tr),xr=Math.sin(tr),yr=Math.cos(ur),zr=Math.sin(ur),Ar=Math.cos(vr),Br=Math.sin(vr);if("XYZ"===rr.order){const Cr=wr*Ar,Dr=wr*Br,Er=xr*Ar,Fr=xr*Br;sr[0]=yr*Ar,sr[4]=-yr*Br,sr[8]=zr,sr[1]=Dr+Er*zr,sr[5]=Cr-Fr*zr,sr[9]=-xr*yr,sr[2]=Fr-Cr*zr,sr[6]=Er+Dr*zr,sr[10]=wr*yr}else if("YXZ"===rr.order){const Gr=yr*Ar,Hr=yr*Br,Ir=zr*Ar,Jr=zr*Br;sr[0]=Gr+Jr*xr,sr[4]=Ir*xr-Hr,sr[8]=wr*zr,sr[1]=wr*Br,sr[5]=wr*Ar,sr[9]=-xr,sr[2]=Hr*xr-Ir,sr[6]=Jr+Gr*xr,sr[10]=wr*yr}else if("ZXY"===rr.order){const Kr=yr*Ar,Lr=yr*Br,Mr=zr*Ar,Nr=zr*Br;sr[0]=Kr-Nr*xr,sr[4]=-wr*Br,sr[8]=Mr+Lr*xr,sr[1]=Lr+Mr*xr,sr[5]=wr*Ar,sr[9]=Nr-Kr*xr,sr[2]=-wr*zr,sr[6]=xr,sr[10]=wr*yr}else if("ZYX"===rr.order){const Or=wr*Ar,Pr=wr*Br,Qr=xr*Ar,Rr=xr*Br;sr[0]=yr*Ar,sr[4]=Qr*zr-Pr,sr[8]=Or*zr+Rr,sr[1]=yr*Br,sr[5]=Rr*zr+Or,sr[9]=Pr*zr-Qr,sr[2]=-zr,sr[6]=xr*yr,sr[10]=wr*yr}else if("YZX"===rr.order){const Sr=wr*yr,Tr=wr*zr,Ur=xr*yr,Vr=xr*zr;sr[0]=yr*Ar,sr[4]=Vr-Sr*Br,sr[8]=Ur*Br+Tr,sr[1]=Br,sr[5]=wr*Ar,sr[9]=-xr*Ar,sr[2]=-zr*Ar,sr[6]=Tr*Br+Ur,sr[10]=Sr-Vr*Br}else if("XZY"===rr.order){const Wr=wr*yr,Xr=wr*zr,Yr=xr*yr,Zr=xr*zr;sr[0]=yr*Ar,sr[4]=-Br,sr[8]=zr*Ar,sr[1]=Wr*Br+Zr,sr[5]=wr*Ar,sr[9]=Xr*Br-Yr,sr[2]=Yr*Br-Xr,sr[6]=xr*Ar,sr[10]=Zr*Br+Wr}return sr[3]=0,sr[7]=0,sr[11]=0,sr[12]=0,sr[13]=0,sr[14]=0,sr[15]=1,this}makeRotationFromQuaternion($r){return this.compose(Gv,$r,Hv)}lookAt(_r,as,bs){const cs=this.elements;return Kv.subVectors(_r,as),0===Kv.lengthSq()&&(Kv.z=1),Kv.normalize(),Iv.crossVectors(bs,Kv),0===Iv.lengthSq()&&(1===Math.abs(bs.z)?Kv.x+=1e-4:Kv.z+=1e-4,Kv.normalize(),Iv.crossVectors(bs,Kv)),Iv.normalize(),Jv.crossVectors(Kv,Iv),cs[0]=Iv.x,cs[4]=Jv.x,cs[8]=Kv.x,cs[1]=Iv.y,cs[5]=Jv.y,cs[9]=Kv.y,cs[2]=Iv.z,cs[6]=Jv.z,cs[10]=Kv.z,this}multiply(ds,es){return void 0!==es?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(ds,es)):this.multiplyMatrices(this,ds)}premultiply(fs){return this.multiplyMatrices(fs,this)}multiplyMatrices(gs,hs){const is=gs.elements,js=hs.elements,ks=this.elements,ls=is[0],ms=is[4],ns=is[8],os=is[12],ps=is[1],qs=is[5],rs=is[9],ss=is[13],ts=is[2],us=is[6],vs=is[10],ws=is[14],xs=is[3],ys=is[7],zs=is[11],As=is[15],Bs=js[0],Cs=js[4],Ds=js[8],Es=js[12],Fs=js[1],Gs=js[5],Hs=js[9],Is=js[13],Js=js[2],Ks=js[6],Ls=js[10],Ms=js[14],Ns=js[3],Os=js[7],Ps=js[11],Qs=js[15];return ks[0]=ls*Bs+ms*Fs+ns*Js+os*Ns,ks[4]=ls*Cs+ms*Gs+ns*Ks+os*Os,ks[8]=ls*Ds+ms*Hs+ns*Ls+os*Ps,ks[12]=ls*Es+ms*Is+ns*Ms+os*Qs,ks[1]=ps*Bs+qs*Fs+rs*Js+ss*Ns,ks[5]=ps*Cs+qs*Gs+rs*Ks+ss*Os,ks[9]=ps*Ds+qs*Hs+rs*Ls+ss*Ps,ks[13]=ps*Es+qs*Is+rs*Ms+ss*Qs,ks[2]=ts*Bs+us*Fs+vs*Js+ws*Ns,ks[6]=ts*Cs+us*Gs+vs*Ks+ws*Os,ks[10]=ts*Ds+us*Hs+vs*Ls+ws*Ps,ks[14]=ts*Es+us*Is+vs*Ms+ws*Qs,ks[3]=xs*Bs+ys*Fs+zs*Js+As*Ns,ks[7]=xs*Cs+ys*Gs+zs*Ks+As*Os,ks[11]=xs*Ds+ys*Hs+zs*Ls+As*Ps,ks[15]=xs*Es+ys*Is+zs*Ms+As*Qs,this}multiplyScalar(Rs){const Ss=this.elements;return Ss[0]*=Rs,Ss[4]*=Rs,Ss[8]*=Rs,Ss[12]*=Rs,Ss[1]*=Rs,Ss[5]*=Rs,Ss[9]*=Rs,Ss[13]*=Rs,Ss[2]*=Rs,Ss[6]*=Rs,Ss[10]*=Rs,Ss[14]*=Rs,Ss[3]*=Rs,Ss[7]*=Rs,Ss[11]*=Rs,Ss[15]*=Rs,this}determinant(){const Ts=this.elements,Us=Ts[0],Vs=Ts[4],Ws=Ts[8],Xs=Ts[12],Ys=Ts[1],Zs=Ts[5],$s=Ts[9],_s=Ts[13],at=Ts[2],bt=Ts[6],ct=Ts[10],dt=Ts[14],et=Ts[3],ft=Ts[7],gt=Ts[11],ht=Ts[15];return et*(+Xs*$s*bt-Ws*_s*bt-Xs*Zs*ct+Vs*_s*ct+Ws*Zs*dt-Vs*$s*dt)+ft*(+Us*$s*dt-Us*_s*ct+Xs*Ys*ct-Ws*Ys*dt+Ws*_s*at-Xs*$s*at)+gt*(+Us*_s*bt-Us*Zs*dt-Xs*Ys*bt+Vs*Ys*dt+Xs*Zs*at-Vs*_s*at)+ht*(-Ws*Zs*at-Us*$s*bt+Us*Zs*ct+Ws*Ys*bt-Vs*Ys*ct+Vs*$s*at)}transpose(){const it=this.elements;let jt;return jt=it[1],it[1]=it[4],it[4]=jt,jt=it[2],it[2]=it[8],it[8]=jt,jt=it[6],it[6]=it[9],it[9]=jt,jt=it[3],it[3]=it[12],it[12]=jt,jt=it[7],it[7]=it[13],it[13]=jt,jt=it[11],it[11]=it[14],it[14]=jt,this}setPosition(kt,lt,mt){const nt=this.elements;return kt.isVector3?(nt[12]=kt.x,nt[13]=kt.y,nt[14]=kt.z):(nt[12]=kt,nt[13]=lt,nt[14]=mt),this}invert(){const ot=this.elements,pt=ot[0],qt=ot[1],rt=ot[2],st=ot[3],tt=ot[4],ut=ot[5],vt=ot[6],wt=ot[7],xt=ot[8],yt=ot[9],zt=ot[10],At=ot[11],Bt=ot[12],Ct=ot[13],Dt=ot[14],Et=ot[15],Ft=yt*Dt*wt-Ct*zt*wt+Ct*vt*At-ut*Dt*At-yt*vt*Et+ut*zt*Et,Gt=Bt*zt*wt-xt*Dt*wt-Bt*vt*At+tt*Dt*At+xt*vt*Et-tt*zt*Et,Ht=xt*Ct*wt-Bt*yt*wt+Bt*ut*At-tt*Ct*At-xt*ut*Et+tt*yt*Et,It=Bt*yt*vt-xt*Ct*vt-Bt*ut*zt+tt*Ct*zt+xt*ut*Dt-tt*yt*Dt,Jt=pt*Ft+qt*Gt+rt*Ht+st*It;if(0===Jt)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const Kt=1/Jt;return ot[0]=Ft*Kt,ot[1]=(Ct*zt*st-yt*Dt*st-Ct*rt*At+qt*Dt*At+yt*rt*Et-qt*zt*Et)*Kt,ot[2]=(ut*Dt*st-Ct*vt*st+Ct*rt*wt-qt*Dt*wt-ut*rt*Et+qt*vt*Et)*Kt,ot[3]=(yt*vt*st-ut*zt*st-yt*rt*wt+qt*zt*wt+ut*rt*At-qt*vt*At)*Kt,ot[4]=Gt*Kt,ot[5]=(xt*Dt*st-Bt*zt*st+Bt*rt*At-pt*Dt*At-xt*rt*Et+pt*zt*Et)*Kt,ot[6]=(Bt*vt*st-tt*Dt*st-Bt*rt*wt+pt*Dt*wt+tt*rt*Et-pt*vt*Et)*Kt,ot[7]=(tt*zt*st-xt*vt*st+xt*rt*wt-pt*zt*wt-tt*rt*At+pt*vt*At)*Kt,ot[8]=Ht*Kt,ot[9]=(Bt*yt*st-xt*Ct*st-Bt*qt*At+pt*Ct*At+xt*qt*Et-pt*yt*Et)*Kt,ot[10]=(tt*Ct*st-Bt*ut*st+Bt*qt*wt-pt*Ct*wt-tt*qt*Et+pt*ut*Et)*Kt,ot[11]=(xt*ut*st-tt*yt*st-xt*qt*wt+pt*yt*wt+tt*qt*At-pt*ut*At)*Kt,ot[12]=It*Kt,ot[13]=(xt*Ct*rt-Bt*yt*rt+Bt*qt*zt-pt*Ct*zt-xt*qt*Dt+pt*yt*Dt)*Kt,ot[14]=(Bt*ut*rt-tt*Ct*rt-Bt*qt*vt+pt*Ct*vt+tt*qt*Dt-pt*ut*Dt)*Kt,ot[15]=(tt*yt*rt-xt*ut*rt+xt*qt*vt-pt*yt*vt-tt*qt*zt+pt*ut*zt)*Kt,this}scale(Lt){const Mt=this.elements,Nt=Lt.x,Ot=Lt.y,Pt=Lt.z;return Mt[0]*=Nt,Mt[4]*=Ot,Mt[8]*=Pt,Mt[1]*=Nt,Mt[5]*=Ot,Mt[9]*=Pt,Mt[2]*=Nt,Mt[6]*=Ot,Mt[10]*=Pt,Mt[3]*=Nt,Mt[7]*=Ot,Mt[11]*=Pt,this}getMaxScaleOnAxis(){const Qt=this.elements,Rt=Qt[0]*Qt[0]+Qt[1]*Qt[1]+Qt[2]*Qt[2],St=Qt[4]*Qt[4]+Qt[5]*Qt[5]+Qt[6]*Qt[6],Tt=Qt[8]*Qt[8]+Qt[9]*Qt[9]+Qt[10]*Qt[10];return Math.sqrt(Math.max(Rt,St,Tt))}makeTranslation(Ut,Vt,Wt){return this.set(1,0,0,Ut,0,1,0,Vt,0,0,1,Wt,0,0,0,1),this}makeRotationX(Xt){const Yt=Math.cos(Xt),Zt=Math.sin(Xt);return this.set(1,0,0,0,0,Yt,-Zt,0,0,Zt,Yt,0,0,0,0,1),this}makeRotationY($t){const _t=Math.cos($t),au=Math.sin($t);return this.set(_t,0,au,0,0,1,0,0,-au,0,_t,0,0,0,0,1),this}makeRotationZ(bu){const cu=Math.cos(bu),du=Math.sin(bu);return this.set(cu,-du,0,0,du,cu,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(eu,fu){const gu=Math.cos(fu),hu=Math.sin(fu),iu=1-gu,ju=eu.x,ku=eu.y,lu=eu.z,mu=iu*ju,nu=iu*ku;return this.set(mu*ju+gu,mu*ku-hu*lu,mu*lu+hu*ku,0,mu*ku+hu*lu,nu*ku+gu,nu*lu-hu*ju,0,mu*lu-hu*ku,nu*lu+hu*ju,iu*lu*lu+gu,0,0,0,0,1),this}makeScale(ou,pu,qu){return this.set(ou,0,0,0,0,pu,0,0,0,0,qu,0,0,0,0,1),this}makeShear(ru,su,tu,uu,vu,wu){return this.set(1,tu,vu,0,ru,1,wu,0,su,uu,1,0,0,0,0,1),this}compose(xu,yu,zu){const Au=this.elements,Bu=yu._x,Cu=yu._y,Du=yu._z,Eu=yu._w,Fu=Bu+Bu,Gu=Cu+Cu,Hu=Du+Du,Iu=Bu*Fu,Ju=Bu*Gu,Ku=Bu*Hu,Lu=Cu*Gu,Mu=Cu*Hu,Nu=Du*Hu,Ou=Eu*Fu,Pu=Eu*Gu,Qu=Eu*Hu,Ru=zu.x,Su=zu.y,Tu=zu.z;return Au[0]=(1-(Lu+Nu))*Ru,Au[1]=(Ju+Qu)*Ru,Au[2]=(Ku-Pu)*Ru,Au[3]=0,Au[4]=(Ju-Qu)*Su,Au[5]=(1-(Iu+Nu))*Su,Au[6]=(Mu+Ou)*Su,Au[7]=0,Au[8]=(Ku+Pu)*Tu,Au[9]=(Mu-Ou)*Tu,Au[10]=(1-(Iu+Lu))*Tu,Au[11]=0,Au[12]=xu.x,Au[13]=xu.y,Au[14]=xu.z,Au[15]=1,this}decompose(Uu,Vu,Wu){const Xu=this.elements;let Yu=Ev.set(Xu[0],Xu[1],Xu[2]).length();const Zu=Ev.set(Xu[4],Xu[5],Xu[6]).length(),$u=Ev.set(Xu[8],Xu[9],Xu[10]).length(),_u=this.determinant();_u<0&&(Yu=-Yu),Uu.x=Xu[12],Uu.y=Xu[13],Uu.z=Xu[14],Fv.copy(this);const av=1/Yu,bv=1/Zu,cv=1/$u;return Fv.elements[0]*=av,Fv.elements[1]*=av,Fv.elements[2]*=av,Fv.elements[4]*=bv,Fv.elements[5]*=bv,Fv.elements[6]*=bv,Fv.elements[8]*=cv,Fv.elements[9]*=cv,Fv.elements[10]*=cv,Vu.setFromRotationMatrix(Fv),Wu.x=Yu,Wu.y=Zu,Wu.z=$u,this}makePerspective(dv,ev,fv,gv,hv,iv){void 0===iv&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const jv=this.elements;return jv[0]=2*hv/(ev-dv),jv[4]=0,jv[8]=(ev+dv)/(ev-dv),jv[12]=0,jv[1]=0,jv[5]=2*hv/(fv-gv),jv[9]=(fv+gv)/(fv-gv),jv[13]=0,jv[2]=0,jv[6]=0,jv[10]=-(iv+hv)/(iv-hv),jv[14]=-2*iv*hv/(iv-hv),jv[3]=0,jv[7]=0,jv[11]=-1,jv[15]=0,this}makeOrthographic(kv,lv,mv,nv,ov,pv){const qv=this.elements,rv=1/(lv-kv),sv=1/(mv-nv),tv=1/(pv-ov);return qv[0]=2*rv,qv[4]=0,qv[8]=0,qv[12]=-((lv+kv)*rv),qv[1]=0,qv[5]=2*sv,qv[9]=0,qv[13]=-((mv+nv)*sv),qv[2]=0,qv[6]=0,qv[10]=-2*tv,qv[14]=-((pv+ov)*tv),qv[3]=0,qv[7]=0,qv[11]=0,qv[15]=1,this}equals(uv){const vv=this.elements,wv=uv.elements;for(let xv=0;xv<16;xv++)if(vv[xv]!==wv[xv])return!1;return!0}fromArray(yv,zv=0){for(let Av=0;Av<16;Av++)this.elements[Av]=yv[Av+zv];return this}toArray(Bv=[],Cv=0){const Dv=this.elements;return Bv[Cv]=Dv[0],Bv[Cv+1]=Dv[1],Bv[Cv+2]=Dv[2],Bv[Cv+3]=Dv[3],Bv[Cv+4]=Dv[4],Bv[Cv+5]=Dv[5],Bv[Cv+6]=Dv[6],Bv[Cv+7]=Dv[7],Bv[Cv+8]=Dv[8],Bv[Cv+9]=Dv[9],Bv[Cv+10]=Dv[10],Bv[Cv+11]=Dv[11],Bv[Cv+12]=Dv[12],Bv[Cv+13]=Dv[13],Bv[Cv+14]=Dv[14],Bv[Cv+15]=Dv[15],Bv}}Hq.prototype.isMatrix4=!0;const Ev=new nk(),Fv=new Hq(),Gv=new nk(0,0,0),Hv=new nk(1,1,1),Iv=new nk(),Jv=new nk(),Kv=new nk(),Lv=new Hq(),Mv=new Ih();class Nv{constructor(Ov=0,Pv=0,Qv=0,Rv=Nv.DefaultOrder){this._x=Ov,this._y=Pv,this._z=Qv,this._order=Rv}get x(){return this._x}set x(Sv){this._x=Sv,this._onChangeCallback()}get y(){return this._y}set y(Tv){this._y=Tv,this._onChangeCallback()}get z(){return this._z}set z(Uv){this._z=Uv,this._onChangeCallback()}get order(){return this._order}set order(Vv){this._order=Vv,this._onChangeCallback()}set(Wv,Xv,Yv,Zv=this._order){return this._x=Wv,this._y=Xv,this._z=Yv,this._order=Zv,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy($v){return this._x=$v._x,this._y=$v._y,this._z=$v._z,this._order=$v._order,this._onChangeCallback(),this}setFromRotationMatrix(_v,aw=this._order,bw=!0){const cw=_v.elements,dw=cw[0],ew=cw[4],fw=cw[8],gw=cw[1],hw=cw[5],iw=cw[9],jw=cw[2],kw=cw[6],lw=cw[10];switch(aw){case"XYZ":this._y=Math.asin(W(fw,-1,1)),.9999999>Math.abs(fw)?(this._x=Math.atan2(-iw,lw),this._z=Math.atan2(-ew,dw)):(this._x=Math.atan2(kw,hw),this._z=0);break;case"YXZ":this._x=Math.asin(-W(iw,-1,1)),.9999999>Math.abs(iw)?(this._y=Math.atan2(fw,lw),this._z=Math.atan2(gw,hw)):(this._y=Math.atan2(-jw,dw),this._z=0);break;case"ZXY":this._x=Math.asin(W(kw,-1,1)),.9999999>Math.abs(kw)?(this._y=Math.atan2(-jw,lw),this._z=Math.atan2(-ew,hw)):(this._y=0,this._z=Math.atan2(gw,dw));break;case"ZYX":this._y=Math.asin(-W(jw,-1,1)),.9999999>Math.abs(jw)?(this._x=Math.atan2(kw,lw),this._z=Math.atan2(gw,dw)):(this._x=0,this._z=Math.atan2(-ew,hw));break;case"YZX":this._z=Math.asin(W(gw,-1,1)),.9999999>Math.abs(gw)?(this._x=Math.atan2(-iw,hw),this._y=Math.atan2(-jw,dw)):(this._x=0,this._y=Math.atan2(fw,lw));break;case"XZY":this._z=Math.asin(-W(ew,-1,1)),.9999999>Math.abs(ew)?(this._x=Math.atan2(kw,hw),this._y=Math.atan2(fw,dw)):(this._x=Math.atan2(-iw,lw),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+aw)}return this._order=aw,!0===bw&&this._onChangeCallback(),this}setFromQuaternion(mw,nw,ow){return Lv.makeRotationFromQuaternion(mw),this.setFromRotationMatrix(Lv,nw,ow)}setFromVector3(pw,qw=this._order){return this.set(pw.x,pw.y,pw.z,qw)}reorder(rw){return Mv.setFromEuler(this),this.setFromQuaternion(Mv,rw)}equals(sw){return sw._x===this._x&&sw._y===this._y&&sw._z===this._z&&sw._order===this._order}fromArray(tw){return this._x=tw[0],this._y=tw[1],this._z=tw[2],void 0!==tw[3]&&(this._order=tw[3]),this._onChangeCallback(),this}toArray(uw=[],vw=0){return uw[vw]=this._x,uw[vw+1]=this._y,uw[vw+2]=this._z,uw[vw+3]=this._order,uw}toVector3(ww){return ww?ww.set(this._x,this._y,this._z):new nk(this._x,this._y,this._z)}_onChange(xw){return this._onChangeCallback=xw,this}_onChangeCallback(){}}Nv.prototype.isEuler=!0,Nv.DefaultOrder="XYZ",Nv.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class yw{constructor(){this.mask=1}set(zw){this.mask=(1<<zw|0)>>>0}enable(Aw){this.mask|=1<<Aw|0}enableAll(){this.mask=-1}toggle(Bw){this.mask^=1<<Bw|0}disable(Cw){this.mask&=~(1<<Cw|0)}disableAll(){this.mask=0}test(Dw){return(this.mask&Dw.mask)!=0}isEnabled(Ew){return(this.mask&(1<<Ew|0))!=0}}let Fw=0;const Gw=new nk(),Hw=new Ih(),Iw=new Hq(),Jw=new nk(),Kw=new nk(),Lw=new nk(),Mw=new Ih(),Nw=new nk(1,0,0),Ow=new nk(0,1,0),Pw=new nk(0,0,1),Qw={type:"added"},Rw={type:"removed"};class Sw extends y{constructor(){super(),Object.defineProperty(this,"id",{value:Fw++}),this.uuid=V(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Sw.DefaultUp.clone();const Tw=new nk(),Uw=new Nv(),Vw=new Ih(),Ww=new nk(1,1,1);Uw._onChange(function(){Vw.setFromEuler(Uw,!1)}),Vw._onChange(function(){Uw.setFromQuaternion(Vw,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:Tw},rotation:{configurable:!0,enumerable:!0,value:Uw},quaternion:{configurable:!0,enumerable:!0,value:Vw},scale:{configurable:!0,enumerable:!0,value:Ww},modelViewMatrix:{value:new Hq()},normalMatrix:{value:new sb()}}),this.matrix=new Hq(),this.matrixWorld=new Hq(),this.matrixAutoUpdate=Sw.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new yw(),this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(Xw){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(Xw),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(Yw){return this.quaternion.premultiply(Yw),this}setRotationFromAxisAngle(Zw,$w){this.quaternion.setFromAxisAngle(Zw,$w)}setRotationFromEuler(_w){this.quaternion.setFromEuler(_w,!0)}setRotationFromMatrix(ax){this.quaternion.setFromRotationMatrix(ax)}setRotationFromQuaternion(bx){this.quaternion.copy(bx)}rotateOnAxis(cx,dx){return Hw.setFromAxisAngle(cx,dx),this.quaternion.multiply(Hw),this}rotateOnWorldAxis(ex,fx){return Hw.setFromAxisAngle(ex,fx),this.quaternion.premultiply(Hw),this}rotateX(gx){return this.rotateOnAxis(Nw,gx)}rotateY(hx){return this.rotateOnAxis(Ow,hx)}rotateZ(ix){return this.rotateOnAxis(Pw,ix)}translateOnAxis(jx,kx){return Gw.copy(jx).applyQuaternion(this.quaternion),this.position.add(Gw.multiplyScalar(kx)),this}translateX(lx){return this.translateOnAxis(Nw,lx)}translateY(mx){return this.translateOnAxis(Ow,mx)}translateZ(nx){return this.translateOnAxis(Pw,nx)}localToWorld(ox){return ox.applyMatrix4(this.matrixWorld)}worldToLocal(px){return px.applyMatrix4(Iw.copy(this.matrixWorld).invert())}lookAt(qx,rx,sx){qx.isVector3?Jw.copy(qx):Jw.set(qx,rx,sx);const tx=this.parent;this.updateWorldMatrix(!0,!1),Kw.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Iw.lookAt(Kw,Jw,this.up):Iw.lookAt(Jw,Kw,this.up),this.quaternion.setFromRotationMatrix(Iw),tx&&(Iw.extractRotation(tx.matrixWorld),Hw.setFromRotationMatrix(Iw),this.quaternion.premultiply(Hw.invert()))}add(ux){if(arguments.length>1){for(let vx=0;vx<arguments.length;vx++)this.add(arguments[vx]);return this}return ux===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",ux),this):(ux&&ux.isObject3D?(null!==ux.parent&&ux.parent.remove(ux),ux.parent=this,this.children.push(ux),ux.dispatchEvent(Qw)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",ux),this)}remove(wx){if(arguments.length>1){for(let xx=0;xx<arguments.length;xx++)this.remove(arguments[xx]);return this}const yx=this.children.indexOf(wx);return -1!==yx&&(wx.parent=null,this.children.splice(yx,1),wx.dispatchEvent(Rw)),this}removeFromParent(){const zx=this.parent;return null!==zx&&zx.remove(this),this}clear(){for(let Ax=0;Ax<this.children.length;Ax++){const Bx=this.children[Ax];Bx.parent=null,Bx.dispatchEvent(Rw)}return this.children.length=0,this}attach(Cx){return this.updateWorldMatrix(!0,!1),Iw.copy(this.matrixWorld).invert(),null!==Cx.parent&&(Cx.parent.updateWorldMatrix(!0,!1),Iw.multiply(Cx.parent.matrixWorld)),Cx.applyMatrix4(Iw),this.add(Cx),Cx.updateWorldMatrix(!1,!0),this}getObjectById(Dx){return this.getObjectByProperty("id",Dx)}getObjectByName(Ex){return this.getObjectByProperty("name",Ex)}getObjectByProperty(Fx,Gx){if(this[Fx]===Gx)return this;for(let Hx=0,Ix=this.children.length;Hx<Ix;Hx++){const Jx=this.children[Hx],Kx=Jx.getObjectByProperty(Fx,Gx);if(void 0!==Kx)return Kx}}getWorldPosition(Lx){return this.updateWorldMatrix(!0,!1),Lx.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(Mx){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Kw,Mx,Lw),Mx}getWorldScale(Nx){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Kw,Mw,Nx),Nx}getWorldDirection(Ox){this.updateWorldMatrix(!0,!1);const Px=this.matrixWorld.elements;return Ox.set(Px[8],Px[9],Px[10]).normalize()}raycast(){}traverse(Qx){Qx(this);const Rx=this.children;for(let Sx=0,Tx=Rx.length;Sx<Tx;Sx++)Rx[Sx].traverse(Qx)}traverseVisible(Ux){if(!1===this.visible)return;Ux(this);const Vx=this.children;for(let Wx=0,Xx=Vx.length;Wx<Xx;Wx++)Vx[Wx].traverseVisible(Ux)}traverseAncestors(Yx){const Zx=this.parent;null!==Zx&&(Yx(Zx),Zx.traverseAncestors(Yx))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld($x){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||$x)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,$x=!0);const _x=this.children;for(let ay=0,by=_x.length;ay<by;ay++)_x[ay].updateMatrixWorld($x)}updateWorldMatrix(cy,dy){const ey=this.parent;if(!0===cy&&null!==ey&&ey.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===dy){const fy=this.children;for(let gy=0,hy=fy.length;gy<hy;gy++)fy[gy].updateWorldMatrix(!1,!0)}}toJSON(iy){const jy=void 0===iy||"string"==typeof iy,ky={};jy&&(iy={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},ky.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const ly={};function my(a,b){return void 0===a[b.uuid]&&(a[b.uuid]=b.toJSON(iy)),b.uuid}if(ly.uuid=this.uuid,ly.type=this.type,""!==this.name&&(ly.name=this.name),!0===this.castShadow&&(ly.castShadow=!0),!0===this.receiveShadow&&(ly.receiveShadow=!0),!1===this.visible&&(ly.visible=!1),!1===this.frustumCulled&&(ly.frustumCulled=!1),0!==this.renderOrder&&(ly.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(ly.userData=this.userData),ly.layers=this.layers.mask,ly.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(ly.matrixAutoUpdate=!1),this.isInstancedMesh&&(ly.type="InstancedMesh",ly.count=this.count,ly.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(ly.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?ly.background=this.background.toJSON():this.background.isTexture&&(ly.background=this.background.toJSON(iy).uuid)),this.environment&&this.environment.isTexture&&(ly.environment=this.environment.toJSON(iy).uuid);else if(this.isMesh||this.isLine||this.isPoints){ly.geometry=my(iy.geometries,this.geometry);const ny=this.geometry.parameters;if(void 0!==ny&& void 0!==ny.shapes){const oy=ny.shapes;if(Array.isArray(oy))for(let py=0,qy=oy.length;py<qy;py++){const ry=oy[py];my(iy.shapes,ry)}else my(iy.shapes,oy)}}if(this.isSkinnedMesh&&(ly.bindMode=this.bindMode,ly.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(my(iy.skeletons,this.skeleton),ly.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const sy=[];for(let ty=0,uy=this.material.length;ty<uy;ty++)sy.push(my(iy.materials,this.material[ty]));ly.material=sy}else ly.material=my(iy.materials,this.material);if(this.children.length>0){ly.children=[];for(let vy=0;vy<this.children.length;vy++)ly.children.push(this.children[vy].toJSON(iy).object)}if(this.animations.length>0){ly.animations=[];for(let wy=0;wy<this.animations.length;wy++){const xy=this.animations[wy];ly.animations.push(my(iy.animations,xy))}}if(jy){const yy=Fy(iy.geometries),zy=Fy(iy.materials),Ay=Fy(iy.textures),By=Fy(iy.images),Cy=Fy(iy.shapes),Dy=Fy(iy.skeletons),Ey=Fy(iy.animations);yy.length>0&&(ky.geometries=yy),zy.length>0&&(ky.materials=zy),Ay.length>0&&(ky.textures=Ay),By.length>0&&(ky.images=By),Cy.length>0&&(ky.shapes=Cy),Dy.length>0&&(ky.skeletons=Dy),Ey.length>0&&(ky.animations=Ey)}return ky.object=ly,ky;function Fy(a){const b=[];for(const c in a){const d=a[c];delete d.metadata,b.push(d)}return b}}clone(Gy){return new this.constructor().copy(this,Gy)}copy(Hy,Iy=!0){if(this.name=Hy.name,this.up.copy(Hy.up),this.position.copy(Hy.position),this.rotation.order=Hy.rotation.order,this.quaternion.copy(Hy.quaternion),this.scale.copy(Hy.scale),this.matrix.copy(Hy.matrix),this.matrixWorld.copy(Hy.matrixWorld),this.matrixAutoUpdate=Hy.matrixAutoUpdate,this.matrixWorldNeedsUpdate=Hy.matrixWorldNeedsUpdate,this.layers.mask=Hy.layers.mask,this.visible=Hy.visible,this.castShadow=Hy.castShadow,this.receiveShadow=Hy.receiveShadow,this.frustumCulled=Hy.frustumCulled,this.renderOrder=Hy.renderOrder,this.userData=JSON.parse(JSON.stringify(Hy.userData)),!0===Iy)for(let Jy=0;Jy<Hy.children.length;Jy++){const Ky=Hy.children[Jy];this.add(Ky.clone())}return this}}Sw.DefaultUp=new nk(0,1,0),Sw.DefaultMatrixAutoUpdate=!0,Sw.prototype.isObject3D=!0;const Ly=new nk(),My=new nk(),Ny=new nk(),Oy=new nk(),Py=new nk(),Qy=new nk(),Ry=new nk(),Sy=new nk(),Ty=new nk(),Uy=new nk();class Vy{constructor(Wy=new nk(),Xy=new nk(),Yy=new nk()){this.a=Wy,this.b=Xy,this.c=Yy}static getNormal(Zy,$y,_y,az){az.subVectors(_y,$y),Ly.subVectors(Zy,$y),az.cross(Ly);const bz=az.lengthSq();return bz>0?az.multiplyScalar(1/Math.sqrt(bz)):az.set(0,0,0)}static getBarycoord(cz,dz,ez,fz,gz){Ly.subVectors(fz,dz),My.subVectors(ez,dz),Ny.subVectors(cz,dz);const hz=Ly.dot(Ly),iz=Ly.dot(My),jz=Ly.dot(Ny),kz=My.dot(My),lz=My.dot(Ny),mz=hz*kz-iz*iz;if(0===mz)return gz.set(-2,-1,-1);const nz=1/mz,oz=(kz*jz-iz*lz)*nz,pz=(hz*lz-iz*jz)*nz;return gz.set(1-oz-pz,pz,oz)}static containsPoint(qz,rz,sz,tz){return this.getBarycoord(qz,rz,sz,tz,Oy),Oy.x>=0&&Oy.y>=0&&Oy.x+Oy.y<=1}static getUV(uz,vz,wz,xz,yz,zz,Az,Bz){return this.getBarycoord(uz,vz,wz,xz,Oy),Bz.set(0,0),Bz.addScaledVector(yz,Oy.x),Bz.addScaledVector(zz,Oy.y),Bz.addScaledVector(Az,Oy.z),Bz}static isFrontFacing(Cz,Dz,Ez,Fz){return Ly.subVectors(Ez,Dz),My.subVectors(Cz,Dz),0>Ly.cross(My).dot(Fz)}set(Gz,Hz,Iz){return this.a.copy(Gz),this.b.copy(Hz),this.c.copy(Iz),this}setFromPointsAndIndices(Jz,Kz,Lz,Mz){return this.a.copy(Jz[Kz]),this.b.copy(Jz[Lz]),this.c.copy(Jz[Mz]),this}setFromAttributeAndIndices(Nz,Oz,Pz,Qz){return this.a.fromBufferAttribute(Nz,Oz),this.b.fromBufferAttribute(Nz,Pz),this.c.fromBufferAttribute(Nz,Qz),this}clone(){return new this.constructor().copy(this)}copy(Rz){return this.a.copy(Rz.a),this.b.copy(Rz.b),this.c.copy(Rz.c),this}getArea(){return Ly.subVectors(this.c,this.b),My.subVectors(this.a,this.b),.5*Ly.cross(My).length()}getMidpoint(Sz){return Sz.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(Tz){return Vy.getNormal(this.a,this.b,this.c,Tz)}getPlane(Uz){return Uz.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(Vz,Wz){return Vy.getBarycoord(Vz,this.a,this.b,this.c,Wz)}getUV(Xz,Yz,Zz,$z,_z){return Vy.getUV(Xz,this.a,this.b,this.c,Yz,Zz,$z,_z)}containsPoint(aA){return Vy.containsPoint(aA,this.a,this.b,this.c)}isFrontFacing(bA){return Vy.isFrontFacing(this.a,this.b,this.c,bA)}intersectsBox(cA){return cA.intersectsTriangle(this)}closestPointToPoint(dA,eA){const fA=this.a,gA=this.b,hA=this.c;let iA,jA;Py.subVectors(gA,fA),Qy.subVectors(hA,fA),Sy.subVectors(dA,fA);const kA=Py.dot(Sy),lA=Qy.dot(Sy);if(kA<=0&&lA<=0)return eA.copy(fA);Ty.subVectors(dA,gA);const mA=Py.dot(Ty),nA=Qy.dot(Ty);if(mA>=0&&nA<=mA)return eA.copy(gA);const oA=kA*nA-mA*lA;if(oA<=0&&kA>=0&&mA<=0)return iA=kA/(kA-mA),eA.copy(fA).addScaledVector(Py,iA);Uy.subVectors(dA,hA);const pA=Py.dot(Uy),qA=Qy.dot(Uy);if(qA>=0&&pA<=qA)return eA.copy(hA);const rA=pA*lA-kA*qA;if(rA<=0&&lA>=0&&qA<=0)return jA=lA/(lA-qA),eA.copy(fA).addScaledVector(Qy,jA);const sA=mA*qA-pA*nA;if(sA<=0&&nA-mA>=0&&pA-qA>=0)return Ry.subVectors(hA,gA),jA=(nA-mA)/(nA-mA+(pA-qA)),eA.copy(gA).addScaledVector(Ry,jA);const tA=1/(sA+rA+oA);return iA=rA*tA,jA=oA*tA,eA.copy(fA).addScaledVector(Py,iA).addScaledVector(Qy,jA)}equals(uA){return uA.a.equals(this.a)&&uA.b.equals(this.b)&&uA.c.equals(this.c)}}let vA=0;class wA extends y{constructor(){super(),Object.defineProperty(this,"id",{value:vA++}),this.uuid=V(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=f,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(xA){this._alphaTest>0!=xA>0&&this.version++,this._alphaTest=xA}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(yA){if(void 0!==yA)for(const zA in yA){const AA=yA[zA];if(void 0===AA){console.warn("THREE.Material: '"+zA+"' parameter is undefined.");continue}if("shading"===zA){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===AA;continue}const BA=this[zA];if(void 0===BA){console.warn("THREE."+this.type+": '"+zA+"' is not a property of this material.");continue}BA&&BA.isColor?BA.set(AA):BA&&BA.isVector3&&AA&&AA.isVector3?BA.copy(AA):this[zA]=AA}}toJSON(CA){const DA=void 0===CA||"string"==typeof CA;DA&&(CA={textures:{},images:{}});const EA={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function FA(a){const b=[];for(const c in a){const d=a[c];delete d.metadata,b.push(d)}return b}if(EA.uuid=this.uuid,EA.type=this.type,""!==this.name&&(EA.name=this.name),this.color&&this.color.isColor&&(EA.color=this.color.getHex()),void 0!==this.roughness&&(EA.roughness=this.roughness),void 0!==this.metalness&&(EA.metalness=this.metalness),void 0!==this.sheen&&(EA.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(EA.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(EA.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(EA.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(EA.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(EA.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(EA.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(EA.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(EA.shininess=this.shininess),void 0!==this.clearcoat&&(EA.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(EA.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(EA.clearcoatMap=this.clearcoatMap.toJSON(CA).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(EA.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(CA).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(EA.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(CA).uuid,EA.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(EA.map=this.map.toJSON(CA).uuid),this.matcap&&this.matcap.isTexture&&(EA.matcap=this.matcap.toJSON(CA).uuid),this.alphaMap&&this.alphaMap.isTexture&&(EA.alphaMap=this.alphaMap.toJSON(CA).uuid),this.lightMap&&this.lightMap.isTexture&&(EA.lightMap=this.lightMap.toJSON(CA).uuid,EA.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(EA.aoMap=this.aoMap.toJSON(CA).uuid,EA.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(EA.bumpMap=this.bumpMap.toJSON(CA).uuid,EA.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(EA.normalMap=this.normalMap.toJSON(CA).uuid,EA.normalMapType=this.normalMapType,EA.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(EA.displacementMap=this.displacementMap.toJSON(CA).uuid,EA.displacementScale=this.displacementScale,EA.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(EA.roughnessMap=this.roughnessMap.toJSON(CA).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(EA.metalnessMap=this.metalnessMap.toJSON(CA).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(EA.emissiveMap=this.emissiveMap.toJSON(CA).uuid),this.specularMap&&this.specularMap.isTexture&&(EA.specularMap=this.specularMap.toJSON(CA).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(EA.specularIntensityMap=this.specularIntensityMap.toJSON(CA).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(EA.specularColorMap=this.specularColorMap.toJSON(CA).uuid),this.envMap&&this.envMap.isTexture&&(EA.envMap=this.envMap.toJSON(CA).uuid,void 0!==this.combine&&(EA.combine=this.combine)),void 0!==this.envMapIntensity&&(EA.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(EA.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(EA.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(EA.gradientMap=this.gradientMap.toJSON(CA).uuid),void 0!==this.transmission&&(EA.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(EA.transmissionMap=this.transmissionMap.toJSON(CA).uuid),void 0!==this.thickness&&(EA.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(EA.thicknessMap=this.thicknessMap.toJSON(CA).uuid),void 0!==this.attenuationDistance&&(EA.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(EA.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(EA.size=this.size),null!==this.shadowSide&&(EA.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(EA.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(EA.blending=this.blending),this.side!==f&&(EA.side=this.side),this.vertexColors&&(EA.vertexColors=!0),this.opacity<1&&(EA.opacity=this.opacity),!0===this.transparent&&(EA.transparent=this.transparent),EA.depthFunc=this.depthFunc,EA.depthTest=this.depthTest,EA.depthWrite=this.depthWrite,EA.colorWrite=this.colorWrite,EA.stencilWrite=this.stencilWrite,EA.stencilWriteMask=this.stencilWriteMask,EA.stencilFunc=this.stencilFunc,EA.stencilRef=this.stencilRef,EA.stencilFuncMask=this.stencilFuncMask,EA.stencilFail=this.stencilFail,EA.stencilZFail=this.stencilZFail,EA.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(EA.rotation=this.rotation),!0===this.polygonOffset&&(EA.polygonOffset=!0),0!==this.polygonOffsetFactor&&(EA.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(EA.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(EA.linewidth=this.linewidth),void 0!==this.dashSize&&(EA.dashSize=this.dashSize),void 0!==this.gapSize&&(EA.gapSize=this.gapSize),void 0!==this.scale&&(EA.scale=this.scale),!0===this.dithering&&(EA.dithering=!0),this.alphaTest>0&&(EA.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(EA.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(EA.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(EA.wireframe=this.wireframe),this.wireframeLinewidth>1&&(EA.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(EA.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(EA.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(EA.flatShading=this.flatShading),!1===this.visible&&(EA.visible=!1),!1===this.toneMapped&&(EA.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(EA.userData=this.userData),DA){const GA=FA(CA.textures),HA=FA(CA.images);GA.length>0&&(EA.textures=GA),HA.length>0&&(EA.images=HA)}return EA}clone(){return new this.constructor().copy(this)}copy(IA){this.name=IA.name,this.fog=IA.fog,this.blending=IA.blending,this.side=IA.side,this.vertexColors=IA.vertexColors,this.opacity=IA.opacity,this.transparent=IA.transparent,this.blendSrc=IA.blendSrc,this.blendDst=IA.blendDst,this.blendEquation=IA.blendEquation,this.blendSrcAlpha=IA.blendSrcAlpha,this.blendDstAlpha=IA.blendDstAlpha,this.blendEquationAlpha=IA.blendEquationAlpha,this.depthFunc=IA.depthFunc,this.depthTest=IA.depthTest,this.depthWrite=IA.depthWrite,this.stencilWriteMask=IA.stencilWriteMask,this.stencilFunc=IA.stencilFunc,this.stencilRef=IA.stencilRef,this.stencilFuncMask=IA.stencilFuncMask,this.stencilFail=IA.stencilFail,this.stencilZFail=IA.stencilZFail,this.stencilZPass=IA.stencilZPass,this.stencilWrite=IA.stencilWrite;const JA=IA.clippingPlanes;let KA=null;if(null!==JA){const LA=JA.length;KA=new Array(LA);for(let MA=0;MA!==LA;++MA)KA[MA]=JA[MA].clone()}return this.clippingPlanes=KA,this.clipIntersection=IA.clipIntersection,this.clipShadows=IA.clipShadows,this.shadowSide=IA.shadowSide,this.colorWrite=IA.colorWrite,this.precision=IA.precision,this.polygonOffset=IA.polygonOffset,this.polygonOffsetFactor=IA.polygonOffsetFactor,this.polygonOffsetUnits=IA.polygonOffsetUnits,this.dithering=IA.dithering,this.alphaTest=IA.alphaTest,this.alphaToCoverage=IA.alphaToCoverage,this.premultipliedAlpha=IA.premultipliedAlpha,this.visible=IA.visible,this.toneMapped=IA.toneMapped,this.userData=JSON.parse(JSON.stringify(IA.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(NA){!0===NA&&this.version++}}wA.prototype.isMaterial=!0;class OA extends wA{constructor(PA){super(),this.type="MeshBasicMaterial",this.color=new Dd(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(PA)}copy(QA){return super.copy(QA),this.color.copy(QA.color),this.map=QA.map,this.lightMap=QA.lightMap,this.lightMapIntensity=QA.lightMapIntensity,this.aoMap=QA.aoMap,this.aoMapIntensity=QA.aoMapIntensity,this.specularMap=QA.specularMap,this.alphaMap=QA.alphaMap,this.envMap=QA.envMap,this.combine=QA.combine,this.reflectivity=QA.reflectivity,this.refractionRatio=QA.refractionRatio,this.wireframe=QA.wireframe,this.wireframeLinewidth=QA.wireframeLinewidth,this.wireframeLinecap=QA.wireframeLinecap,this.wireframeLinejoin=QA.wireframeLinejoin,this}}OA.prototype.isMeshBasicMaterial=!0;const RA=new nk(),SA=new ba();class TA{constructor(UA,VA,WA){if(Array.isArray(UA))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=UA,this.itemSize=VA,this.count=void 0!==UA?UA.length/VA:0,this.normalized=!0===WA,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(XA){!0===XA&&this.version++}setUsage(YA){return this.usage=YA,this}copy(ZA){return this.name=ZA.name,this.array=new ZA.array.constructor(ZA.array),this.itemSize=ZA.itemSize,this.count=ZA.count,this.normalized=ZA.normalized,this.usage=ZA.usage,this}copyAt($A,_A,aB){$A*=this.itemSize,aB*=_A.itemSize;for(let bB=0,cB=this.itemSize;bB<cB;bB++)this.array[$A+bB]=_A.array[aB+bB];return this}copyArray(dB){return this.array.set(dB),this}copyColorsArray(eB){const fB=this.array;let gB=0;for(let hB=0,iB=eB.length;hB<iB;hB++){let jB=eB[hB];void 0===jB&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",hB),jB=new Dd()),fB[gB++]=jB.r,fB[gB++]=jB.g,fB[gB++]=jB.b}return this}copyVector2sArray(kB){const lB=this.array;let mB=0;for(let nB=0,oB=kB.length;nB<oB;nB++){let pB=kB[nB];void 0===pB&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",nB),pB=new ba()),lB[mB++]=pB.x,lB[mB++]=pB.y}return this}copyVector3sArray(qB){const rB=this.array;let sB=0;for(let tB=0,uB=qB.length;tB<uB;tB++){let vB=qB[tB];void 0===vB&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",tB),vB=new nk()),rB[sB++]=vB.x,rB[sB++]=vB.y,rB[sB++]=vB.z}return this}copyVector4sArray(wB){const xB=this.array;let yB=0;for(let zB=0,AB=wB.length;zB<AB;zB++){let BB=wB[zB];void 0===BB&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",zB),BB=new Af()),xB[yB++]=BB.x,xB[yB++]=BB.y,xB[yB++]=BB.z,xB[yB++]=BB.w}return this}applyMatrix3(CB){if(2===this.itemSize)for(let DB=0,EB=this.count;DB<EB;DB++)SA.fromBufferAttribute(this,DB),SA.applyMatrix3(CB),this.setXY(DB,SA.x,SA.y);else if(3===this.itemSize)for(let FB=0,GB=this.count;FB<GB;FB++)RA.fromBufferAttribute(this,FB),RA.applyMatrix3(CB),this.setXYZ(FB,RA.x,RA.y,RA.z);return this}applyMatrix4(HB){for(let IB=0,JB=this.count;IB<JB;IB++)RA.x=this.getX(IB),RA.y=this.getY(IB),RA.z=this.getZ(IB),RA.applyMatrix4(HB),this.setXYZ(IB,RA.x,RA.y,RA.z);return this}applyNormalMatrix(KB){for(let LB=0,MB=this.count;LB<MB;LB++)RA.x=this.getX(LB),RA.y=this.getY(LB),RA.z=this.getZ(LB),RA.applyNormalMatrix(KB),this.setXYZ(LB,RA.x,RA.y,RA.z);return this}transformDirection(NB){for(let OB=0,PB=this.count;OB<PB;OB++)RA.x=this.getX(OB),RA.y=this.getY(OB),RA.z=this.getZ(OB),RA.transformDirection(NB),this.setXYZ(OB,RA.x,RA.y,RA.z);return this}set(QB,RB=0){return this.array.set(QB,RB),this}getX(SB){return this.array[SB*this.itemSize]}setX(TB,UB){return this.array[TB*this.itemSize]=UB,this}getY(VB){return this.array[VB*this.itemSize+1]}setY(WB,XB){return this.array[WB*this.itemSize+1]=XB,this}getZ(YB){return this.array[YB*this.itemSize+2]}setZ(ZB,$B){return this.array[ZB*this.itemSize+2]=$B,this}getW(_B){return this.array[_B*this.itemSize+3]}setW(aC,bC){return this.array[aC*this.itemSize+3]=bC,this}setXY(cC,dC,eC){return cC*=this.itemSize,this.array[cC+0]=dC,this.array[cC+1]=eC,this}setXYZ(fC,gC,hC,iC){return fC*=this.itemSize,this.array[fC+0]=gC,this.array[fC+1]=hC,this.array[fC+2]=iC,this}setXYZW(jC,kC,lC,mC,nC){return jC*=this.itemSize,this.array[jC+0]=kC,this.array[jC+1]=lC,this.array[jC+2]=mC,this.array[jC+3]=nC,this}onUpload(oC){return this.onUploadCallback=oC,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const pC={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(pC.name=this.name),35044!==this.usage&&(pC.usage=this.usage),(0!==this.updateRange.offset|| -1!==this.updateRange.count)&&(pC.updateRange=this.updateRange),pC}}TA.prototype.isBufferAttribute=!0;class qC extends TA{constructor(rC,sC,tC){super(new Uint16Array(rC),sC,tC)}}class uC extends TA{constructor(vC,wC,xC){super(new Uint32Array(vC),wC,xC)}}(class extends TA{constructor(yC,zC,AC){super(new Uint16Array(yC),zC,AC)}}).prototype.isFloat16BufferAttribute=!0;class BC extends TA{constructor(CC,DC,EC){super(new Float32Array(CC),DC,EC)}}let FC=0;const GC=new Hq(),HC=new Sw(),IC=new nk(),JC=new Tm(),KC=new Tm(),LC=new nk();class MC extends y{constructor(){super(),Object.defineProperty(this,"id",{value:FC++}),this.uuid=V(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(NC){return Array.isArray(NC)?this.index=new(vd(NC)?uC:qC)(NC,1):this.index=NC,this}getAttribute(OC){return this.attributes[OC]}setAttribute(PC,QC){return this.attributes[PC]=QC,this}deleteAttribute(RC){return delete this.attributes[RC],this}hasAttribute(SC){return void 0!==this.attributes[SC]}addGroup(TC,UC,VC=0){this.groups.push({start:TC,count:UC,materialIndex:VC})}clearGroups(){this.groups=[]}setDrawRange(WC,XC){this.drawRange.start=WC,this.drawRange.count=XC}applyMatrix4(YC){const ZC=this.attributes.position;void 0!==ZC&&(ZC.applyMatrix4(YC),ZC.needsUpdate=!0);const $C=this.attributes.normal;if(void 0!==$C){const _C=new sb().getNormalMatrix(YC);$C.applyNormalMatrix(_C),$C.needsUpdate=!0}const aD=this.attributes.tangent;return void 0!==aD&&(aD.transformDirection(YC),aD.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(bD){return GC.makeRotationFromQuaternion(bD),this.applyMatrix4(GC),this}rotateX(cD){return GC.makeRotationX(cD),this.applyMatrix4(GC),this}rotateY(dD){return GC.makeRotationY(dD),this.applyMatrix4(GC),this}rotateZ(eD){return GC.makeRotationZ(eD),this.applyMatrix4(GC),this}translate(fD,gD,hD){return GC.makeTranslation(fD,gD,hD),this.applyMatrix4(GC),this}scale(iD,jD,kD){return GC.makeScale(iD,jD,kD),this.applyMatrix4(GC),this}lookAt(lD){return HC.lookAt(lD),HC.updateMatrix(),this.applyMatrix4(HC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(IC).negate(),this.translate(IC.x,IC.y,IC.z),this}setFromPoints(mD){const nD=[];for(let oD=0,pD=mD.length;oD<pD;oD++){const qD=mD[oD];nD.push(qD.x,qD.y,qD.z||0)}return this.setAttribute("position",new BC(nD,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Tm());const rD=this.attributes.position,sD=this.morphAttributes.position;if(rD&&rD.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".",this),this.boundingBox.set(new nk(-1/0,-1/0,-1/0),new nk(Infinity,Infinity,Infinity));return}if(void 0!==rD){if(this.boundingBox.setFromBufferAttribute(rD),sD)for(let tD=0,uD=sD.length;tD<uD;tD++){const vD=sD[tD];JC.setFromBufferAttribute(vD),this.morphTargetsRelative?(LC.addVectors(this.boundingBox.min,JC.min),this.boundingBox.expandByPoint(LC),LC.addVectors(this.boundingBox.max,JC.max),this.boundingBox.expandByPoint(LC)):(this.boundingBox.expandByPoint(JC.min),this.boundingBox.expandByPoint(JC.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error("THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.",this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Eo());const wD=this.attributes.position,xD=this.morphAttributes.position;if(wD&&wD.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".",this),this.boundingSphere.set(new nk(),1/0);return}if(wD){const yD=this.boundingSphere.center;if(JC.setFromBufferAttribute(wD),xD)for(let zD=0,AD=xD.length;zD<AD;zD++){const BD=xD[zD];KC.setFromBufferAttribute(BD),this.morphTargetsRelative?(LC.addVectors(JC.min,KC.min),JC.expandByPoint(LC),LC.addVectors(JC.max,KC.max),JC.expandByPoint(LC)):(JC.expandByPoint(KC.min),JC.expandByPoint(KC.max))}JC.getCenter(yD);let CD=0;for(let DD=0,ED=wD.count;DD<ED;DD++)LC.fromBufferAttribute(wD,DD),CD=Math.max(CD,yD.distanceToSquared(LC));if(xD)for(let FD=0,GD=xD.length;FD<GD;FD++){const HD=xD[FD],ID=this.morphTargetsRelative;for(let JD=0,KD=HD.count;JD<KD;JD++)LC.fromBufferAttribute(HD,JD),ID&&(IC.fromBufferAttribute(wD,JD),LC.add(IC)),CD=Math.max(CD,yD.distanceToSquared(LC))}this.boundingSphere.radius=Math.sqrt(CD),isNaN(this.boundingSphere.radius)&&console.error("THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.",this)}}computeTangents(){const LD=this.index,MD=this.attributes;if(null===LD|| void 0===MD.position|| void 0===MD.normal|| void 0===MD.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const ND=LD.array,OD=MD.position.array,PD=MD.normal.array,QD=MD.uv.array,RD=OD.length/3;void 0===MD.tangent&&this.setAttribute("tangent",new TA(new Float32Array(4*RD),4));const SD=MD.tangent.array,TD=[],UD=[];for(let VD=0;VD<RD;VD++)TD[VD]=new nk(),UD[VD]=new nk();const WD=new nk(),XD=new nk(),YD=new nk(),ZD=new ba(),$D=new ba(),_D=new ba(),aE=new nk(),bE=new nk();function cE(a,b,c){WD.fromArray(OD,3*a),XD.fromArray(OD,3*b),YD.fromArray(OD,3*c),ZD.fromArray(QD,2*a),$D.fromArray(QD,2*b),_D.fromArray(QD,2*c),XD.sub(WD),YD.sub(WD),$D.sub(ZD),_D.sub(ZD);const d=1/($D.x*_D.y-_D.x*$D.y);isFinite(d)&&(aE.copy(XD).multiplyScalar(_D.y).addScaledVector(YD,-$D.y).multiplyScalar(d),bE.copy(YD).multiplyScalar($D.x).addScaledVector(XD,-_D.x).multiplyScalar(d),TD[a].add(aE),TD[b].add(aE),TD[c].add(aE),UD[a].add(bE),UD[b].add(bE),UD[c].add(bE))}let dE=this.groups;0===dE.length&&(dE=[{start:0,count:ND.length}]);for(let eE=0,fE=dE.length;eE<fE;++eE){const gE=dE[eE],hE=gE.start,iE=gE.count;for(let jE=hE,kE=hE+iE;jE<kE;jE+=3)cE(ND[jE+0],ND[jE+1],ND[jE+2])}const lE=new nk(),mE=new nk(),nE=new nk(),oE=new nk();function pE(a){nE.fromArray(PD,3*a),oE.copy(nE);const b=TD[a];lE.copy(b),lE.sub(nE.multiplyScalar(nE.dot(b))).normalize(),mE.crossVectors(oE,b);const c=mE.dot(UD[a]);SD[4*a]=lE.x,SD[4*a+1]=lE.y,SD[4*a+2]=lE.z,SD[4*a+3]=c<0?-1:1}for(let qE=0,rE=dE.length;qE<rE;++qE){const sE=dE[qE],tE=sE.start,uE=sE.count;for(let vE=tE,wE=tE+uE;vE<wE;vE+=3)pE(ND[vE+0]),pE(ND[vE+1]),pE(ND[vE+2])}}computeVertexNormals(){const xE=this.index,yE=this.getAttribute("position");if(void 0!==yE){let zE=this.getAttribute("normal");if(void 0===zE)zE=new TA(new Float32Array(3*yE.count),3),this.setAttribute("normal",zE);else for(let AE=0,BE=zE.count;AE<BE;AE++)zE.setXYZ(AE,0,0,0);const CE=new nk(),DE=new nk(),EE=new nk(),FE=new nk(),GE=new nk(),HE=new nk(),IE=new nk(),JE=new nk();if(xE)for(let KE=0,LE=xE.count;KE<LE;KE+=3){const ME=xE.getX(KE+0),NE=xE.getX(KE+1),OE=xE.getX(KE+2);CE.fromBufferAttribute(yE,ME),DE.fromBufferAttribute(yE,NE),EE.fromBufferAttribute(yE,OE),IE.subVectors(EE,DE),JE.subVectors(CE,DE),IE.cross(JE),FE.fromBufferAttribute(zE,ME),GE.fromBufferAttribute(zE,NE),HE.fromBufferAttribute(zE,OE),FE.add(IE),GE.add(IE),HE.add(IE),zE.setXYZ(ME,FE.x,FE.y,FE.z),zE.setXYZ(NE,GE.x,GE.y,GE.z),zE.setXYZ(OE,HE.x,HE.y,HE.z)}else for(let PE=0,QE=yE.count;PE<QE;PE+=3)CE.fromBufferAttribute(yE,PE+0),DE.fromBufferAttribute(yE,PE+1),EE.fromBufferAttribute(yE,PE+2),IE.subVectors(EE,DE),JE.subVectors(CE,DE),IE.cross(JE),zE.setXYZ(PE+0,IE.x,IE.y,IE.z),zE.setXYZ(PE+1,IE.x,IE.y,IE.z),zE.setXYZ(PE+2,IE.x,IE.y,IE.z);this.normalizeNormals(),zE.needsUpdate=!0}}merge(RE,SE){if(!(RE&&RE.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",RE);return}void 0===SE&&(SE=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const TE=this.attributes;for(const UE in TE){if(void 0===RE.attributes[UE])continue;const VE=TE[UE],WE=VE.array,XE=RE.attributes[UE],YE=XE.array,ZE=XE.itemSize*SE,$E=Math.min(YE.length,WE.length-ZE);for(let _E=0,aF=ZE;_E<$E;_E++,aF++)WE[aF]=YE[_E]}return this}normalizeNormals(){const bF=this.attributes.normal;for(let cF=0,dF=bF.count;cF<dF;cF++)LC.fromBufferAttribute(bF,cF),LC.normalize(),bF.setXYZ(cF,LC.x,LC.y,LC.z)}toNonIndexed(){function eF(a,b){const c=a.array,d=a.itemSize,e=a.normalized,f=new c.constructor(b.length*d);let g=0,h=0;for(let i=0,j=b.length;i<j;i++){g=a.isInterleavedBufferAttribute?b[i]*a.data.stride+a.offset:b[i]*d;for(let k=0;k<d;k++)f[h++]=c[g++]}return new TA(f,d,e)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const fF=new MC(),gF=this.index.array,hF=this.attributes;for(const iF in hF){const jF=hF[iF],kF=eF(jF,gF);fF.setAttribute(iF,kF)}const lF=this.morphAttributes;for(const mF in lF){const nF=[],oF=lF[mF];for(let pF=0,qF=oF.length;pF<qF;pF++){const rF=oF[pF],sF=eF(rF,gF);nF.push(sF)}fF.morphAttributes[mF]=nF}fF.morphTargetsRelative=this.morphTargetsRelative;const tF=this.groups;for(let uF=0,vF=tF.length;uF<vF;uF++){const wF=tF[uF];fF.addGroup(wF.start,wF.count,wF.materialIndex)}return fF}toJSON(){const xF={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(xF.uuid=this.uuid,xF.type=this.type,""!==this.name&&(xF.name=this.name),Object.keys(this.userData).length>0&&(xF.userData=this.userData),void 0!==this.parameters){const yF=this.parameters;for(const zF in yF)void 0!==yF[zF]&&(xF[zF]=yF[zF]);return xF}xF.data={attributes:{}};const AF=this.index;null!==AF&&(xF.data.index={type:AF.array.constructor.name,array:Array.prototype.slice.call(AF.array)});const BF=this.attributes;for(const CF in BF){const DF=BF[CF];xF.data.attributes[CF]=DF.toJSON(xF.data)}const EF={};let FF=!1;for(const GF in this.morphAttributes){const HF=this.morphAttributes[GF],IF=[];for(let JF=0,KF=HF.length;JF<KF;JF++){const LF=HF[JF];IF.push(LF.toJSON(xF.data))}IF.length>0&&(EF[GF]=IF,FF=!0)}FF&&(xF.data.morphAttributes=EF,xF.data.morphTargetsRelative=this.morphTargetsRelative);const MF=this.groups;MF.length>0&&(xF.data.groups=JSON.parse(JSON.stringify(MF)));const NF=this.boundingSphere;return null!==NF&&(xF.data.boundingSphere={center:NF.center.toArray(),radius:NF.radius}),xF}clone(){return new this.constructor().copy(this)}copy(OF){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const PF={};this.name=OF.name;const QF=OF.index;null!==QF&&this.setIndex(QF.clone(PF));const RF=OF.attributes;for(const SF in RF){const TF=RF[SF];this.setAttribute(SF,TF.clone(PF))}const UF=OF.morphAttributes;for(const VF in UF){const WF=[],XF=UF[VF];for(let YF=0,ZF=XF.length;YF<ZF;YF++)WF.push(XF[YF].clone(PF));this.morphAttributes[VF]=WF}this.morphTargetsRelative=OF.morphTargetsRelative;const $F=OF.groups;for(let _F=0,aG=$F.length;_F<aG;_F++){const bG=$F[_F];this.addGroup(bG.start,bG.count,bG.materialIndex)}const cG=OF.boundingBox;null!==cG&&(this.boundingBox=cG.clone());const dG=OF.boundingSphere;return null!==dG&&(this.boundingSphere=dG.clone()),this.drawRange.start=OF.drawRange.start,this.drawRange.count=OF.drawRange.count,this.userData=OF.userData,void 0!==OF.parameters&&(this.parameters=Object.assign({},OF.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}MC.prototype.isBufferGeometry=!0;const eG=new Hq(),fG=new np(),gG=new Eo(),hG=new nk(),iG=new nk(),jG=new nk(),kG=new nk(),lG=new nk(),mG=new nk(),nG=new nk(),oG=new nk(),pG=new nk(),qG=new ba(),rG=new ba(),sG=new ba(),tG=new nk(),uG=new nk();class vG extends Sw{constructor(wG=new MC(),xG=new OA()){super(),this.type="Mesh",this.geometry=wG,this.material=xG,this.updateMorphTargets()}copy(yG){return super.copy(yG),void 0!==yG.morphTargetInfluences&&(this.morphTargetInfluences=yG.morphTargetInfluences.slice()),void 0!==yG.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},yG.morphTargetDictionary)),this.material=yG.material,this.geometry=yG.geometry,this}updateMorphTargets(){const zG=this.geometry;if(zG.isBufferGeometry){const AG=zG.morphAttributes,BG=Object.keys(AG);if(BG.length>0){const CG=AG[BG[0]];if(void 0!==CG){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let DG=0,EG=CG.length;DG<EG;DG++){const FG=CG[DG].name||String(DG);this.morphTargetInfluences.push(0),this.morphTargetDictionary[FG]=DG}}}}else{const GG=zG.morphTargets;void 0!==GG&&GG.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(HG,IG){const JG=this.geometry,KG=this.material,LG=this.matrixWorld;if(void 0===KG)return;if(null===JG.boundingSphere&&JG.computeBoundingSphere(),gG.copy(JG.boundingSphere),gG.applyMatrix4(LG),!1===HG.ray.intersectsSphere(gG))return;if(eG.copy(LG).invert(),fG.copy(HG.ray).applyMatrix4(eG),null!==JG.boundingBox&& !1===fG.intersectsBox(JG.boundingBox))return;let MG;if(JG.isBufferGeometry){const NG=JG.index,OG=JG.attributes.position,PG=JG.morphAttributes.position,QG=JG.morphTargetsRelative,RG=JG.attributes.uv,SG=JG.attributes.uv2,TG=JG.groups,UG=JG.drawRange;if(null!==NG)if(Array.isArray(KG))for(let VG=0,WG=TG.length;VG<WG;VG++){const XG=TG[VG],YG=KG[XG.materialIndex],ZG=Math.max(XG.start,UG.start),$G=Math.min(NG.count,Math.min(XG.start+XG.count,UG.start+UG.count));for(let _G=ZG,aH=$G;_G<aH;_G+=3){const bH=NG.getX(_G),cH=NG.getX(_G+1),dH=NG.getX(_G+2);(MG=DH(this,YG,HG,fG,OG,PG,QG,RG,SG,bH,cH,dH))&&(MG.faceIndex=Math.floor(_G/3),MG.face.materialIndex=XG.materialIndex,IG.push(MG))}}else{const eH=Math.max(0,UG.start),fH=Math.min(NG.count,UG.start+UG.count);for(let gH=eH,hH=fH;gH<hH;gH+=3){const iH=NG.getX(gH),jH=NG.getX(gH+1),kH=NG.getX(gH+2);(MG=DH(this,KG,HG,fG,OG,PG,QG,RG,SG,iH,jH,kH))&&(MG.faceIndex=Math.floor(gH/3),IG.push(MG))}}else if(void 0!==OG)if(Array.isArray(KG))for(let lH=0,mH=TG.length;lH<mH;lH++){const nH=TG[lH],oH=KG[nH.materialIndex],pH=Math.max(nH.start,UG.start),qH=Math.min(OG.count,Math.min(nH.start+nH.count,UG.start+UG.count));for(let rH=pH,sH=qH;rH<sH;rH+=3){const tH=rH,uH=rH+1,vH=rH+2;(MG=DH(this,oH,HG,fG,OG,PG,QG,RG,SG,tH,uH,vH))&&(MG.faceIndex=Math.floor(rH/3),MG.face.materialIndex=nH.materialIndex,IG.push(MG))}}else{const wH=Math.max(0,UG.start),xH=Math.min(OG.count,UG.start+UG.count);for(let yH=wH,zH=xH;yH<zH;yH+=3){const AH=yH,BH=yH+1,CH=yH+2;(MG=DH(this,KG,HG,fG,OG,PG,QG,RG,SG,AH,BH,CH))&&(MG.faceIndex=Math.floor(yH/3),IG.push(MG))}}}else JG.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function DH(a,b,c,d,e,f,i,j,k,l,m,n){hG.fromBufferAttribute(e,l),iG.fromBufferAttribute(e,m),jG.fromBufferAttribute(e,n);const o=a.morphTargetInfluences;if(f&&o){nG.set(0,0,0),oG.set(0,0,0),pG.set(0,0,0);for(let p=0,q=f.length;p<q;p++){const r=o[p],s=f[p];0!==r&&(kG.fromBufferAttribute(s,l),lG.fromBufferAttribute(s,m),mG.fromBufferAttribute(s,n),i?(nG.addScaledVector(kG,r),oG.addScaledVector(lG,r),pG.addScaledVector(mG,r)):(nG.addScaledVector(kG.sub(hG),r),oG.addScaledVector(lG.sub(iG),r),pG.addScaledVector(mG.sub(jG),r)))}hG.add(nG),iG.add(oG),jG.add(pG)}a.isSkinnedMesh&&(a.boneTransform(l,hG),a.boneTransform(m,iG),a.boneTransform(n,jG));const t=function(a,b,c,d,e,f,i,j){if(null===(b.side===g?d.intersectTriangle(i,f,e,!0,j):d.intersectTriangle(e,f,i,b.side!==h,j)))return null;uG.copy(j),uG.applyMatrix4(a.matrixWorld);const k=c.ray.origin.distanceTo(uG);return k<c.near||k>c.far?null:{distance:k,point:uG.clone(),object:a}}(a,b,c,d,hG,iG,jG,tG);if(t){j&&(qG.fromBufferAttribute(j,l),rG.fromBufferAttribute(j,m),sG.fromBufferAttribute(j,n),t.uv=Vy.getUV(tG,hG,iG,jG,qG,rG,sG,new ba())),k&&(qG.fromBufferAttribute(k,l),rG.fromBufferAttribute(k,m),sG.fromBufferAttribute(k,n),t.uv2=Vy.getUV(tG,hG,iG,jG,qG,rG,sG,new ba()));const u={a:l,b:m,c:n,normal:new nk(),materialIndex:0};Vy.getNormal(hG,iG,jG,u.normal),t.face=u}return t}vG.prototype.isMesh=!0;class EH extends MC{constructor(FH=1,GH=1,HH=1,IH=1,JH=1,KH=1){super(),this.type="BoxGeometry",this.parameters={width:FH,height:GH,depth:HH,widthSegments:IH,heightSegments:JH,depthSegments:KH};const LH=this;IH=Math.floor(IH),JH=Math.floor(JH),KH=Math.floor(KH);const MH=[],NH=[],OH=[],PH=[];let QH=0,RH=0;function SH(a,b,c,d,e,f,g,h,i,j,k){const l=f/i,m=g/j,n=f/2,o=g/2,p=h/2,q=i+1,r=j+1;let s=0,t=0;const u=new nk();for(let v=0;v<r;v++){const w=v*m-o;for(let x=0;x<q;x++){const y=x*l-n;u[a]=y*d,u[b]=w*e,u[c]=p,NH.push(u.x,u.y,u.z),u[a]=0,u[b]=0,u[c]=h>0?1:-1,OH.push(u.x,u.y,u.z),PH.push(x/i),PH.push(1-v/j),s+=1}}for(let z=0;z<j;z++)for(let A=0;A<i;A++){const B=QH+A+q*z,C=QH+A+q*(z+1),D=QH+(A+1)+q*(z+1),E=QH+(A+1)+q*z;MH.push(B,C,E),MH.push(C,D,E),t+=6}LH.addGroup(RH,t,k),RH+=t,QH+=s}SH("z","y","x",-1,-1,HH,GH,FH,KH,JH,0),SH("z","y","x",1,-1,HH,GH,-FH,KH,JH,1),SH("x","z","y",1,1,FH,HH,GH,IH,KH,2),SH("x","z","y",1,-1,FH,HH,-GH,IH,KH,3),SH("x","y","z",1,-1,FH,GH,HH,IH,JH,4),SH("x","y","z",-1,-1,FH,GH,-HH,IH,JH,5),this.setIndex(MH),this.setAttribute("position",new BC(NH,3)),this.setAttribute("normal",new BC(OH,3)),this.setAttribute("uv",new BC(PH,2))}static fromJSON(TH){return new EH(TH.width,TH.height,TH.depth,TH.widthSegments,TH.heightSegments,TH.depthSegments)}}function UH(a){const b={};for(const c in a)for(const d in b[c]={},a[c]){const e=a[c][d];e&&(e.isColor||e.isMatrix3||e.isMatrix4||e.isVector2||e.isVector3||e.isVector4||e.isTexture||e.isQuaternion)?b[c][d]=e.clone():Array.isArray(e)?b[c][d]=e.slice():b[c][d]=e}return b}function VH(a){const b={};for(let c=0;c<a.length;c++){const d=UH(a[c]);for(const e in d)b[e]=d[e]}return b}const WH={clone:UH,merge:VH};class XH extends wA{constructor(YH){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==YH&&(void 0!==YH.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(YH))}copy(ZH){return super.copy(ZH),this.fragmentShader=ZH.fragmentShader,this.vertexShader=ZH.vertexShader,this.uniforms=UH(ZH.uniforms),this.defines=Object.assign({},ZH.defines),this.wireframe=ZH.wireframe,this.wireframeLinewidth=ZH.wireframeLinewidth,this.lights=ZH.lights,this.clipping=ZH.clipping,this.extensions=Object.assign({},ZH.extensions),this.glslVersion=ZH.glslVersion,this}toJSON($H){const _H=super.toJSON($H);for(const aI in _H.glslVersion=this.glslVersion,_H.uniforms={},this.uniforms){const bI=this.uniforms[aI],cI=bI.value;cI&&cI.isTexture?_H.uniforms[aI]={type:"t",value:cI.toJSON($H).uuid}:cI&&cI.isColor?_H.uniforms[aI]={type:"c",value:cI.getHex()}:cI&&cI.isVector2?_H.uniforms[aI]={type:"v2",value:cI.toArray()}:cI&&cI.isVector3?_H.uniforms[aI]={type:"v3",value:cI.toArray()}:cI&&cI.isVector4?_H.uniforms[aI]={type:"v4",value:cI.toArray()}:cI&&cI.isMatrix3?_H.uniforms[aI]={type:"m3",value:cI.toArray()}:cI&&cI.isMatrix4?_H.uniforms[aI]={type:"m4",value:cI.toArray()}:_H.uniforms[aI]={value:cI}}Object.keys(this.defines).length>0&&(_H.defines=this.defines),_H.vertexShader=this.vertexShader,_H.fragmentShader=this.fragmentShader;const dI={};for(const eI in this.extensions)!0===this.extensions[eI]&&(dI[eI]=!0);return Object.keys(dI).length>0&&(_H.extensions=dI),_H}}XH.prototype.isShaderMaterial=!0;class fI extends Sw{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Hq(),this.projectionMatrix=new Hq(),this.projectionMatrixInverse=new Hq()}copy(gI,hI){return super.copy(gI,hI),this.matrixWorldInverse.copy(gI.matrixWorldInverse),this.projectionMatrix.copy(gI.projectionMatrix),this.projectionMatrixInverse.copy(gI.projectionMatrixInverse),this}getWorldDirection(iI){this.updateWorldMatrix(!0,!1);const jI=this.matrixWorld.elements;return iI.set(-jI[8],-jI[9],-jI[10]).normalize()}updateMatrixWorld(kI){super.updateMatrixWorld(kI),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(lI,mI){super.updateWorldMatrix(lI,mI),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}fI.prototype.isCamera=!0;class nI extends fI{constructor(oI=50,pI=1,qI=.1,rI=2e3){super(),this.type="PerspectiveCamera",this.fov=oI,this.zoom=1,this.near=qI,this.far=rI,this.focus=10,this.aspect=pI,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(sI,tI){return super.copy(sI,tI),this.fov=sI.fov,this.zoom=sI.zoom,this.near=sI.near,this.far=sI.far,this.focus=sI.focus,this.aspect=sI.aspect,this.view=null===sI.view?null:Object.assign({},sI.view),this.filmGauge=sI.filmGauge,this.filmOffset=sI.filmOffset,this}setFocalLength(uI){const vI=.5*this.getFilmHeight()/uI;this.fov=2*U*Math.atan(vI),this.updateProjectionMatrix()}getFocalLength(){const wI=Math.tan(.5*T*this.fov);return .5*this.getFilmHeight()/wI}getEffectiveFOV(){return 2*U*Math.atan(Math.tan(.5*T*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(xI,yI,zI,AI,BI,CI){this.aspect=xI/yI,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=xI,this.view.fullHeight=yI,this.view.offsetX=zI,this.view.offsetY=AI,this.view.width=BI,this.view.height=CI,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const DI=this.near;let EI=DI*Math.tan(.5*T*this.fov)/this.zoom,FI=2*EI,GI=this.aspect*FI,HI=-0.5*GI;const II=this.view;if(null!==this.view&&this.view.enabled){const JI=II.fullWidth,KI=II.fullHeight;HI+=II.offsetX*GI/JI,EI-=II.offsetY*FI/KI,GI*=II.width/JI,FI*=II.height/KI}const LI=this.filmOffset;0!==LI&&(HI+=DI*LI/this.getFilmWidth()),this.projectionMatrix.makePerspective(HI,HI+GI,EI,EI-FI,DI,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(MI){const NI=super.toJSON(MI);return NI.object.fov=this.fov,NI.object.zoom=this.zoom,NI.object.near=this.near,NI.object.far=this.far,NI.object.focus=this.focus,NI.object.aspect=this.aspect,null!==this.view&&(NI.object.view=Object.assign({},this.view)),NI.object.filmGauge=this.filmGauge,NI.object.filmOffset=this.filmOffset,NI}}nI.prototype.isPerspectiveCamera=!0;class OI extends Sw{constructor(PI,QI,RI){if(super(),this.type="CubeCamera",!0!==RI.isWebGLCubeRenderTarget){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=RI;const SI=new nI(90,1,PI,QI);SI.layers=this.layers,SI.up.set(0,-1,0),SI.lookAt(new nk(1,0,0)),this.add(SI);const TI=new nI(90,1,PI,QI);TI.layers=this.layers,TI.up.set(0,-1,0),TI.lookAt(new nk(-1,0,0)),this.add(TI);const UI=new nI(90,1,PI,QI);UI.layers=this.layers,UI.up.set(0,0,1),UI.lookAt(new nk(0,1,0)),this.add(UI);const VI=new nI(90,1,PI,QI);VI.layers=this.layers,VI.up.set(0,0,-1),VI.lookAt(new nk(0,-1,0)),this.add(VI);const WI=new nI(90,1,PI,QI);WI.layers=this.layers,WI.up.set(0,-1,0),WI.lookAt(new nk(0,0,1)),this.add(WI);const XI=new nI(90,1,PI,QI);XI.layers=this.layers,XI.up.set(0,-1,0),XI.lookAt(new nk(0,0,-1)),this.add(XI)}update(YI,ZI){null===this.parent&&this.updateMatrixWorld();const $I=this.renderTarget,[_I,aJ,bJ,cJ,dJ,eJ]=this.children,fJ=YI.xr.enabled,gJ=YI.getRenderTarget();YI.xr.enabled=!1;const hJ=$I.texture.generateMipmaps;$I.texture.generateMipmaps=!1,YI.setRenderTarget($I,0),YI.render(ZI,_I),YI.setRenderTarget($I,1),YI.render(ZI,aJ),YI.setRenderTarget($I,2),YI.render(ZI,bJ),YI.setRenderTarget($I,3),YI.render(ZI,cJ),YI.setRenderTarget($I,4),YI.render(ZI,dJ),$I.texture.generateMipmaps=hJ,YI.setRenderTarget($I,5),YI.render(ZI,eJ),YI.setRenderTarget(gJ),YI.xr.enabled=fJ,$I.texture.needsPMREMUpdate=!0}}class iJ extends df{constructor(jJ,kJ,lJ,mJ,nJ,oJ,pJ,qJ,rJ,sJ){super(jJ=void 0!==jJ?jJ:[],kJ=void 0!==kJ?kJ:301,lJ,mJ,nJ,oJ,pJ,qJ,rJ,sJ),this.flipY=!1}get images(){return this.image}set images(tJ){this.image=tJ}}iJ.prototype.isCubeTexture=!0;class uJ extends hh{constructor(vJ,wJ,xJ){Number.isInteger(wJ)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),wJ=xJ),super(vJ,vJ,wJ),wJ=wJ||{},this.texture=new iJ(void 0,wJ.mapping,wJ.wrapS,wJ.wrapT,wJ.magFilter,wJ.minFilter,wJ.format,wJ.type,wJ.anisotropy,wJ.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==wJ.generateMipmaps&&wJ.generateMipmaps,this.texture.minFilter=void 0!==wJ.minFilter?wJ.minFilter:o}fromEquirectangularTexture(yJ,zJ){this.texture.type=zJ.type,this.texture.format=1023,this.texture.encoding=zJ.encoding,this.texture.generateMipmaps=zJ.generateMipmaps,this.texture.minFilter=zJ.minFilter,this.texture.magFilter=zJ.magFilter;const AJ={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},BJ=new EH(5,5,5),CJ=new XH({name:"CubemapFromEquirect",uniforms:UH(AJ.uniforms),vertexShader:AJ.vertexShader,fragmentShader:AJ.fragmentShader,side:g,blending:0});CJ.uniforms.tEquirect.value=zJ;const DJ=new vG(BJ,CJ),EJ=zJ.minFilter;zJ.minFilter===q&&(zJ.minFilter=o);const FJ=new OI(1,10,this);return FJ.update(yJ,DJ),zJ.minFilter=EJ,DJ.geometry.dispose(),DJ.material.dispose(),this}clear(GJ,HJ,IJ,JJ){const KJ=GJ.getRenderTarget();for(let LJ=0;LJ<6;LJ++)GJ.setRenderTarget(this,LJ),GJ.clear(HJ,IJ,JJ);GJ.setRenderTarget(KJ)}}uJ.prototype.isWebGLCubeRenderTarget=!0;const MJ=new nk(),NJ=new nk(),OJ=new sb();class PJ{constructor(QJ=new nk(1,0,0),RJ=0){this.normal=QJ,this.constant=RJ}set(SJ,TJ){return this.normal.copy(SJ),this.constant=TJ,this}setComponents(UJ,VJ,WJ,XJ){return this.normal.set(UJ,VJ,WJ),this.constant=XJ,this}setFromNormalAndCoplanarPoint(YJ,ZJ){return this.normal.copy(YJ),this.constant=-ZJ.dot(this.normal),this}setFromCoplanarPoints($J,_J,aK){const bK=MJ.subVectors(aK,_J).cross(NJ.subVectors($J,_J)).normalize();return this.setFromNormalAndCoplanarPoint(bK,$J),this}copy(cK){return this.normal.copy(cK.normal),this.constant=cK.constant,this}normalize(){const dK=1/this.normal.length();return this.normal.multiplyScalar(dK),this.constant*=dK,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(eK){return this.normal.dot(eK)+this.constant}distanceToSphere(fK){return this.distanceToPoint(fK.center)-fK.radius}projectPoint(gK,hK){return hK.copy(this.normal).multiplyScalar(-this.distanceToPoint(gK)).add(gK)}intersectLine(iK,jK){const kK=iK.delta(MJ),lK=this.normal.dot(kK);if(0===lK)return 0===this.distanceToPoint(iK.start)?jK.copy(iK.start):null;const mK=-(iK.start.dot(this.normal)+this.constant)/lK;return mK<0||mK>1?null:jK.copy(kK).multiplyScalar(mK).add(iK.start)}intersectsLine(nK){const oK=this.distanceToPoint(nK.start),pK=this.distanceToPoint(nK.end);return oK<0&&pK>0||pK<0&&oK>0}intersectsBox(qK){return qK.intersectsPlane(this)}intersectsSphere(rK){return rK.intersectsPlane(this)}coplanarPoint(sK){return sK.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(tK,uK){const vK=uK||OJ.getNormalMatrix(tK),wK=this.coplanarPoint(MJ).applyMatrix4(tK),xK=this.normal.applyMatrix3(vK).normalize();return this.constant=-wK.dot(xK),this}translate(yK){return this.constant-=yK.dot(this.normal),this}equals(zK){return zK.normal.equals(this.normal)&&zK.constant===this.constant}clone(){return new this.constructor().copy(this)}}PJ.prototype.isPlane=!0;const AK=new Eo(),BK=new nk();class CK{constructor(DK=new PJ(),EK=new PJ(),FK=new PJ(),GK=new PJ(),HK=new PJ(),IK=new PJ()){this.planes=[DK,EK,FK,GK,HK,IK]}set(JK,KK,LK,MK,NK,OK){const PK=this.planes;return PK[0].copy(JK),PK[1].copy(KK),PK[2].copy(LK),PK[3].copy(MK),PK[4].copy(NK),PK[5].copy(OK),this}copy(QK){const RK=this.planes;for(let SK=0;SK<6;SK++)RK[SK].copy(QK.planes[SK]);return this}setFromProjectionMatrix(TK){const UK=this.planes,VK=TK.elements,WK=VK[0],XK=VK[1],YK=VK[2],ZK=VK[3],$K=VK[4],_K=VK[5],aL=VK[6],bL=VK[7],cL=VK[8],dL=VK[9],eL=VK[10],fL=VK[11],gL=VK[12],hL=VK[13],iL=VK[14],jL=VK[15];return UK[0].setComponents(ZK-WK,bL-$K,fL-cL,jL-gL).normalize(),UK[1].setComponents(ZK+WK,bL+$K,fL+cL,jL+gL).normalize(),UK[2].setComponents(ZK+XK,bL+_K,fL+dL,jL+hL).normalize(),UK[3].setComponents(ZK-XK,bL-_K,fL-dL,jL-hL).normalize(),UK[4].setComponents(ZK-YK,bL-aL,fL-eL,jL-iL).normalize(),UK[5].setComponents(ZK+YK,bL+aL,fL+eL,jL+iL).normalize(),this}intersectsObject(kL){const lL=kL.geometry;return null===lL.boundingSphere&&lL.computeBoundingSphere(),AK.copy(lL.boundingSphere).applyMatrix4(kL.matrixWorld),this.intersectsSphere(AK)}intersectsSprite(mL){return AK.center.set(0,0,0),AK.radius=.7071067811865476,AK.applyMatrix4(mL.matrixWorld),this.intersectsSphere(AK)}intersectsSphere(nL){const oL=this.planes,pL=nL.center,qL=-nL.radius;for(let rL=0;rL<6;rL++){const sL=oL[rL].distanceToPoint(pL);if(sL<qL)return!1}return!0}intersectsBox(tL){const uL=this.planes;for(let vL=0;vL<6;vL++){const wL=uL[vL];if(BK.x=wL.normal.x>0?tL.max.x:tL.min.x,BK.y=wL.normal.y>0?tL.max.y:tL.min.y,BK.z=wL.normal.z>0?tL.max.z:tL.min.z,0>wL.distanceToPoint(BK))return!1}return!0}containsPoint(xL){const yL=this.planes;for(let zL=0;zL<6;zL++)if(0>yL[zL].distanceToPoint(xL))return!1;return!0}clone(){return new this.constructor().copy(this)}}function AL(){let a=null,b=!1,c=null,d=null;function e(b,f){c(b,f),d=a.requestAnimationFrame(e)}return{start:function(){!0!==b&&null!==c&&(d=a.requestAnimationFrame(e),b=!0)},stop:function(){a.cancelAnimationFrame(d),b=!1},setAnimationLoop:function(a){c=a},setContext:function(b){a=b}}}function BL(a,b){const c=b.isWebGL2,d=new WeakMap();return{get:function(a){return a.isInterleavedBufferAttribute&&(a=a.data),d.get(a)},remove:function(b){b.isInterleavedBufferAttribute&&(b=b.data);const c=d.get(b);c&&(a.deleteBuffer(c.buffer),d.delete(b))},update:function(b,e){if(b.isGLBufferAttribute){const f=d.get(b);(!f||f.version<b.version)&&d.set(b,{buffer:b.buffer,type:b.type,bytesPerElement:b.elementSize,version:b.version});return}b.isInterleavedBufferAttribute&&(b=b.data);const g=d.get(b);void 0===g?d.set(b,function(b,d){const e=b.array,f=b.usage,g=a.createBuffer();a.bindBuffer(d,g),a.bufferData(d,e,f),b.onUploadCallback();let h=5126;return e instanceof Float32Array?h=5126:e instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):e instanceof Uint16Array?b.isFloat16BufferAttribute?c?h=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):h=5123:e instanceof Int16Array?h=5122:e instanceof Uint32Array?h=5125:e instanceof Int32Array?h=5124:e instanceof Int8Array?h=5120:e instanceof Uint8Array?h=5121:e instanceof Uint8ClampedArray&&(h=5121),{buffer:g,type:h,bytesPerElement:e.BYTES_PER_ELEMENT,version:b.version}}(b,e)):g.version<b.version&&(!function(b,d,e){const f=d.array,g=d.updateRange;a.bindBuffer(e,b),-1===g.count?a.bufferSubData(e,0,f):(c?a.bufferSubData(e,g.offset*f.BYTES_PER_ELEMENT,f,g.offset,g.count):a.bufferSubData(e,g.offset*f.BYTES_PER_ELEMENT,f.subarray(g.offset,g.offset+g.count)),g.count=-1)}(g.buffer,b,e),g.version=b.version)}}}class CL extends MC{constructor(DL=1,EL=1,FL=1,GL=1){super(),this.type="PlaneGeometry",this.parameters={width:DL,height:EL,widthSegments:FL,heightSegments:GL};const HL=DL/2,IL=EL/2,JL=Math.floor(FL),KL=Math.floor(GL),LL=JL+1,ML=KL+1,NL=DL/JL,OL=EL/KL,PL=[],QL=[],RL=[],SL=[];for(let TL=0;TL<ML;TL++){const UL=TL*OL-IL;for(let VL=0;VL<LL;VL++){const WL=VL*NL-HL;QL.push(WL,-UL,0),RL.push(0,0,1),SL.push(VL/JL),SL.push(1-TL/KL)}}for(let XL=0;XL<KL;XL++)for(let YL=0;YL<JL;YL++){const ZL=YL+LL*XL,$L=YL+LL*(XL+1),_L=YL+1+LL*(XL+1),aM=YL+1+LL*XL;PL.push(ZL,$L,aM),PL.push($L,_L,aM)}this.setIndex(PL),this.setAttribute("position",new BC(QL,3)),this.setAttribute("normal",new BC(RL,3)),this.setAttribute("uv",new BC(SL,2))}static fromJSON(bM){return new CL(bM.width,bM.height,bM.widthSegments,bM.heightSegments)}}const cM={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},dM={common:{diffuse:{value:new Dd(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new sb()},uv2Transform:{value:new sb()},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ba(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Dd(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Dd(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new sb()}},sprite:{diffuse:{value:new Dd(16777215)},opacity:{value:1},center:{value:new ba(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new sb()}}},eM={basic:{uniforms:VH([dM.common,dM.specularmap,dM.envmap,dM.aomap,dM.lightmap,dM.fog]),vertexShader:cM.meshbasic_vert,fragmentShader:cM.meshbasic_frag},lambert:{uniforms:VH([dM.common,dM.specularmap,dM.envmap,dM.aomap,dM.lightmap,dM.emissivemap,dM.fog,dM.lights,{emissive:{value:new Dd(0)}}]),vertexShader:cM.meshlambert_vert,fragmentShader:cM.meshlambert_frag},phong:{uniforms:VH([dM.common,dM.specularmap,dM.envmap,dM.aomap,dM.lightmap,dM.emissivemap,dM.bumpmap,dM.normalmap,dM.displacementmap,dM.fog,dM.lights,{emissive:{value:new Dd(0)},specular:{value:new Dd(1118481)},shininess:{value:30}}]),vertexShader:cM.meshphong_vert,fragmentShader:cM.meshphong_frag},standard:{uniforms:VH([dM.common,dM.envmap,dM.aomap,dM.lightmap,dM.emissivemap,dM.bumpmap,dM.normalmap,dM.displacementmap,dM.roughnessmap,dM.metalnessmap,dM.fog,dM.lights,{emissive:{value:new Dd(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:cM.meshphysical_vert,fragmentShader:cM.meshphysical_frag},toon:{uniforms:VH([dM.common,dM.aomap,dM.lightmap,dM.emissivemap,dM.bumpmap,dM.normalmap,dM.displacementmap,dM.gradientmap,dM.fog,dM.lights,{emissive:{value:new Dd(0)}}]),vertexShader:cM.meshtoon_vert,fragmentShader:cM.meshtoon_frag},matcap:{uniforms:VH([dM.common,dM.bumpmap,dM.normalmap,dM.displacementmap,dM.fog,{matcap:{value:null}}]),vertexShader:cM.meshmatcap_vert,fragmentShader:cM.meshmatcap_frag},points:{uniforms:VH([dM.points,dM.fog]),vertexShader:cM.points_vert,fragmentShader:cM.points_frag},dashed:{uniforms:VH([dM.common,dM.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:cM.linedashed_vert,fragmentShader:cM.linedashed_frag},depth:{uniforms:VH([dM.common,dM.displacementmap]),vertexShader:cM.depth_vert,fragmentShader:cM.depth_frag},normal:{uniforms:VH([dM.common,dM.bumpmap,dM.normalmap,dM.displacementmap,{opacity:{value:1}}]),vertexShader:cM.meshnormal_vert,fragmentShader:cM.meshnormal_frag},sprite:{uniforms:VH([dM.sprite,dM.fog]),vertexShader:cM.sprite_vert,fragmentShader:cM.sprite_frag},background:{uniforms:{uvTransform:{value:new sb()},t2D:{value:null}},vertexShader:cM.background_vert,fragmentShader:cM.background_frag},cube:{uniforms:VH([dM.envmap,{opacity:{value:1}}]),vertexShader:cM.cube_vert,fragmentShader:cM.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:cM.equirect_vert,fragmentShader:cM.equirect_frag},distanceRGBA:{uniforms:VH([dM.common,dM.displacementmap,{referencePosition:{value:new nk()},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:cM.distanceRGBA_vert,fragmentShader:cM.distanceRGBA_frag},shadow:{uniforms:VH([dM.lights,dM.fog,{color:{value:new Dd(0)},opacity:{value:1}},]),vertexShader:cM.shadow_vert,fragmentShader:cM.shadow_frag}};function fM(a,b,c,d,e,h){const i=new Dd(0);let j=!0===e?0:1,k,l,m=null,n=0,o=null;function p(a,b){c.buffers.color.setClear(a.r,a.g,a.b,b,h)}return{getClearColor:function(){return i},setClearColor:function(a,b=1){i.set(a),p(i,j=b)},getClearAlpha:function(){return j},setClearAlpha:function(a){p(i,j=a)},render:function(c,e){let h=!1,q=!0===e.isScene?e.background:null;q&&q.isTexture&&(q=b.get(q));const r=a.xr,s=r.getSession&&r.getSession();s&&"additive"===s.environmentBlendMode&&(q=null),null===q?p(i,j):q&&q.isColor&&(p(q,1),h=!0),(a.autoClear||h)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),q&&(q.isCubeTexture||306===q.mapping)?(void 0===l&&((l=new vG(new EH(1,1,1),new XH({name:"BackgroundCubeMaterial",uniforms:UH(eM.cube.uniforms),vertexShader:eM.cube.vertexShader,fragmentShader:eM.cube.fragmentShader,side:g,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(a,b,c){this.matrixWorld.copyPosition(c.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),d.update(l)),l.material.uniforms.envMap.value=q,l.material.uniforms.flipEnvMap.value=q.isCubeTexture&& !1===q.isRenderTargetTexture?-1:1,(m!==q||n!==q.version||o!==a.toneMapping)&&(l.material.needsUpdate=!0,m=q,n=q.version,o=a.toneMapping),c.unshift(l,l.geometry,l.material,0,0,null)):q&&q.isTexture&&(void 0===k&&((k=new vG(new CL(2,2),new XH({name:"BackgroundMaterial",uniforms:UH(eM.background.uniforms),vertexShader:eM.background.vertexShader,fragmentShader:eM.background.fragmentShader,side:f,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(k.material,"map",{get:function(){return this.uniforms.t2D.value}}),d.update(k)),k.material.uniforms.t2D.value=q,!0===q.matrixAutoUpdate&&q.updateMatrix(),k.material.uniforms.uvTransform.value.copy(q.matrix),(m!==q||n!==q.version||o!==a.toneMapping)&&(k.material.needsUpdate=!0,m=q,n=q.version,o=a.toneMapping),c.unshift(k,k.geometry,k.material,0,0,null))}}}function gM(a,b,c,d){const e=a.getParameter(34921),f=d.isWebGL2?null:b.get("OES_vertex_array_object"),g=d.isWebGL2||null!==f,h={},i=m(null);let j=i;function k(b){return d.isWebGL2?a.bindVertexArray(b):f.bindVertexArrayOES(b)}function l(b){return d.isWebGL2?a.deleteVertexArray(b):f.deleteVertexArrayOES(b)}function m(a){const b=[],c=[],d=[];for(let f=0;f<e;f++)b[f]=0,c[f]=0,d[f]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:b,enabledAttributes:c,attributeDivisors:d,object:a,attributes:{},index:null}}function n(){const a=j.newAttributes;for(let b=0,c=a.length;b<c;b++)a[b]=0}function o(a){p(a,0)}function p(c,e){const f=j.newAttributes,g=j.enabledAttributes,h=j.attributeDivisors;if(f[c]=1,0===g[c]&&(a.enableVertexAttribArray(c),g[c]=1),h[c]!==e){const i=d.isWebGL2?a:b.get("ANGLE_instanced_arrays");i[d.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](c,e),h[c]=e}}function q(){const b=j.newAttributes,c=j.enabledAttributes;for(let d=0,e=c.length;d<e;d++)c[d]!==b[d]&&(a.disableVertexAttribArray(d),c[d]=0)}function r(b,c,e,f,g,h){!0===d.isWebGL2&&(5124===e||5125===e)?a.vertexAttribIPointer(b,c,e,g,h):a.vertexAttribPointer(b,c,e,f,g,h)}function s(){t(),j!==i&&k((j=i).object)}function t(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:function(e,i,l,s,t){let u=!1;if(g){const v=function(b,c,e){const g=!0===e.wireframe;let i=h[b.id];void 0===i&&(i={},h[b.id]=i);let j=i[c.id];void 0===j&&(j={},i[c.id]=j);let k=j[g];return void 0===k&&(k=m(d.isWebGL2?a.createVertexArray():f.createVertexArrayOES()),j[g]=k),k}(s,l,i);j!==v&&k((j=v).object),(u=(function(a,b){const c=j.attributes,d=a.attributes;let e=0;for(const f in d){const g=c[f],h=d[f];if(void 0===g)return!0;if(g.attribute!==h)return!0;if(g.data!==h.data)return!0;e++}return j.attributesNum!==e||j.index!==b})(s,t))&&(function(a,b){const c={},d=a.attributes;let e=0;for(const f in d){const g=d[f],h={};h.attribute=g,g.data&&(h.data=g.data),c[f]=h,e++}j.attributes=c,j.attributesNum=e,j.index=b})(s,t)}else{const w=!0===i.wireframe;(j.geometry!==s.id||j.program!==l.id||j.wireframe!==w)&&(j.geometry=s.id,j.program=l.id,j.wireframe=w,u=!0)}!0===e.isInstancedMesh&&(u=!0),null!==t&&c.update(t,34963),u&&((function(e,f,g,h){if(!1===d.isWebGL2&&(e.isInstancedMesh||h.isInstancedBufferGeometry)&&null===b.get("ANGLE_instanced_arrays"))return;n();const i=h.attributes,j=g.getAttributes(),k=f.defaultAttributeValues;for(const l in j){const m=j[l];if(m.location>=0){let s=i[l];if(void 0===s&&("instanceMatrix"===l&&e.instanceMatrix&&(s=e.instanceMatrix),"instanceColor"===l&&e.instanceColor&&(s=e.instanceColor)),void 0!==s){const t=s.normalized,u=s.itemSize,v=c.get(s);if(void 0===v)continue;const w=v.buffer,x=v.type,y=v.bytesPerElement;if(s.isInterleavedBufferAttribute){const z=s.data,A=z.stride,B=s.offset;if(z&&z.isInstancedInterleavedBuffer){for(let C=0;C<m.locationSize;C++)p(m.location+C,z.meshPerAttribute);!0!==e.isInstancedMesh&& void 0===h._maxInstanceCount&&(h._maxInstanceCount=z.meshPerAttribute*z.count)}else for(let D=0;D<m.locationSize;D++)o(m.location+D);a.bindBuffer(34962,w);for(let E=0;E<m.locationSize;E++)r(m.location+E,u/m.locationSize,x,t,A*y,(B+u/m.locationSize*E)*y)}else{if(s.isInstancedBufferAttribute){for(let F=0;F<m.locationSize;F++)p(m.location+F,s.meshPerAttribute);!0!==e.isInstancedMesh&& void 0===h._maxInstanceCount&&(h._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let G=0;G<m.locationSize;G++)o(m.location+G);a.bindBuffer(34962,w);for(let H=0;H<m.locationSize;H++)r(m.location+H,u/m.locationSize,x,t,u*y,u/m.locationSize*H*y)}}else if(void 0!==k){const I=k[l];if(void 0!==I)switch(I.length){case 2:a.vertexAttrib2fv(m.location,I);break;case 3:a.vertexAttrib3fv(m.location,I);break;case 4:a.vertexAttrib4fv(m.location,I);break;default:a.vertexAttrib1fv(m.location,I)}}}}q()})(e,i,l,s),null!==t&&a.bindBuffer(34963,c.get(t).buffer))},reset:s,resetDefaultState:t,dispose:function(){for(const a in s(),h){const b=h[a];for(const c in b){const d=b[c];for(const e in d)l(d[e].object),delete d[e];delete b[c]}delete h[a]}},releaseStatesOfGeometry:function(a){if(void 0===h[a.id])return;const b=h[a.id];for(const c in b){const d=b[c];for(const e in d)l(d[e].object),delete d[e];delete b[c]}delete h[a.id]},releaseStatesOfProgram:function(a){for(const b in h){const c=h[b];if(void 0===c[a.id])continue;const d=c[a.id];for(const e in d)l(d[e].object),delete d[e];delete c[a.id]}},initAttributes:n,enableAttribute:o,disableUnusedAttributes:q}}function hM(a,b,c,d){const e=d.isWebGL2;let f;this.setMode=function(a){f=a},this.render=function(b,d){a.drawArrays(f,b,d),c.update(d,f,1)},this.renderInstances=function(d,g,h){if(0===h)return;let i,j;if(e)i=a,j="drawArraysInstanced";else if(j="drawArraysInstancedANGLE",null===(i=b.get("ANGLE_instanced_arrays"))){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}i[j](f,d,g,h),c.update(g,f,h)}}function iM(a,b,c){let d;function e(b){if("highp"===b){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";b="mediump"}return"mediump"===b&&a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const f="undefined"!=typeof WebGL2RenderingContext&&a instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&a instanceof WebGL2ComputeRenderingContext;let g=void 0!==c.precision?c.precision:"highp";const h=e(g);h!==g&&(console.warn("THREE.WebGLRenderer:",g,"not supported, using",h,"instead."),g=h);const i=f||b.has("WEBGL_draw_buffers"),j=!0===c.logarithmicDepthBuffer,k=a.getParameter(34930),l=a.getParameter(35660),m=a.getParameter(3379),n=a.getParameter(34076),o=a.getParameter(34921),p=a.getParameter(36347),q=a.getParameter(36348),r=a.getParameter(36349),s=l>0,t=f||b.has("OES_texture_float"),u=f?a.getParameter(36183):0;return{isWebGL2:f,drawBuffers:i,getMaxAnisotropy:function(){if(void 0!==d)return d;if(!0===b.has("EXT_texture_filter_anisotropic")){const c=b.get("EXT_texture_filter_anisotropic");d=a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else d=0;return d},getMaxPrecision:e,precision:g,logarithmicDepthBuffer:j,maxTextures:k,maxVertexTextures:l,maxTextureSize:m,maxCubemapSize:n,maxAttributes:o,maxVertexUniforms:p,maxVaryings:q,maxFragmentUniforms:r,vertexTextures:s,floatFragmentTextures:t,floatVertexTextures:s&&t,maxSamples:u}}function jM(a){const b=this;let c=null,d=0,e=!1,f=!1;const g=new PJ(),h=new sb(),i={value:null,needsUpdate:!1};function j(){i.value!==c&&(i.value=c,i.needsUpdate=d>0),b.numPlanes=d,b.numIntersection=0}function k(a,c,d,e){const f=null!==a?a.length:0;let j=null;if(0!==f){if(j=i.value,!0!==e||null===j){const k=d+4*f,l=c.matrixWorldInverse;h.getNormalMatrix(l),(null===j||j.length<k)&&(j=new Float32Array(k));for(let m=0,n=d;m!==f;++m,n+=4)g.copy(a[m]).applyMatrix4(l,h),g.normal.toArray(j,n),j[n+3]=g.constant}i.value=j,i.needsUpdate=!0}return b.numPlanes=f,b.numIntersection=0,j}this.uniform=i,this.numPlanes=0,this.numIntersection=0,this.init=function(a,b,f){const g=0!==a.length||b||0!==d||e;return e=b,c=k(a,f,0),d=a.length,g},this.beginShadows=function(){f=!0,k(null)},this.endShadows=function(){f=!1,j()},this.setState=function(b,g,h){const l=b.clippingPlanes,m=b.clipIntersection,n=b.clipShadows,o=a.get(b);if(e&&null!==l&&0!==l.length&&(!f||n)){const p=f?0:d,q=4*p;let r=o.clippingState||null;i.value=r,r=k(l,g,q,h);for(let s=0;s!==q;++s)r[s]=c[s];o.clippingState=r,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=p}else f?k(null):j()}}function kM(a){let b=new WeakMap();function c(a,b){return 303===b?a.mapping=301:304===b&&(a.mapping=302),a}function d(a){const c=a.target;c.removeEventListener("dispose",d);const e=b.get(c);void 0!==e&&(b.delete(c),e.dispose())}return{get:function(e){if(e&&e.isTexture&& !1===e.isRenderTargetTexture){const f=e.mapping;if(303===f||304===f){if(b.has(e)){const g=b.get(e).texture;return c(g,e.mapping)}{const h=e.image;if(!h||!(h.height>0))return null;{const i=new uJ(h.height/2);return i.fromEquirectangularTexture(a,e),b.set(e,i),e.addEventListener("dispose",d),c(i.texture,e.mapping)}}}}return e},dispose:function(){b=new WeakMap()}}}eM.physical={uniforms:VH([eM.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ba(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Dd(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new ba()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Dd(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Dd(1,1,1)},specularColorMap:{value:null}}]),vertexShader:cM.meshphysical_vert,fragmentShader:cM.meshphysical_frag};class lM extends fI{constructor(mM=-1,nM=1,oM=1,pM=-1,qM=.1,rM=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=mM,this.right=nM,this.top=oM,this.bottom=pM,this.near=qM,this.far=rM,this.updateProjectionMatrix()}copy(sM,tM){return super.copy(sM,tM),this.left=sM.left,this.right=sM.right,this.top=sM.top,this.bottom=sM.bottom,this.near=sM.near,this.far=sM.far,this.zoom=sM.zoom,this.view=null===sM.view?null:Object.assign({},sM.view),this}setViewOffset(uM,vM,wM,xM,yM,zM){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=uM,this.view.fullHeight=vM,this.view.offsetX=wM,this.view.offsetY=xM,this.view.width=yM,this.view.height=zM,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const AM=(this.right-this.left)/(2*this.zoom),BM=(this.top-this.bottom)/(2*this.zoom),CM=(this.right+this.left)/2,DM=(this.top+this.bottom)/2;let EM=CM-AM,FM=CM+AM,GM=DM+BM,HM=DM-BM;if(null!==this.view&&this.view.enabled){const IM=(this.right-this.left)/this.view.fullWidth/this.zoom,JM=(this.top-this.bottom)/this.view.fullHeight/this.zoom;FM=(EM+=IM*this.view.offsetX)+IM*this.view.width,HM=(GM-=JM*this.view.offsetY)-JM*this.view.height}this.projectionMatrix.makeOrthographic(EM,FM,GM,HM,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(KM){const LM=super.toJSON(KM);return LM.object.zoom=this.zoom,LM.object.left=this.left,LM.object.right=this.right,LM.object.top=this.top,LM.object.bottom=this.bottom,LM.object.near=this.near,LM.object.far=this.far,null!==this.view&&(LM.object.view=Object.assign({},this.view)),LM}}lM.prototype.isOrthographicCamera=!0;class MM extends XH{constructor(NM){super(NM),this.type="RawShaderMaterial"}}MM.prototype.isRawShaderMaterial=!0;const OM=[.125,.215,.35,.446,.526,.582],PM=5+OM.length,QM=new lM(),{_lodPlanes:RM,_sizeLods:SM,_sigmas:TM}=function(){const a=[],b=[],c=[];let d=8;for(let e=0;e<PM;e++){const f=Math.pow(2,d);b.push(f);let g=1/f;e>4?g=OM[e-8+4-1]:0===e&&(g=0),c.push(g);const h=1/(f-1),i=-h/2,j=1+h/2,k=[i,i,j,i,j,j,i,i,j,j,i,j],l=6,m=6,n=3,o=2,p=1,q=new Float32Array(n*m*l),r=new Float32Array(o*m*l),s=new Float32Array(p*m*l);for(let t=0;t<l;t++){const u=t%3*2/3-1,v=t>2?0:-1,w=[u,v,0,u+2/3,v,0,u+2/3,v+1,0,u,v,0,u+2/3,v+1,0,u,v+1,0];q.set(w,n*m*t),r.set(k,o*m*t);const x=[t,t,t,t,t,t];s.set(x,p*m*t)}const y=new MC();y.setAttribute("position",new TA(q,n)),y.setAttribute("uv",new TA(r,o)),y.setAttribute("faceIndex",new TA(s,p)),a.push(y),d>4&&d--}return{_lodPlanes:a,_sizeLods:b,_sigmas:c}}(),UM=new Dd();let VM=null;const WM=(1+Math.sqrt(5))/2,XM=1/WM,YM=[new nk(1,1,1),new nk(-1,1,1),new nk(1,1,-1),new nk(-1,1,-1),new nk(0,WM,XM),new nk(0,WM,-XM),new nk(XM,0,WM),new nk(-XM,0,WM),new nk(WM,XM,0),new nk(-WM,XM,0)];class ZM{constructor($M){this._renderer=$M,this._pingPongRenderTarget=null,this._blurMaterial=(function(a){const b=new Float32Array(a),c=new nk(0,1,0),d=new MM({name:"SphericalGaussianBlur",defines:{n:a},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:b},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:c}},vertexShader:zO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return d})(20),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(_M,aN=0,bN=.1,cN=100){VM=this._renderer.getRenderTarget();const dN=this._allocateTargets();return this._sceneToCubeUV(_M,bN,cN,dN),aN>0&&this._blur(dN,0,0,aN),this._applyPMREM(dN),this._cleanup(dN),dN}fromEquirectangular(eN,fN=null){return this._fromTexture(eN,fN)}fromCubemap(gN,hN=null){return this._fromTexture(gN,hN)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=yO(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=xO(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let iN=0;iN<RM.length;iN++)RM[iN].dispose()}_cleanup(jN){this._renderer.setRenderTarget(VM),jN.scissorTest=!1,wO(jN,0,0,jN.width,jN.height)}_fromTexture(kN,lN){VM=this._renderer.getRenderTarget();const mN=lN||this._allocateTargets(kN);return this._textureToCubeUV(kN,mN),this._applyPMREM(mN),this._cleanup(mN),mN}_allocateTargets(nN){const oN={magFilter:o,minFilter:o,generateMipmaps:!1,type:1016,format:1023,encoding:3e3,depthBuffer:!1},pN=vO(oN);return pN.depthBuffer=!nN,null===this._pingPongRenderTarget&&(this._pingPongRenderTarget=vO(oN)),pN}_compileMaterial(qN){const rN=new vG(RM[0],qN);this._renderer.compile(rN,QM)}_sceneToCubeUV(sN,tN,uN,vN){const wN=new nI(90,1,tN,uN),xN=[1,-1,1,1,1,1],yN=[1,1,1,-1,-1,-1],zN=this._renderer,AN=zN.autoClear,BN=zN.toneMapping;zN.getClearColor(UM),zN.toneMapping=0,zN.autoClear=!1;const CN=new OA({name:"PMREM.Background",side:g,depthWrite:!1,depthTest:!1}),DN=new vG(new EH(),CN);let EN=!1;const FN=sN.background;FN?FN.isColor&&(CN.color.copy(FN),sN.background=null,EN=!0):(CN.color.copy(UM),EN=!0);for(let GN=0;GN<6;GN++){const HN=GN%3;0===HN?(wN.up.set(0,xN[GN],0),wN.lookAt(yN[GN],0,0)):1===HN?(wN.up.set(0,0,xN[GN]),wN.lookAt(0,yN[GN],0)):(wN.up.set(0,xN[GN],0),wN.lookAt(0,0,yN[GN])),wO(vN,256*HN,GN>2?256:0,256,256),zN.setRenderTarget(vN),EN&&zN.render(DN,wN),zN.render(sN,wN)}DN.geometry.dispose(),DN.material.dispose(),zN.toneMapping=BN,zN.autoClear=AN,sN.background=FN}_textureToCubeUV(IN,JN){const KN=this._renderer,LN=301===IN.mapping||302===IN.mapping;LN?(null===this._cubemapShader&&(this._cubemapShader=yO()),this._cubemapShader.uniforms.flipEnvMap.value=!1===IN.isRenderTargetTexture?-1:1):null===this._equirectShader&&(this._equirectShader=xO());const MN=LN?this._cubemapShader:this._equirectShader,NN=new vG(RM[0],MN),ON=MN.uniforms;ON.envMap.value=IN,LN||ON.texelSize.value.set(1/IN.image.width,1/IN.image.height),wO(JN,0,0,768,512),KN.setRenderTarget(JN),KN.render(NN,QM)}_applyPMREM(PN){const QN=this._renderer,RN=QN.autoClear;QN.autoClear=!1;for(let SN=1;SN<PM;SN++){const TN=Math.sqrt(TM[SN]*TM[SN]-TM[SN-1]*TM[SN-1]),UN=YM[(SN-1)%YM.length];this._blur(PN,SN-1,SN,TN,UN)}QN.autoClear=RN}_blur(VN,WN,XN,YN,ZN){const $N=this._pingPongRenderTarget;this._halfBlur(VN,$N,WN,XN,YN,"latitudinal",ZN),this._halfBlur($N,VN,XN,XN,YN,"longitudinal",ZN)}_halfBlur(_N,aO,bO,cO,dO,eO,fO){const gO=this._renderer,hO=this._blurMaterial;"latitudinal"!==eO&&"longitudinal"!==eO&&console.error("blur direction must be either latitudinal or longitudinal!");const iO=new vG(RM[cO],hO),jO=hO.uniforms,kO=SM[bO]-1,lO=isFinite(dO)?Math.PI/(2*kO):2*Math.PI/39,mO=dO/lO,nO=isFinite(dO)?1+Math.floor(3*mO):20;nO>20&&console.warn(`sigmaRadians, ${dO}, is too large and will clip, as it requested ${nO} samples when the maximum is set to 20`);const oO=[];let pO=0;for(let qO=0;qO<20;++qO){const rO=qO/mO,sO=Math.exp(-rO*rO/2);oO.push(sO),0===qO?pO+=sO:qO<nO&&(pO+=2*sO)}for(let tO=0;tO<oO.length;tO++)oO[tO]=oO[tO]/pO;jO.envMap.value=_N.texture,jO.samples.value=nO,jO.weights.value=oO,jO.latitudinal.value="latitudinal"===eO,fO&&(jO.poleAxis.value=fO),jO.dTheta.value=lO,jO.mipInt.value=8-bO;const uO=SM[cO];wO(aO,3*Math.max(0,256-2*uO),(0===cO?0:512)+2*uO*(cO>4?cO-8+4:0),3*uO,2*uO),gO.setRenderTarget(aO),gO.render(iO,QM)}}function vO(a){const b=new hh(768,768,a);return b.texture.mapping=306,b.texture.name="PMREM.cubeUv",b.scissorTest=!0,b}function wO(a,b,c,d,e){a.viewport.set(b,c,d,e),a.scissor.set(b,c,d,e)}function xO(){const a=new ba(1,1),b=new MM({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:a}},vertexShader:zO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = texture2D ( envMap, uv ).rgb;
				uv.x += texelSize.x;
				vec3 tr = texture2D ( envMap, uv ).rgb;
				uv.y += texelSize.y;
				vec3 br = texture2D ( envMap, uv ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = texture2D ( envMap, uv ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return b}function yO(){const a=new MM({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:zO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return a}function zO(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function AO(a){let b=new WeakMap(),c=null;function d(a){const c=a.target;c.removeEventListener("dispose",d);const e=b.get(c);void 0!==e&&(b.delete(c),e.dispose())}return{get:function(e){if(e&&e.isTexture){const f=e.mapping,g=303===f||304===f,h=301===f||302===f;if(g||h){if(e.isRenderTargetTexture&& !0===e.needsPMREMUpdate){e.needsPMREMUpdate=!1;let i=b.get(e);return null===c&&(c=new ZM(a)),i=g?c.fromEquirectangular(e,i):c.fromCubemap(e,i),b.set(e,i),i.texture}if(b.has(e))return b.get(e).texture;{const j=e.image;if(!(g&&j&&j.height>0||h&&j&&function(a){let b=0;for(let c=0;c<6;c++)void 0!==a[c]&&b++;return 6===b}(j)))return null;{null===c&&(c=new ZM(a));const k=g?c.fromEquirectangular(e):c.fromCubemap(e);return b.set(e,k),e.addEventListener("dispose",d),k.texture}}}}return e},dispose:function(){b=new WeakMap(),null!==c&&(c.dispose(),c=null)}}}function BO(a){const b={};function c(c){if(void 0!==b[c])return b[c];let d;switch(c){case"WEBGL_depth_texture":d=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":d=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":d=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":d=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:d=a.getExtension(c)}return b[c]=d,d}return{has:function(a){return null!==c(a)},init:function(a){a.isWebGL2?c("EXT_color_buffer_float"):(c("WEBGL_depth_texture"),c("OES_texture_float"),c("OES_texture_half_float"),c("OES_texture_half_float_linear"),c("OES_standard_derivatives"),c("OES_element_index_uint"),c("OES_vertex_array_object"),c("ANGLE_instanced_arrays")),c("OES_texture_float_linear"),c("EXT_color_buffer_half_float"),c("WEBGL_multisampled_render_to_texture")},get:function(a){const b=c(a);return null===b&&console.warn("THREE.WebGLRenderer: "+a+" extension not supported."),b}}}function CO(a,b,c,d){const e={},f=new WeakMap();function g(a){const h=a.target;for(const i in null!==h.index&&b.remove(h.index),h.attributes)b.remove(h.attributes[i]);h.removeEventListener("dispose",g),delete e[h.id];const j=f.get(h);j&&(b.remove(j),f.delete(h)),d.releaseStatesOfGeometry(h),!0===h.isInstancedBufferGeometry&&delete h._maxInstanceCount,c.memory.geometries--}function h(a){const c=[],d=a.index,e=a.attributes.position;let g=0;if(null!==d){const h=d.array;g=d.version;for(let i=0,j=h.length;i<j;i+=3){const k=h[i+0],l=h[i+1],m=h[i+2];c.push(k,l,l,m,m,k)}}else{const n=e.array;g=e.version;for(let o=0,p=n.length/3-1;o<p;o+=3){const q=o+0,r=o+1,s=o+2;c.push(q,r,r,s,s,q)}}const t=new(vd(c)?uC:qC)(c,1);t.version=g;const u=f.get(a);u&&b.remove(u),f.set(a,t)}return{get:function(a,b){return!0===e[b.id]||(b.addEventListener("dispose",g),e[b.id]=!0,c.memory.geometries++),b},update:function(a){const c=a.attributes;for(const d in c)b.update(c[d],34962);const e=a.morphAttributes;for(const f in e){const g=e[f];for(let h=0,i=g.length;h<i;h++)b.update(g[h],34962)}},getWireframeAttribute:function(a){const b=f.get(a);if(b){const c=a.index;null!==c&&b.version<c.version&&h(a)}else h(a);return f.get(a)}}}function DO(a,b,c,d){const e=d.isWebGL2;let f,g,h;this.setMode=function(a){f=a},this.setIndex=function(a){g=a.type,h=a.bytesPerElement},this.render=function(b,d){a.drawElements(f,d,g,b*h),c.update(d,f,1)},this.renderInstances=function(d,i,j){if(0===j)return;let k,l;if(e)k=a,l="drawElementsInstanced";else if(l="drawElementsInstancedANGLE",null===(k=b.get("ANGLE_instanced_arrays"))){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}k[l](f,i,g,d*h,j),c.update(i,f,j)}}function EO(a){const b={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:b,programs:null,autoReset:!0,reset:function(){b.frame++,b.calls=0,b.triangles=0,b.points=0,b.lines=0},update:function(a,c,d){switch(b.calls++,c){case 4:b.triangles+=d*(a/3);break;case 1:b.lines+=d*(a/2);break;case 3:b.lines+=d*(a-1);break;case 2:b.lines+=d*a;break;case 0:b.points+=d*a;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",c);break}}}}class FO extends df{constructor(GO=null,HO=1,IO=1,JO=1){super(null),this.image={data:GO,width:HO,height:IO,depth:JO},this.magFilter=l,this.minFilter=l,this.wrapR=j,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}function KO(a,b){return a[0]-b[0]}function LO(a,b){return Math.abs(b[1])-Math.abs(a[1])}function MO(a,b){let c=1;const d=b.isInterleavedBufferAttribute?b.data.array:b.array;d instanceof Int8Array?c=127:d instanceof Int16Array?c=32767:d instanceof Int32Array?c=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",d),a.divideScalar(c)}function NO(a,b,c){const d={},e=new Float32Array(8),f=new WeakMap(),g=new nk(),h=[];for(let i=0;i<8;i++)h[i]=[i,0];return{update:function(i,j,k,l){const m=i.morphTargetInfluences;if(!0===b.isWebGL2){const n=j.morphAttributes.position.length;let o=f.get(j);if(void 0===o||o.count!==n){void 0!==o&&o.texture.dispose();const p=void 0!==j.morphAttributes.normal,q=j.morphAttributes.position,r=j.morphAttributes.normal||[],s=j.attributes.position.count,t=!0===p?2:1;let u=s*t,v=1;u>b.maxTextureSize&&(v=Math.ceil(u/b.maxTextureSize),u=b.maxTextureSize);const w=new Float32Array(u*v*4*n),x=new FO(w,u,v,n);x.format=1023,x.type=1015,x.needsUpdate=!0;const y=4*t;for(let z=0;z<n;z++){const A=q[z],B=r[z],C=u*v*4*z;for(let D=0;D<A.count;D++){g.fromBufferAttribute(A,D),!0===A.normalized&&MO(g,A);const E=D*y;w[C+E+0]=g.x,w[C+E+1]=g.y,w[C+E+2]=g.z,w[C+E+3]=0,!0===p&&(g.fromBufferAttribute(B,D),!0===B.normalized&&MO(g,B),w[C+E+4]=g.x,w[C+E+5]=g.y,w[C+E+6]=g.z,w[C+E+7]=0)}}function F(){x.dispose(),f.delete(j),j.removeEventListener("dispose",F)}o={count:n,texture:x,size:new ba(u,v)},f.set(j,o),j.addEventListener("dispose",F)}let G=0;for(let H=0;H<m.length;H++)G+=m[H];const I=j.morphTargetsRelative?1:1-G;l.getUniforms().setValue(a,"morphTargetBaseInfluence",I),l.getUniforms().setValue(a,"morphTargetInfluences",m),l.getUniforms().setValue(a,"morphTargetsTexture",o.texture,c),l.getUniforms().setValue(a,"morphTargetsTextureSize",o.size)}else{const J=void 0===m?0:m.length;let K=d[j.id];if(void 0===K||K.length!==J){K=[];for(let L=0;L<J;L++)K[L]=[L,0];d[j.id]=K}for(let M=0;M<J;M++){const N=K[M];N[0]=M,N[1]=m[M]}K.sort(LO);for(let O=0;O<8;O++)O<J&&K[O][1]?(h[O][0]=K[O][0],h[O][1]=K[O][1]):(h[O][0]=Number.MAX_SAFE_INTEGER,h[O][1]=0);h.sort(KO);const P=j.morphAttributes.position,Q=j.morphAttributes.normal;let R=0;for(let S=0;S<8;S++){const T=h[S],U=T[0],V=T[1];U!==Number.MAX_SAFE_INTEGER&&V?(P&&j.getAttribute("morphTarget"+S)!==P[U]&&j.setAttribute("morphTarget"+S,P[U]),Q&&j.getAttribute("morphNormal"+S)!==Q[U]&&j.setAttribute("morphNormal"+S,Q[U]),e[S]=V,R+=V):(P&& !0===j.hasAttribute("morphTarget"+S)&&j.deleteAttribute("morphTarget"+S),Q&& !0===j.hasAttribute("morphNormal"+S)&&j.deleteAttribute("morphNormal"+S),e[S]=0)}const W=j.morphTargetsRelative?1:1-R;l.getUniforms().setValue(a,"morphTargetBaseInfluence",W),l.getUniforms().setValue(a,"morphTargetInfluences",e)}}}}function OO(a,b,c,d){let e=new WeakMap();function f(a){const b=a.target;b.removeEventListener("dispose",f),c.remove(b.instanceMatrix),null!==b.instanceColor&&c.remove(b.instanceColor)}return{update:function(a){const g=d.render.frame,h=a.geometry,i=b.get(a,h);return e.get(i)!==g&&(b.update(i),e.set(i,g)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",f)&&a.addEventListener("dispose",f),c.update(a.instanceMatrix,34962),null!==a.instanceColor&&c.update(a.instanceColor,34962)),i},dispose:function(){e=new WeakMap()}}}FO.prototype.isDataTexture2DArray=!0;class PO extends df{constructor(QO=null,RO=1,SO=1,TO=1){super(null),this.image={data:QO,width:RO,height:SO,depth:TO},this.magFilter=l,this.minFilter=l,this.wrapR=j,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}PO.prototype.isDataTexture3D=!0;const UO=new df(),VO=new FO(),WO=new PO(),XO=new iJ(),YO=[],ZO=[],$O=new Float32Array(16),_O=new Float32Array(9),aP=new Float32Array(4);function bP(a,b,c){const d=a[0];if(d<=0||d>0)return a;const e=b*c;let f=YO[e];if(void 0===f&&(f=new Float32Array(e),YO[e]=f),0!==b){d.toArray(f,0);for(let g=1,h=0;g!==b;++g)h+=c,a[g].toArray(f,h)}return f}function cP(a,b){if(a.length!==b.length)return!1;for(let c=0,d=a.length;c<d;c++)if(a[c]!==b[c])return!1;return!0}function dP(a,b){for(let c=0,d=b.length;c<d;c++)a[c]=b[c]}function eP(a,b){let c=ZO[b];void 0===c&&(c=new Int32Array(b),ZO[b]=c);for(let d=0;d!==b;++d)c[d]=a.allocateTextureUnit();return c}function fP(a,b){const c=this.cache;c[0]!==b&&(a.uniform1f(this.addr,b),c[0]=b)}function gP(a,b){const c=this.cache;if(void 0!==b.x)(c[0]!==b.x||c[1]!==b.y)&&(a.uniform2f(this.addr,b.x,b.y),c[0]=b.x,c[1]=b.y);else{if(cP(c,b))return;a.uniform2fv(this.addr,b),dP(c,b)}}function hP(a,b){const c=this.cache;if(void 0!==b.x)(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z)&&(a.uniform3f(this.addr,b.x,b.y,b.z),c[0]=b.x,c[1]=b.y,c[2]=b.z);else if(void 0!==b.r)(c[0]!==b.r||c[1]!==b.g||c[2]!==b.b)&&(a.uniform3f(this.addr,b.r,b.g,b.b),c[0]=b.r,c[1]=b.g,c[2]=b.b);else{if(cP(c,b))return;a.uniform3fv(this.addr,b),dP(c,b)}}function iP(a,b){const c=this.cache;if(void 0!==b.x)(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z||c[3]!==b.w)&&(a.uniform4f(this.addr,b.x,b.y,b.z,b.w),c[0]=b.x,c[1]=b.y,c[2]=b.z,c[3]=b.w);else{if(cP(c,b))return;a.uniform4fv(this.addr,b),dP(c,b)}}function jP(a,b){const c=this.cache,d=b.elements;if(void 0===d){if(cP(c,b))return;a.uniformMatrix2fv(this.addr,!1,b),dP(c,b)}else{if(cP(c,d))return;aP.set(d),a.uniformMatrix2fv(this.addr,!1,aP),dP(c,d)}}function kP(a,b){const c=this.cache,d=b.elements;if(void 0===d){if(cP(c,b))return;a.uniformMatrix3fv(this.addr,!1,b),dP(c,b)}else{if(cP(c,d))return;_O.set(d),a.uniformMatrix3fv(this.addr,!1,_O),dP(c,d)}}function lP(a,b){const c=this.cache,d=b.elements;if(void 0===d){if(cP(c,b))return;a.uniformMatrix4fv(this.addr,!1,b),dP(c,b)}else{if(cP(c,d))return;$O.set(d),a.uniformMatrix4fv(this.addr,!1,$O),dP(c,d)}}function mP(a,b){const c=this.cache;c[0]!==b&&(a.uniform1i(this.addr,b),c[0]=b)}function nP(a,b){const c=this.cache;cP(c,b)||(a.uniform2iv(this.addr,b),dP(c,b))}function oP(a,b){const c=this.cache;cP(c,b)||(a.uniform3iv(this.addr,b),dP(c,b))}function pP(a,b){const c=this.cache;cP(c,b)||(a.uniform4iv(this.addr,b),dP(c,b))}function qP(a,b){const c=this.cache;c[0]!==b&&(a.uniform1ui(this.addr,b),c[0]=b)}function rP(a,b){const c=this.cache;cP(c,b)||(a.uniform2uiv(this.addr,b),dP(c,b))}function sP(a,b){const c=this.cache;cP(c,b)||(a.uniform3uiv(this.addr,b),dP(c,b))}function tP(a,b){const c=this.cache;cP(c,b)||(a.uniform4uiv(this.addr,b),dP(c,b))}function uP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.safeSetTexture2D(b||UO,e)}function vP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.setTexture3D(b||WO,e)}function wP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.safeSetTextureCube(b||XO,e)}function xP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.setTexture2DArray(b||VO,e)}function yP(a,b){a.uniform1fv(this.addr,b)}function zP(a,b){const c=bP(b,this.size,2);a.uniform2fv(this.addr,c)}function AP(a,b){const c=bP(b,this.size,3);a.uniform3fv(this.addr,c)}function BP(a,b){const c=bP(b,this.size,4);a.uniform4fv(this.addr,c)}function CP(a,b){const c=bP(b,this.size,4);a.uniformMatrix2fv(this.addr,!1,c)}function DP(a,b){const c=bP(b,this.size,9);a.uniformMatrix3fv(this.addr,!1,c)}function EP(a,b){const c=bP(b,this.size,16);a.uniformMatrix4fv(this.addr,!1,c)}function FP(a,b){a.uniform1iv(this.addr,b)}function GP(a,b){a.uniform2iv(this.addr,b)}function HP(a,b){a.uniform3iv(this.addr,b)}function IP(a,b){a.uniform4iv(this.addr,b)}function JP(a,b){a.uniform1uiv(this.addr,b)}function KP(a,b){a.uniform2uiv(this.addr,b)}function LP(a,b){a.uniform3uiv(this.addr,b)}function MP(a,b){a.uniform4uiv(this.addr,b)}function NP(a,b,c){const d=b.length,e=eP(c,d);a.uniform1iv(this.addr,e);for(let f=0;f!==d;++f)c.safeSetTexture2D(b[f]||UO,e[f])}function OP(a,b,c){const d=b.length,e=eP(c,d);a.uniform1iv(this.addr,e);for(let f=0;f!==d;++f)c.setTexture3D(b[f]||WO,e[f])}function PP(a,b,c){const d=b.length,e=eP(c,d);a.uniform1iv(this.addr,e);for(let f=0;f!==d;++f)c.safeSetTextureCube(b[f]||XO,e[f])}function QP(a,b,c){const d=b.length,e=eP(c,d);a.uniform1iv(this.addr,e);for(let f=0;f!==d;++f)c.setTexture2DArray(b[f]||VO,e[f])}function RP(a,b,c){this.id=a,this.addr=c,this.cache=[],this.setValue=(function(a){switch(a){case 5126:return fP;case 35664:return gP;case 35665:return hP;case 35666:return iP;case 35674:return jP;case 35675:return kP;case 35676:return lP;case 5124:case 35670:return mP;case 35667:case 35671:return nP;case 35668:case 35672:return oP;case 35669:case 35673:return pP;case 5125:return qP;case 36294:return rP;case 36295:return sP;case 36296:return tP;case 35678:case 36198:case 36298:case 36306:case 35682:return uP;case 35679:case 36299:case 36307:return vP;case 35680:case 36300:case 36308:case 36293:return wP;case 36289:case 36303:case 36311:case 36292:return xP}})(b.type)}function SP(a,b,c){this.id=a,this.addr=c,this.cache=[],this.size=b.size,this.setValue=(function(a){switch(a){case 5126:return yP;case 35664:return zP;case 35665:return AP;case 35666:return BP;case 35674:return CP;case 35675:return DP;case 35676:return EP;case 5124:case 35670:return FP;case 35667:case 35671:return GP;case 35668:case 35672:return HP;case 35669:case 35673:return IP;case 5125:return JP;case 36294:return KP;case 36295:return LP;case 36296:return MP;case 35678:case 36198:case 36298:case 36306:case 35682:return NP;case 35679:case 36299:case 36307:return OP;case 35680:case 36300:case 36308:case 36293:return PP;case 36289:case 36303:case 36311:case 36292:return QP}})(b.type)}function TP(a){this.id=a,this.seq=[],this.map={}}SP.prototype.updateCache=function(a){const b=this.cache;a instanceof Float32Array&&b.length!==a.length&&(this.cache=new Float32Array(a.length)),dP(b,a)},TP.prototype.setValue=function(a,b,c){const d=this.seq;for(let e=0,f=d.length;e!==f;++e){const g=d[e];g.setValue(a,b[g.id],c)}};const UP=/(\w+)(\])?(\[|\.)?/g;function VP(a,b){a.seq.push(b),a.map[b.id]=b}function WP(a,b,c){const d=a.name,e=d.length;for(UP.lastIndex=0;;){const f=UP.exec(d),g=UP.lastIndex;let h=f[1];const i="]"===f[2],j=f[3];if(i&&(h|=0),void 0===j||"["===j&&g+2===e){VP(c,void 0===j?new RP(h,a,b):new SP(h,a,b));break}{const k=c.map;let l=k[h];void 0===l&&VP(c,l=new TP(h)),c=l}}}function XP(a,b){this.seq=[],this.map={};const c=a.getProgramParameter(b,35718);for(let d=0;d<c;++d){const e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name);WP(e,f,this)}}function YP(a,b,c){const d=a.createShader(b);return a.shaderSource(d,c),a.compileShader(d),d}XP.prototype.setValue=function(a,b,c,d){const e=this.map[b];void 0!==e&&e.setValue(a,c,d)},XP.prototype.setOptional=function(a,b,c){const d=b[c];void 0!==d&&this.setValue(a,c,d)},XP.upload=function(a,b,c,d){for(let e=0,f=b.length;e!==f;++e){const g=b[e],h=c[g.id];!1!==h.needsUpdate&&g.setValue(a,h.value,d)}},XP.seqWithValue=function(a,b){const c=[];for(let d=0,e=a.length;d!==e;++d){const f=a[d];f.id in b&&c.push(f)}return c};let ZP=0;function $P(a,b,c){const d=a.getShaderParameter(b,35713),e=a.getShaderInfoLog(b).trim();return d&&""===e?"":c.toUpperCase()+"\n\n"+e+"\n\n"+(function(a){const b=a.split("\n");for(let c=0;c<b.length;c++)b[c]=c+1+": "+b[c];return b.join("\n")})(a.getShaderSource(b))}function _P(a){return""!==a}function aQ(a,b){return a.replace(/NUM_DIR_LIGHTS/g,b.numDirLights).replace(/NUM_SPOT_LIGHTS/g,b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,b.numPointLights).replace(/NUM_HEMI_LIGHTS/g,b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,b.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,b.numPointLightShadows)}function bQ(a,b){return a.replace(/NUM_CLIPPING_PLANES/g,b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,b.numClippingPlanes-b.numClipIntersection)}const cQ=/^[ \t]*#include +<([\w\d./]+)>/gm;function dQ(a){return a.replace(cQ,eQ)}function eQ(a,b){const c=cM[b];if(void 0===c)throw new Error("Can not resolve #include <"+b+">");return dQ(c)}const fQ=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,gQ=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function hQ(a){return a.replace(gQ,jQ).replace(fQ,iQ)}function iQ(a,b,c,d){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),jQ(a,b,c,d)}function jQ(a,b,c,d){let e="";for(let f=parseInt(b);f<parseInt(c);f++)e+=d.replace(/\[\s*i\s*\]/g,"[ "+f+" ]").replace(/UNROLLED_LOOP_INDEX/g,f);return e}function kQ(a){let b="precision "+a.precision+" float;\nprecision "+a.precision+" int;";return"highp"===a.precision?b+="\n#define HIGH_PRECISION":"mediump"===a.precision?b+="\n#define MEDIUM_PRECISION":"lowp"===a.precision&&(b+="\n#define LOW_PRECISION"),b}function lQ(a,b,c,d){var e;const f=a.getContext(),g=c.defines;let h=c.vertexShader,i=c.fragmentShader,j;const k=(j="SHADOWMAP_TYPE_BASIC",1===(e=c).shadowMapType?j="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?j="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(j="SHADOWMAP_TYPE_VSM"),j),l=function(a){let b="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case 301:case 302:b="ENVMAP_TYPE_CUBE";break;case 306:case 307:b="ENVMAP_TYPE_CUBE_UV";break}return b}(c),m=function(a){let b="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case 302:case 307:b="ENVMAP_MODE_REFRACTION";break}return b}(c),n=function(a){let b="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case 0:b="ENVMAP_BLENDING_MULTIPLY";break;case 1:b="ENVMAP_BLENDING_MIX";break;case 2:b="ENVMAP_BLENDING_ADD";break}return b}(c),o=c.isWebGL2?"":function(a){const b=[a.extensionDerivatives||a.envMapCubeUV||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||"physical"===a.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return b.filter(_P).join("\n")}(c),p=function(a){const b=[];for(const c in a){const d=a[c];!1!==d&&b.push("#define "+c+" "+d)}return b.join("\n")}(g),q=f.createProgram();let r,s,t=c.glslVersion?"#version "+c.glslVersion+"\n":"";c.isRawShaderMaterial?((r=[p].filter(_P).join("\n")).length>0&&(r+="\n"),(s=[o,p].filter(_P).join("\n")).length>0&&(s+="\n")):(r=[kQ(c),"#define SHADER_NAME "+c.shaderName,p,c.instancing?"#define USE_INSTANCING":"",c.instancingColor?"#define USE_INSTANCING_COLOR":"",c.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+c.maxBones,c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&c.fogExp2?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.envMap?"#define "+m:"",c.lightMap?"#define USE_LIGHTMAP":"",c.aoMap?"#define USE_AOMAP":"",c.emissiveMap?"#define USE_EMISSIVEMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.normalMap&&c.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",c.normalMap&&c.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",c.clearcoatMap?"#define USE_CLEARCOATMAP":"",c.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",c.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",c.displacementMap&&c.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",c.specularColorMap?"#define USE_SPECULARCOLORMAP":"",c.roughnessMap?"#define USE_ROUGHNESSMAP":"",c.metalnessMap?"#define USE_METALNESSMAP":"",c.alphaMap?"#define USE_ALPHAMAP":"",c.transmission?"#define USE_TRANSMISSION":"",c.transmissionMap?"#define USE_TRANSMISSIONMAP":"",c.thicknessMap?"#define USE_THICKNESSMAP":"",c.sheenColorMap?"#define USE_SHEENCOLORMAP":"",c.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",c.vertexTangents?"#define USE_TANGENT":"",c.vertexColors?"#define USE_COLOR":"",c.vertexAlphas?"#define USE_COLOR_ALPHA":"",c.vertexUvs?"#define USE_UV":"",c.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",c.flatShading?"#define FLAT_SHADED":"",c.skinning?"#define USE_SKINNING":"",c.useVertexTexture?"#define BONE_TEXTURE":"",c.morphTargets?"#define USE_MORPHTARGETS":"",c.morphNormals&& !1===c.flatShading?"#define USE_MORPHNORMALS":"",c.morphTargets&&c.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",c.morphTargets&&c.isWebGL2?"#define MORPHTARGETS_COUNT "+c.morphTargetsCount:"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+k:"",c.sizeAttenuation?"#define USE_SIZEATTENUATION":"",c.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",c.logarithmicDepthBuffer&&c.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(_P).join("\n"),s=[o,kQ(c),"#define SHADER_NAME "+c.shaderName,p,c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&c.fogExp2?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.matcap?"#define USE_MATCAP":"",c.envMap?"#define USE_ENVMAP":"",c.envMap?"#define "+l:"",c.envMap?"#define "+m:"",c.envMap?"#define "+n:"",c.lightMap?"#define USE_LIGHTMAP":"",c.aoMap?"#define USE_AOMAP":"",c.emissiveMap?"#define USE_EMISSIVEMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.normalMap&&c.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",c.normalMap&&c.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",c.clearcoat?"#define USE_CLEARCOAT":"",c.clearcoatMap?"#define USE_CLEARCOATMAP":"",c.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",c.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",c.specularColorMap?"#define USE_SPECULARCOLORMAP":"",c.roughnessMap?"#define USE_ROUGHNESSMAP":"",c.metalnessMap?"#define USE_METALNESSMAP":"",c.alphaMap?"#define USE_ALPHAMAP":"",c.alphaTest?"#define USE_ALPHATEST":"",c.sheen?"#define USE_SHEEN":"",c.sheenColorMap?"#define USE_SHEENCOLORMAP":"",c.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",c.transmission?"#define USE_TRANSMISSION":"",c.transmissionMap?"#define USE_TRANSMISSIONMAP":"",c.thicknessMap?"#define USE_THICKNESSMAP":"",c.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",c.vertexTangents?"#define USE_TANGENT":"",c.vertexColors||c.instancingColor?"#define USE_COLOR":"",c.vertexAlphas?"#define USE_COLOR_ALPHA":"",c.vertexUvs?"#define USE_UV":"",c.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",c.gradientMap?"#define USE_GRADIENTMAP":"",c.flatShading?"#define FLAT_SHADED":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+k:"",c.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",c.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",c.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",c.logarithmicDepthBuffer&&c.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(c.extensionShaderTextureLOD||c.envMap)&&c.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==c.toneMapping?"#define TONE_MAPPING":"",0!==c.toneMapping?cM.tonemapping_pars_fragment:"",0!==c.toneMapping?function(a,b){let c;switch(b){case 1:c="Linear";break;case 2:c="Reinhard";break;case 3:c="OptimizedCineon";break;case 4:c="ACESFilmic";break;case 5:c="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",b),c="Linear"}return"vec3 "+a+"( vec3 color ) { return "+c+"ToneMapping( color ); }"}("toneMapping",c.toneMapping):"",c.dithering?"#define DITHERING":"",c.transparent?"":"#define OPAQUE",cM.encodings_pars_fragment,function(a,b){const c=function(a){switch(a){case 3e3:return["Linear","( value )"];case v:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",a),["Linear","( value )"]}}(b);return"vec4 "+a+"( vec4 value ) { return LinearTo"+c[0]+c[1]+"; }"}("linearToOutputTexel",c.outputEncoding),c.depthPacking?"#define DEPTH_PACKING "+c.depthPacking:"","\n"].filter(_P).join("\n")),h=bQ(h=aQ(h=dQ(h),c),c),i=dQ(i),i=aQ(i,c),i=bQ(i,c),h=hQ(h),i=hQ(i),c.isWebGL2&& !0!==c.isRawShaderMaterial&&(t="#version 300 es\n",r="precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n"+r,s=["#define varying in",c.glslVersion===x?"":"layout(location = 0) out highp vec4 pc_fragColor;",c.glslVersion===x?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+s);const u=YP(f,35633,t+r+h),w=YP(f,35632,t+s+i);if(f.attachShader(q,u),f.attachShader(q,w),void 0!==c.index0AttributeName?f.bindAttribLocation(q,0,c.index0AttributeName):!0===c.morphTargets&&f.bindAttribLocation(q,0,"position"),f.linkProgram(q),a.debug.checkShaderErrors){const y=f.getProgramInfoLog(q).trim(),z=f.getShaderInfoLog(u).trim(),A=f.getShaderInfoLog(w).trim();let B=!0,C=!0;if(!1===f.getProgramParameter(q,35714)){B=!1;const D=$P(f,u,"vertex"),E=$P(f,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+f.getError()+" - VALIDATE_STATUS "+f.getProgramParameter(q,35715)+"\n\nProgram Info Log: "+y+"\n"+D+"\n"+E)}else""!==y?console.warn("THREE.WebGLProgram: Program Info Log:",y):(""===z||""===A)&&(C=!1);C&&(this.diagnostics={runnable:B,programLog:y,vertexShader:{log:z,prefix:r},fragmentShader:{log:A,prefix:s}})}f.deleteShader(u),f.deleteShader(w);let F;this.getUniforms=function(){return void 0===F&&(F=new XP(f,q)),F};let G;return this.getAttributes=function(){return void 0===G&&(G=(function(a,b){const c={},d=a.getProgramParameter(b,35721);for(let e=0;e<d;e++){const f=a.getActiveAttrib(b,e),g=f.name;let h=1;35674===f.type&&(h=2),35675===f.type&&(h=3),35676===f.type&&(h=4),c[g]={type:f.type,location:a.getAttribLocation(b,g),locationSize:h}}return c})(f,q)),G},this.destroy=function(){d.releaseStatesOfProgram(this),f.deleteProgram(q),this.program=void 0},this.name=c.shaderName,this.id=ZP++,this.cacheKey=b,this.usedTimes=1,this.program=q,this.vertexShader=u,this.fragmentShader=w,this}let mQ=0;class nQ{constructor(){this.shaderCache=new Map(),this.materialCache=new Map()}update(oQ){const pQ=oQ.vertexShader,qQ=oQ.fragmentShader,rQ=this._getShaderStage(pQ),sQ=this._getShaderStage(qQ),tQ=this._getShaderCacheForMaterial(oQ);return!1===tQ.has(rQ)&&(tQ.add(rQ),rQ.usedTimes++),!1===tQ.has(sQ)&&(tQ.add(sQ),sQ.usedTimes++),this}remove(uQ){const vQ=this.materialCache.get(uQ);for(const wQ of vQ)wQ.usedTimes--,0===wQ.usedTimes&&this.shaderCache.delete(wQ);return this.materialCache.delete(uQ),this}getVertexShaderID(xQ){return this._getShaderStage(xQ.vertexShader).id}getFragmentShaderID(yQ){return this._getShaderStage(yQ.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(zQ){const AQ=this.materialCache;return!1===AQ.has(zQ)&&AQ.set(zQ,new Set()),AQ.get(zQ)}_getShaderStage(BQ){const CQ=this.shaderCache;if(!1===CQ.has(BQ)){const DQ=new EQ();CQ.set(BQ,DQ)}return CQ.get(BQ)}}class EQ{constructor(){this.id=mQ++,this.usedTimes=0}}function FQ(a,b,c,d,e,f,i){const j=new yw(),k=new nQ(),l=[],m=e.isWebGL2,n=e.logarithmicDepthBuffer,o=e.floatVertexTextures,p=e.maxVertexUniforms,q=e.vertexTextures;let r=e.precision;const s={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(f,j,l,t,u){const x=t.fog,y=f.isMeshStandardMaterial?t.environment:null,z=(f.isMeshStandardMaterial?c:b).get(f.envMap||y),A=s[f.type],B=u.isSkinnedMesh?function(a){const b=a.skeleton,c=b.bones;if(o)return 1024;{const d=p,e=Math.floor((d-20)/4),f=Math.min(e,c.length);return f<c.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+c.length+" bones. This GPU supports "+f+"."),0):f}}(u):0;null!==f.precision&&(r=e.getMaxPrecision(f.precision))!==f.precision&&console.warn("THREE.WebGLProgram.getParameters:",f.precision,"not supported, using",r,"instead.");let C,D,E,F;if(A){const G=eM[A];C=G.vertexShader,D=G.fragmentShader}else C=f.vertexShader,D=f.fragmentShader,k.update(f),E=k.getVertexShaderID(f),F=k.getFragmentShaderID(f);const H=a.getRenderTarget(),I=f.alphaTest>0,J=f.clearcoat>0,K={isWebGL2:m,shaderID:A,shaderName:f.type,vertexShader:C,fragmentShader:D,defines:f.defines,customVertexShaderID:E,customFragmentShaderID:F,isRawShaderMaterial:!0===f.isRawShaderMaterial,glslVersion:f.glslVersion,precision:r,instancing:!0===u.isInstancedMesh,instancingColor:!0===u.isInstancedMesh&&null!==u.instanceColor,supportsVertexTextures:q,outputEncoding:null===H?a.outputEncoding:!0===H.isXRRenderTarget?H.texture.encoding:3e3,map:!!f.map,matcap:!!f.matcap,envMap:!!z,envMapMode:z&&z.mapping,envMapCubeUV:!!z&&(306===z.mapping||307===z.mapping),lightMap:!!f.lightMap,aoMap:!!f.aoMap,emissiveMap:!!f.emissiveMap,bumpMap:!!f.bumpMap,normalMap:!!f.normalMap,objectSpaceNormalMap:1===f.normalMapType,tangentSpaceNormalMap:f.normalMapType===w,decodeVideoTexture:!!f.map&& !0===f.map.isVideoTexture&&f.map.encoding===v,clearcoat:J,clearcoatMap:J&&!!f.clearcoatMap,clearcoatRoughnessMap:J&&!!f.clearcoatRoughnessMap,clearcoatNormalMap:J&&!!f.clearcoatNormalMap,displacementMap:!!f.displacementMap,roughnessMap:!!f.roughnessMap,metalnessMap:!!f.metalnessMap,specularMap:!!f.specularMap,specularIntensityMap:!!f.specularIntensityMap,specularColorMap:!!f.specularColorMap,transparent:f.transparent,alphaMap:!!f.alphaMap,alphaTest:I,gradientMap:!!f.gradientMap,sheen:f.sheen>0,sheenColorMap:!!f.sheenColorMap,sheenRoughnessMap:!!f.sheenRoughnessMap,transmission:f.transmission>0,transmissionMap:!!f.transmissionMap,thicknessMap:!!f.thicknessMap,combine:f.combine,vertexTangents:!!f.normalMap&&!!u.geometry&&!!u.geometry.attributes.tangent,vertexColors:f.vertexColors,vertexAlphas:!0===f.vertexColors&&!!u.geometry&&!!u.geometry.attributes.color&&4===u.geometry.attributes.color.itemSize,vertexUvs:!!f.map||!!f.bumpMap||!!f.normalMap||!!f.specularMap||!!f.alphaMap||!!f.emissiveMap||!!f.roughnessMap||!!f.metalnessMap||!!f.clearcoatMap||!!f.clearcoatRoughnessMap||!!f.clearcoatNormalMap||!!f.displacementMap||!!f.transmissionMap||!!f.thicknessMap||!!f.specularIntensityMap||!!f.specularColorMap||!!f.sheenColorMap||!!f.sheenRoughnessMap,uvsVertexOnly:!(f.map||f.bumpMap||f.normalMap||f.specularMap||f.alphaMap||f.emissiveMap||f.roughnessMap||f.metalnessMap||f.clearcoatNormalMap||f.transmission>0||f.transmissionMap||f.thicknessMap||f.specularIntensityMap||f.specularColorMap||f.sheen>0||f.sheenColorMap||f.sheenRoughnessMap)&&!!f.displacementMap,fog:!!x,useFog:f.fog,fogExp2:x&&x.isFogExp2,flatShading:!!f.flatShading,sizeAttenuation:f.sizeAttenuation,logarithmicDepthBuffer:n,skinning:!0===u.isSkinnedMesh&&B>0,maxBones:B,useVertexTexture:o,morphTargets:!!u.geometry&&!!u.geometry.morphAttributes.position,morphNormals:!!u.geometry&&!!u.geometry.morphAttributes.normal,morphTargetsCount:u.geometry&&u.geometry.morphAttributes.position?u.geometry.morphAttributes.position.length:0,numDirLights:j.directional.length,numPointLights:j.point.length,numSpotLights:j.spot.length,numRectAreaLights:j.rectArea.length,numHemiLights:j.hemi.length,numDirLightShadows:j.directionalShadowMap.length,numPointLightShadows:j.pointShadowMap.length,numSpotLightShadows:j.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:f.dithering,shadowMapEnabled:a.shadowMap.enabled&&l.length>0,shadowMapType:a.shadowMap.type,toneMapping:f.toneMapped?a.toneMapping:0,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:f.premultipliedAlpha,doubleSided:f.side===h,flipSided:f.side===g,depthPacking:void 0!==f.depthPacking&&f.depthPacking,index0AttributeName:f.index0AttributeName,extensionDerivatives:f.extensions&&f.extensions.derivatives,extensionFragDepth:f.extensions&&f.extensions.fragDepth,extensionDrawBuffers:f.extensions&&f.extensions.drawBuffers,extensionShaderTextureLOD:f.extensions&&f.extensions.shaderTextureLOD,rendererExtensionFragDepth:m||d.has("EXT_frag_depth"),rendererExtensionDrawBuffers:m||d.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:m||d.has("EXT_shader_texture_lod"),customProgramCacheKey:f.customProgramCacheKey()};return K},getProgramCacheKey:function(b){var c,d,e,f;const g=[];if(b.shaderID?g.push(b.shaderID):(g.push(b.customVertexShaderID),g.push(b.customFragmentShaderID)),void 0!==b.defines)for(const h in b.defines)g.push(h),g.push(b.defines[h]);return!1===b.isRawShaderMaterial&&(c=g,d=b,c.push(d.precision),c.push(d.outputEncoding),c.push(d.envMapMode),c.push(d.combine),c.push(d.vertexUvs),c.push(d.fogExp2),c.push(d.sizeAttenuation),c.push(d.maxBones),c.push(d.morphTargetsCount),c.push(d.numDirLights),c.push(d.numPointLights),c.push(d.numSpotLights),c.push(d.numHemiLights),c.push(d.numRectAreaLights),c.push(d.numDirLightShadows),c.push(d.numPointLightShadows),c.push(d.numSpotLightShadows),c.push(d.shadowMapType),c.push(d.toneMapping),c.push(d.numClippingPlanes),c.push(d.numClipIntersection),e=g,f=b,j.disableAll(),f.isWebGL2&&j.enable(0),f.supportsVertexTextures&&j.enable(1),f.instancing&&j.enable(2),f.instancingColor&&j.enable(3),f.map&&j.enable(4),f.matcap&&j.enable(5),f.envMap&&j.enable(6),f.envMapCubeUV&&j.enable(7),f.lightMap&&j.enable(8),f.aoMap&&j.enable(9),f.emissiveMap&&j.enable(10),f.bumpMap&&j.enable(11),f.normalMap&&j.enable(12),f.objectSpaceNormalMap&&j.enable(13),f.tangentSpaceNormalMap&&j.enable(14),f.clearcoat&&j.enable(15),f.clearcoatMap&&j.enable(16),f.clearcoatRoughnessMap&&j.enable(17),f.clearcoatNormalMap&&j.enable(18),f.displacementMap&&j.enable(19),f.specularMap&&j.enable(20),f.roughnessMap&&j.enable(21),f.metalnessMap&&j.enable(22),f.gradientMap&&j.enable(23),f.alphaMap&&j.enable(24),f.alphaTest&&j.enable(25),f.vertexColors&&j.enable(26),f.vertexAlphas&&j.enable(27),f.vertexUvs&&j.enable(28),f.vertexTangents&&j.enable(29),f.uvsVertexOnly&&j.enable(30),f.fog&&j.enable(31),e.push(j.mask),j.disableAll(),f.useFog&&j.enable(0),f.flatShading&&j.enable(1),f.logarithmicDepthBuffer&&j.enable(2),f.skinning&&j.enable(3),f.useVertexTexture&&j.enable(4),f.morphTargets&&j.enable(5),f.morphNormals&&j.enable(6),f.premultipliedAlpha&&j.enable(7),f.shadowMapEnabled&&j.enable(8),f.physicallyCorrectLights&&j.enable(9),f.doubleSided&&j.enable(10),f.flipSided&&j.enable(11),f.depthPacking&&j.enable(12),f.dithering&&j.enable(13),f.specularIntensityMap&&j.enable(14),f.specularColorMap&&j.enable(15),f.transmission&&j.enable(16),f.transmissionMap&&j.enable(17),f.thicknessMap&&j.enable(18),f.sheen&&j.enable(19),f.sheenColorMap&&j.enable(20),f.sheenRoughnessMap&&j.enable(21),f.decodeVideoTexture&&j.enable(22),f.transparent&&j.enable(23),e.push(j.mask),g.push(a.outputEncoding)),g.push(b.customProgramCacheKey),g.join()},getUniforms:function(a){const b=s[a.type];let c;if(b){const d=eM[b];c=WH.clone(d.uniforms)}else c=a.uniforms;return c},acquireProgram:function(b,c){let d;for(let e=0,g=l.length;e<g;e++){const h=l[e];if(h.cacheKey===c){d=h,++d.usedTimes;break}}return void 0===d&&(d=new lQ(a,c,b,f),l.push(d)),d},releaseProgram:function(a){if(0== --a.usedTimes){const b=l.indexOf(a);l[b]=l[l.length-1],l.pop(),a.destroy()}},releaseShaderCache:function(a){k.remove(a)},programs:l,dispose:function(){k.dispose()}}}function GQ(){let a=new WeakMap();return{get:function(b){let c=a.get(b);return void 0===c&&(c={},a.set(b,c)),c},remove:function(b){a.delete(b)},update:function(b,c,d){a.get(b)[c]=d},dispose:function(){a=new WeakMap()}}}function HQ(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function IQ(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function JQ(){const a=[];let b=0;const c=[],d=[],e=[];function f(c,d,e,f,g,h){let i=a[b];return void 0===i?(i={id:c.id,object:c,geometry:d,material:e,groupOrder:f,renderOrder:c.renderOrder,z:g,group:h},a[b]=i):(i.id=c.id,i.object=c,i.geometry=d,i.material=e,i.groupOrder=f,i.renderOrder=c.renderOrder,i.z=g,i.group=h),b++,i}return{opaque:c,transmissive:d,transparent:e,init:function(){b=0,c.length=0,d.length=0,e.length=0},push:function(a,b,g,h,i,j){const k=f(a,b,g,h,i,j);g.transmission>0?d.push(k):!0===g.transparent?e.push(k):c.push(k)},unshift:function(a,b,g,h,i,j){const k=f(a,b,g,h,i,j);g.transmission>0?d.unshift(k):!0===g.transparent?e.unshift(k):c.unshift(k)},finish:function(){for(let c=b,d=a.length;c<d;c++){const e=a[c];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(a,b){c.length>1&&c.sort(a||HQ),d.length>1&&d.sort(b||IQ),e.length>1&&e.sort(b||IQ)}}}function KQ(){let a=new WeakMap();return{get:function(b,c){let d;return!1===a.has(b)?(d=new JQ(),a.set(b,[d])):c>=a.get(b).length?(d=new JQ(),a.get(b).push(d)):d=a.get(b)[c],d},dispose:function(){a=new WeakMap()}}}function LQ(){const a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];let c;switch(b.type){case"DirectionalLight":c={direction:new nk(),color:new Dd()};break;case"SpotLight":c={position:new nk(),direction:new nk(),color:new Dd(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":c={position:new nk(),color:new Dd(),distance:0,decay:0};break;case"HemisphereLight":c={direction:new nk(),skyColor:new Dd(),groundColor:new Dd()};break;case"RectAreaLight":c={color:new Dd(),position:new nk(),halfWidth:new nk(),halfHeight:new nk()};break}return a[b.id]=c,c}}}let MQ=0;function NQ(a,b){return(b.castShadow?1:0)-(a.castShadow?1:0)}function OQ(a,b){const c=new LQ(),d=function(){const a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];let c;switch(b.type){case"DirectionalLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ba()};break;case"SpotLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ba()};break;case"PointLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ba(),shadowCameraNear:1,shadowCameraFar:1e3};break}return a[b.id]=c,c}}}(),e={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)e.probe.push(new nk());const g=new nk(),h=new Hq(),i=new Hq();return{setup:function(f,g){let h=0,i=0,j=0;for(let k=0;k<9;k++)e.probe[k].set(0,0,0);let l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;f.sort(NQ);const t=!0!==g?Math.PI:1;for(let u=0,v=f.length;u<v;u++){const w=f[u],x=w.color,y=w.intensity,z=w.distance,A=w.shadow&&w.shadow.map?w.shadow.map.texture:null;if(w.isAmbientLight)h+=x.r*y*t,i+=x.g*y*t,j+=x.b*y*t;else if(w.isLightProbe)for(let B=0;B<9;B++)e.probe[B].addScaledVector(w.sh.coefficients[B],y);else if(w.isDirectionalLight){const C=c.get(w);if(C.color.copy(w.color).multiplyScalar(w.intensity*t),w.castShadow){const D=w.shadow,E=d.get(w);E.shadowBias=D.bias,E.shadowNormalBias=D.normalBias,E.shadowRadius=D.radius,E.shadowMapSize=D.mapSize,e.directionalShadow[l]=E,e.directionalShadowMap[l]=A,e.directionalShadowMatrix[l]=w.shadow.matrix,q++}e.directional[l]=C,l++}else if(w.isSpotLight){const F=c.get(w);if(F.position.setFromMatrixPosition(w.matrixWorld),F.color.copy(x).multiplyScalar(y*t),F.distance=z,F.coneCos=Math.cos(w.angle),F.penumbraCos=Math.cos(w.angle*(1-w.penumbra)),F.decay=w.decay,w.castShadow){const G=w.shadow,H=d.get(w);H.shadowBias=G.bias,H.shadowNormalBias=G.normalBias,H.shadowRadius=G.radius,H.shadowMapSize=G.mapSize,e.spotShadow[n]=H,e.spotShadowMap[n]=A,e.spotShadowMatrix[n]=w.shadow.matrix,s++}e.spot[n]=F,n++}else if(w.isRectAreaLight){const I=c.get(w);I.color.copy(x).multiplyScalar(y),I.halfWidth.set(.5*w.width,0,0),I.halfHeight.set(0,.5*w.height,0),e.rectArea[o]=I,o++}else if(w.isPointLight){const J=c.get(w);if(J.color.copy(w.color).multiplyScalar(w.intensity*t),J.distance=w.distance,J.decay=w.decay,w.castShadow){const K=w.shadow,L=d.get(w);L.shadowBias=K.bias,L.shadowNormalBias=K.normalBias,L.shadowRadius=K.radius,L.shadowMapSize=K.mapSize,L.shadowCameraNear=K.camera.near,L.shadowCameraFar=K.camera.far,e.pointShadow[m]=L,e.pointShadowMap[m]=A,e.pointShadowMatrix[m]=w.shadow.matrix,r++}e.point[m]=J,m++}else if(w.isHemisphereLight){const M=c.get(w);M.skyColor.copy(w.color).multiplyScalar(y*t),M.groundColor.copy(w.groundColor).multiplyScalar(y*t),e.hemi[p]=M,p++}}o>0&&(b.isWebGL2?(e.rectAreaLTC1=dM.LTC_FLOAT_1,e.rectAreaLTC2=dM.LTC_FLOAT_2):!0===a.has("OES_texture_float_linear")?(e.rectAreaLTC1=dM.LTC_FLOAT_1,e.rectAreaLTC2=dM.LTC_FLOAT_2):!0===a.has("OES_texture_half_float_linear")?(e.rectAreaLTC1=dM.LTC_HALF_1,e.rectAreaLTC2=dM.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),e.ambient[0]=h,e.ambient[1]=i,e.ambient[2]=j;const N=e.hash;(N.directionalLength!==l||N.pointLength!==m||N.spotLength!==n||N.rectAreaLength!==o||N.hemiLength!==p||N.numDirectionalShadows!==q||N.numPointShadows!==r||N.numSpotShadows!==s)&&(e.directional.length=l,e.spot.length=n,e.rectArea.length=o,e.point.length=m,e.hemi.length=p,e.directionalShadow.length=q,e.directionalShadowMap.length=q,e.pointShadow.length=r,e.pointShadowMap.length=r,e.spotShadow.length=s,e.spotShadowMap.length=s,e.directionalShadowMatrix.length=q,e.pointShadowMatrix.length=r,e.spotShadowMatrix.length=s,N.directionalLength=l,N.pointLength=m,N.spotLength=n,N.rectAreaLength=o,N.hemiLength=p,N.numDirectionalShadows=q,N.numPointShadows=r,N.numSpotShadows=s,e.version=MQ++)},setupView:function(a,b){let c=0,d=0,f=0,j=0,k=0;const l=b.matrixWorldInverse;for(let m=0,n=a.length;m<n;m++){const o=a[m];if(o.isDirectionalLight){const p=e.directional[c];p.direction.setFromMatrixPosition(o.matrixWorld),g.setFromMatrixPosition(o.target.matrixWorld),p.direction.sub(g),p.direction.transformDirection(l),c++}else if(o.isSpotLight){const q=e.spot[f];q.position.setFromMatrixPosition(o.matrixWorld),q.position.applyMatrix4(l),q.direction.setFromMatrixPosition(o.matrixWorld),g.setFromMatrixPosition(o.target.matrixWorld),q.direction.sub(g),q.direction.transformDirection(l),f++}else if(o.isRectAreaLight){const r=e.rectArea[j];r.position.setFromMatrixPosition(o.matrixWorld),r.position.applyMatrix4(l),i.identity(),h.copy(o.matrixWorld),h.premultiply(l),i.extractRotation(h),r.halfWidth.set(.5*o.width,0,0),r.halfHeight.set(0,.5*o.height,0),r.halfWidth.applyMatrix4(i),r.halfHeight.applyMatrix4(i),j++}else if(o.isPointLight){const s=e.point[d];s.position.setFromMatrixPosition(o.matrixWorld),s.position.applyMatrix4(l),d++}else if(o.isHemisphereLight){const t=e.hemi[k];t.direction.setFromMatrixPosition(o.matrixWorld),t.direction.transformDirection(l),t.direction.normalize(),k++}}},state:e}}function PQ(a,b){const c=new OQ(a,b),d=[],e=[];return{init:function(){d.length=0,e.length=0},state:{lightsArray:d,shadowsArray:e,lights:c},setupLights:function(a){c.setup(d,a)},setupLightsView:function(a){c.setupView(d,a)},pushLight:function(a){d.push(a)},pushShadow:function(a){e.push(a)}}}function QQ(a,b){let c=new WeakMap();return{get:function(d,e=0){let f;return!1===c.has(d)?(f=new PQ(a,b),c.set(d,[f])):e>=c.get(d).length?(f=new PQ(a,b),c.get(d).push(f)):f=c.get(d)[e],f},dispose:function(){c=new WeakMap()}}}class RQ extends wA{constructor(SQ){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(SQ)}copy(TQ){return super.copy(TQ),this.depthPacking=TQ.depthPacking,this.map=TQ.map,this.alphaMap=TQ.alphaMap,this.displacementMap=TQ.displacementMap,this.displacementScale=TQ.displacementScale,this.displacementBias=TQ.displacementBias,this.wireframe=TQ.wireframe,this.wireframeLinewidth=TQ.wireframeLinewidth,this}}RQ.prototype.isMeshDepthMaterial=!0;class UQ extends wA{constructor(VQ){super(),this.type="MeshDistanceMaterial",this.referencePosition=new nk(),this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(VQ)}copy(WQ){return super.copy(WQ),this.referencePosition.copy(WQ.referencePosition),this.nearDistance=WQ.nearDistance,this.farDistance=WQ.farDistance,this.map=WQ.map,this.alphaMap=WQ.alphaMap,this.displacementMap=WQ.displacementMap,this.displacementScale=WQ.displacementScale,this.displacementBias=WQ.displacementBias,this}}function XQ(a,b,c){let d=new CK();const e=new ba(),i=new ba(),j=new Af(),k=new RQ({depthPacking:3201}),m=new UQ(),n={},p=c.maxTextureSize,q={0:g,1:f,2:h},r=new XH({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ba()},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),s=r.clone();s.defines.HORIZONTAL_PASS=1;const t=new MC();t.setAttribute("position",new TA(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const u=new vG(t,r),v=this;function w(c,d){const e=b.update(u);r.defines.VSM_SAMPLES!==c.blurSamples&&(r.defines.VSM_SAMPLES=c.blurSamples,s.defines.VSM_SAMPLES=c.blurSamples,r.needsUpdate=!0,s.needsUpdate=!0),r.uniforms.shadow_pass.value=c.map.texture,r.uniforms.resolution.value=c.mapSize,r.uniforms.radius.value=c.radius,a.setRenderTarget(c.mapPass),a.clear(),a.renderBufferDirect(d,null,e,r,u,null),s.uniforms.shadow_pass.value=c.mapPass.texture,s.uniforms.resolution.value=c.mapSize,s.uniforms.radius.value=c.radius,a.setRenderTarget(c.map),a.clear(),a.renderBufferDirect(d,null,e,s,u,null)}function x(b,c,d,e,f,g,h){let i=null;const j=!0===e.isPointLight?b.customDistanceMaterial:b.customDepthMaterial;if(i=void 0!==j?j:!0===e.isPointLight?m:k,a.localClippingEnabled&& !0===d.clipShadows&&0!==d.clippingPlanes.length||d.displacementMap&&0!==d.displacementScale||d.alphaMap&&d.alphaTest>0){const l=i.uuid,o=d.uuid;let p=n[l];void 0===p&&(p={},n[l]=p);let r=p[o];void 0===r&&(r=i.clone(),p[o]=r),i=r}return i.visible=d.visible,i.wireframe=d.wireframe,3===h?i.side=null!==d.shadowSide?d.shadowSide:d.side:i.side=null!==d.shadowSide?d.shadowSide:q[d.side],i.alphaMap=d.alphaMap,i.alphaTest=d.alphaTest,i.clipShadows=d.clipShadows,i.clippingPlanes=d.clippingPlanes,i.clipIntersection=d.clipIntersection,i.displacementMap=d.displacementMap,i.displacementScale=d.displacementScale,i.displacementBias=d.displacementBias,i.wireframeLinewidth=d.wireframeLinewidth,i.linewidth=d.linewidth,!0===e.isPointLight&& !0===i.isMeshDistanceMaterial&&(i.referencePosition.setFromMatrixPosition(e.matrixWorld),i.nearDistance=f,i.farDistance=g),i}function y(c,e,f,g,h){if(!1===c.visible)return;const i=c.layers.test(e.layers);if(i&&(c.isMesh||c.isLine||c.isPoints)&&(c.castShadow||c.receiveShadow&&3===h)&&(!c.frustumCulled||d.intersectsObject(c))){c.modelViewMatrix.multiplyMatrices(f.matrixWorldInverse,c.matrixWorld);const j=b.update(c),k=c.material;if(Array.isArray(k)){const l=j.groups;for(let m=0,n=l.length;m<n;m++){const o=l[m],p=k[o.materialIndex];if(p&&p.visible){const q=x(c,j,p,g,f.near,f.far,h);a.renderBufferDirect(f,null,j,q,c,o)}}}else if(k.visible){const r=x(c,j,k,g,f.near,f.far,h);a.renderBufferDirect(f,null,j,r,c,null)}}const s=c.children;for(let t=0,u=s.length;t<u;t++)y(s[t],e,f,g,h)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(b,c,f){if(!1===v.enabled)return;if(!1===v.autoUpdate&& !1===v.needsUpdate)return;if(0===b.length)return;const g=a.getRenderTarget(),h=a.getActiveCubeFace(),k=a.getActiveMipmapLevel(),m=a.state;m.setBlending(0),m.buffers.color.setClear(1,1,1,1),m.buffers.depth.setTest(!0),m.setScissorTest(!1);for(let n=0,q=b.length;n<q;n++){const r=b[n],s=r.shadow;if(void 0===s){console.warn("THREE.WebGLShadowMap:",r,"has no shadow.");continue}if(!1===s.autoUpdate&& !1===s.needsUpdate)continue;e.copy(s.mapSize);const t=s.getFrameExtents();if(e.multiply(t),i.copy(s.mapSize),(e.x>p||e.y>p)&&(e.x>p&&(i.x=Math.floor(p/t.x),e.x=i.x*t.x,s.mapSize.x=i.x),e.y>p&&(i.y=Math.floor(p/t.y),e.y=i.y*t.y,s.mapSize.y=i.y)),null===s.map&&!s.isPointLightShadow&&3===this.type){const u={minFilter:o,magFilter:o,format:1023};s.map=new hh(e.x,e.y,u),s.map.texture.name=r.name+".shadowMap",s.mapPass=new hh(e.x,e.y,u),s.camera.updateProjectionMatrix()}if(null===s.map){const x={minFilter:l,magFilter:l,format:1023};s.map=new hh(e.x,e.y,x),s.map.texture.name=r.name+".shadowMap",s.camera.updateProjectionMatrix()}a.setRenderTarget(s.map),a.clear();const z=s.getViewportCount();for(let A=0;A<z;A++){const B=s.getViewport(A);j.set(i.x*B.x,i.y*B.y,i.x*B.z,i.y*B.w),m.viewport(j),s.updateMatrices(r,A),d=s.getFrustum(),y(c,f,s.camera,r,this.type)}s.isPointLightShadow||3!==this.type||w(s,f),s.needsUpdate=!1}v.needsUpdate=!1,a.setRenderTarget(g,h,k)}}function YQ(a,b,c){const d=c.isWebGL2,e=new function(){let b=!1;const c=new Af();let d=null;const e=new Af(0,0,0,0);return{setMask:function(c){d===c||b||(a.colorMask(c,c,c,c),d=c)},setLocked:function(a){b=a},setClear:function(b,d,f,g,h){!0===h&&(b*=g,d*=g,f*=g),c.set(b,d,f,g),!1===e.equals(c)&&(a.clearColor(b,d,f,g),e.copy(c))},reset:function(){b=!1,d=null,e.set(-1,0,0,0)}}}(),f=new function(){let b=!1,c=null,d=null,e=null;return{setTest:function(a){a?N(2929):O(2929)},setMask:function(d){c===d||b||(a.depthMask(d),c=d)},setFunc:function(b){if(d!==b){if(b)switch(b){case 0:a.depthFunc(512);break;case 1:a.depthFunc(519);break;case 2:a.depthFunc(513);break;case 3:a.depthFunc(515);break;case 4:a.depthFunc(514);break;case 5:a.depthFunc(518);break;case 6:a.depthFunc(516);break;case 7:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);d=b}},setLocked:function(a){b=a},setClear:function(b){e!==b&&(a.clearDepth(b),e=b)},reset:function(){b=!1,c=null,d=null,e=null}}}(),i=new function(){let b=!1,c=null,d=null,e=null,f=null,g=null,h=null,i=null,j=null;return{setTest:function(a){b||(a?N(2960):O(2960))},setMask:function(d){c===d||b||(a.stencilMask(d),c=d)},setFunc:function(b,c,g){(d!==b||e!==c||f!==g)&&(a.stencilFunc(b,c,g),d=b,e=c,f=g)},setOp:function(b,c,d){(g!==b||h!==c||i!==d)&&(a.stencilOp(b,c,d),g=b,h=c,i=d)},setLocked:function(a){b=a},setClear:function(b){j!==b&&(a.clearStencil(b),j=b)},reset:function(){b=!1,c=null,d=null,e=null,f=null,g=null,h=null,i=null,j=null}}}();let j={},k={},l=new WeakMap(),m=[],n=null,o=!1,p=null,q=null,r=null,s=null,t=null,u=null,v=null,w=!1,x=null,y=null,z=null,A=null,B=null;const C=a.getParameter(35661);let D=!1;const E=a.getParameter(7938);-1!==E.indexOf("WebGL")?D=parseFloat(/^WebGL (\d)/.exec(E)[1])>=1:-1!==E.indexOf("OpenGL ES")&&(D=parseFloat(/^OpenGL ES (\d)/.exec(E)[1])>=2);let F=null,G={};const H=a.getParameter(3088),I=a.getParameter(2978),J=new Af().fromArray(H),K=new Af().fromArray(I);function L(b,c,d){const e=new Uint8Array(4),f=a.createTexture();a.bindTexture(b,f),a.texParameteri(b,10241,9728),a.texParameteri(b,10240,9728);for(let g=0;g<d;g++)a.texImage2D(c+g,0,6408,1,1,0,6408,5121,e);return f}const M={};function N(b){!0!==j[b]&&(a.enable(b),j[b]=!0)}function O(b){!1!==j[b]&&(a.disable(b),j[b]=!1)}M[3553]=L(3553,3553,1),M[34067]=L(34067,34069,6),e.setClear(0,0,0,1),f.setClear(1),i.setClear(0),N(2929),f.setFunc(3),T(!1),U(1),N(2884),S(0);const P={[100]:32774,[101]:32778,[102]:32779};if(d)P[103]=32775,P[104]=32776;else{const Q=b.get("EXT_blend_minmax");null!==Q&&(P[103]=Q.MIN_EXT,P[104]=Q.MAX_EXT)}const R={[200]:0,[201]:1,[202]:768,[204]:770,[210]:776,[208]:774,[206]:772,[203]:769,[205]:771,[209]:775,[207]:773};function S(b,c,d,e,f,g,h,i){if(0===b){!0===o&&(O(3042),o=!1);return}if(!1===o&&(N(3042),o=!0),5!==b){if(b!==p||i!==w){if((100!==q||100!==t)&&(a.blendEquation(32774),q=100,t=100),i)switch(b){case 1:a.blendFuncSeparate(1,771,1,771);break;case 2:a.blendFunc(1,1);break;case 3:a.blendFuncSeparate(0,769,0,1);break;case 4:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",b);break}else switch(b){case 1:a.blendFuncSeparate(770,771,1,771);break;case 2:a.blendFunc(770,1);break;case 3:a.blendFuncSeparate(0,769,0,1);break;case 4:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",b);break}r=null,s=null,u=null,v=null,p=b,w=i}return}f=f||c,g=g||d,h=h||e,(c!==q||f!==t)&&(a.blendEquationSeparate(P[c],P[f]),q=c,t=f),(d!==r||e!==s||g!==u||h!==v)&&(a.blendFuncSeparate(R[d],R[e],R[g],R[h]),r=d,s=e,u=g,v=h),p=b,w=null}function T(b){x!==b&&(b?a.frontFace(2304):a.frontFace(2305),x=b)}function U(b){0!==b?(N(2884),b!==y&&(1===b?a.cullFace(1029):2===b?a.cullFace(1028):a.cullFace(1032))):O(2884),y=b}function V(b,c,d){b?(N(32823),(A!==c||B!==d)&&(a.polygonOffset(c,d),A=c,B=d)):O(32823)}function W(b){void 0===b&&(b=33984+C-1),F!==b&&(a.activeTexture(b),F=b)}return{buffers:{color:e,depth:f,stencil:i},enable:N,disable:O,bindFramebuffer:function(b,c){return k[b]!==c&&(a.bindFramebuffer(b,c),k[b]=c,d&&(36009===b&&(k[36160]=c),36160===b&&(k[36009]=c)),!0)},drawBuffers:function(d,e){let f=m,g=!1;if(d)if(void 0===(f=l.get(e))&&(f=[],l.set(e,f)),d.isWebGLMultipleRenderTargets){const h=d.texture;if(f.length!==h.length||36064!==f[0]){for(let i=0,j=h.length;i<j;i++)f[i]=36064+i;f.length=h.length,g=!0}}else 36064!==f[0]&&(f[0]=36064,g=!0);else 1029!==f[0]&&(f[0]=1029,g=!0);g&&(c.isWebGL2?a.drawBuffers(f):b.get("WEBGL_draw_buffers").drawBuffersWEBGL(f))},useProgram:function(b){return n!==b&&(a.useProgram(b),n=b,!0)},setBlending:S,setMaterial:function(a,b){a.side===h?O(2884):N(2884);let c=a.side===g;b&&(c=!c),T(c),1===a.blending&& !1===a.transparent?S(0):S(a.blending,a.blendEquation,a.blendSrc,a.blendDst,a.blendEquationAlpha,a.blendSrcAlpha,a.blendDstAlpha,a.premultipliedAlpha),f.setFunc(a.depthFunc),f.setTest(a.depthTest),f.setMask(a.depthWrite),e.setMask(a.colorWrite);const d=a.stencilWrite;i.setTest(d),d&&(i.setMask(a.stencilWriteMask),i.setFunc(a.stencilFunc,a.stencilRef,a.stencilFuncMask),i.setOp(a.stencilFail,a.stencilZFail,a.stencilZPass)),V(a.polygonOffset,a.polygonOffsetFactor,a.polygonOffsetUnits),!0===a.alphaToCoverage?N(32926):O(32926)},setFlipSided:T,setCullFace:U,setLineWidth:function(b){b!==z&&(D&&a.lineWidth(b),z=b)},setPolygonOffset:V,setScissorTest:function(a){a?N(3089):O(3089)},activeTexture:W,bindTexture:function(b,c){null===F&&W();let d=G[F];void 0===d&&(d={type:void 0,texture:void 0},G[F]=d),(d.type!==b||d.texture!==c)&&(a.bindTexture(b,c||M[b]),d.type=b,d.texture=c)},unbindTexture:function(){const b=G[F];void 0!==b&& void 0!==b.type&&(a.bindTexture(b.type,null),b.type=void 0,b.texture=void 0)},compressedTexImage2D:function(){try{a.compressedTexImage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texImage2D:function(){try{a.texImage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texImage3D:function(){try{a.texImage3D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texStorage2D:function(){try{a.texStorage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texStorage3D:function(){try{a.texStorage3D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texSubImage2D:function(){try{a.texSubImage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texSubImage3D:function(){try{a.texSubImage3D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},compressedTexSubImage2D:function(){try{a.compressedTexSubImage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},scissor:function(b){!1===J.equals(b)&&(a.scissor(b.x,b.y,b.z,b.w),J.copy(b))},viewport:function(b){!1===K.equals(b)&&(a.viewport(b.x,b.y,b.z,b.w),K.copy(b))},reset:function(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),!0===d&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),j={},F=null,G={},k={},l=new WeakMap(),m=[],n=null,o=!1,p=null,q=null,r=null,s=null,t=null,u=null,v=null,w=!1,x=null,y=null,z=null,A=null,B=null,J.set(0,0,a.canvas.width,a.canvas.height),K.set(0,0,a.canvas.width,a.canvas.height),e.reset(),f.reset(),i.reset()}}}function ZQ(a,b,c,d,e,f,g){const h=e.isWebGL2,r=e.maxTextures,s=e.maxCubemapSize,t=e.maxTextureSize,u=e.maxSamples,w=b.has("WEBGL_multisampled_render_to_texture"),x=w?b.get("WEBGL_multisampled_render_to_texture"):void 0,y=new WeakMap();let z,A=!1;try{A="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(B){}function C(a,b){return A?new OffscreenCanvas(a,b):wd("canvas")}function D(a,b,c,d){let e=1;if((a.width>d||a.height>d)&&(e=d/Math.max(a.width,a.height)),e<1|| !0===b){if(("undefined"==typeof HTMLImageElement||!(a instanceof HTMLImageElement))&&("undefined"==typeof HTMLCanvasElement||!(a instanceof HTMLCanvasElement))&&("undefined"==typeof ImageBitmap||!(a instanceof ImageBitmap)))return"data"in a&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+a.width+"x"+a.height+")."),a;{const f=b?_:Math.floor,g=f(e*a.width),h=f(e*a.height);void 0===z&&(z=C(g,h));const i=c?C(g,h):z;i.width=g,i.height=h;const j=i.getContext("2d");return j.drawImage(a,0,0,g,h),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+a.width+"x"+a.height+") to ("+g+"x"+h+")."),i}}return a}function E(a){return Z(a.width)&&Z(a.height)}function F(a,b){return a.generateMipmaps&&b&&a.minFilter!==l&&a.minFilter!==o}function G(b){a.generateMipmap(b)}function H(c,d,e,f,g=!1){if(!1===h)return d;if(null!==c){if(void 0!==a[c])return a[c];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+c+"'")}let i=d;return 6403===d&&(5126===e&&(i=33326),5131===e&&(i=33325),5121===e&&(i=33321)),33319===d&&(5126===e&&(i=33328),5131===e&&(i=33327),5121===e&&(i=33323)),6408===d&&(5126===e&&(i=34836),5131===e&&(i=34842),5121===e&&(i=f===v&& !1===g?35907:32856),32819===e&&(i=32854),32820===e&&(i=32855)),(33325===i||33326===i||33327===i||33328===i||34842===i||34836===i)&&b.get("EXT_color_buffer_float"),i}function I(a,b,c){return!0===F(a,c)||a.isFramebufferTexture&&a.minFilter!==l&&a.minFilter!==o?Math.log2(Math.max(b.width,b.height))+1:void 0!==a.mipmaps&&a.mipmaps.length>0?a.mipmaps.length:a.isCompressedTexture&&Array.isArray(a.image)?b.mipmaps.length:1}function J(a){return a===l||a===m||a===n?9728:9729}function K(a){const b=a.target;b.removeEventListener("dispose",K),M(b),b.isVideoTexture&&y.delete(b),g.memory.textures--}function L(a){const b=a.target;b.removeEventListener("dispose",L),N(b)}function M(b){const c=d.get(b);void 0!==c.__webglInit&&(a.deleteTexture(c.__webglTexture),d.remove(b))}function N(b){const c=b.texture,e=d.get(b),f=d.get(c);if(b){if(void 0!==f.__webglTexture&&(a.deleteTexture(f.__webglTexture),g.memory.textures--),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let h=0;h<6;h++)a.deleteFramebuffer(e.__webglFramebuffer[h]),e.__webglDepthbuffer&&a.deleteRenderbuffer(e.__webglDepthbuffer[h]);else a.deleteFramebuffer(e.__webglFramebuffer),e.__webglDepthbuffer&&a.deleteRenderbuffer(e.__webglDepthbuffer),e.__webglMultisampledFramebuffer&&a.deleteFramebuffer(e.__webglMultisampledFramebuffer),e.__webglColorRenderbuffer&&a.deleteRenderbuffer(e.__webglColorRenderbuffer),e.__webglDepthRenderbuffer&&a.deleteRenderbuffer(e.__webglDepthRenderbuffer);if(b.isWebGLMultipleRenderTargets)for(let i=0,j=c.length;i<j;i++){const k=d.get(c[i]);k.__webglTexture&&(a.deleteTexture(k.__webglTexture),g.memory.textures--),d.remove(c[i])}d.remove(c),d.remove(b)}}let O=0;function P(a,b){const e=d.get(a);if(a.isVideoTexture&&ba(a),a.version>0&&e.__version!==a.version){const f=a.image;if(void 0===f)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(!1===f.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{V(e,a,b);return}}c.activeTexture(33984+b),c.bindTexture(3553,e.__webglTexture)}function Q(a,b){const e=d.get(a);if(a.version>0&&e.__version!==a.version){W(e,a,b);return}c.activeTexture(33984+b),c.bindTexture(34067,e.__webglTexture)}const R={[i]:10497,[j]:33071,[k]:33648},S={[l]:9728,[m]:9984,[n]:9986,[o]:9729,[p]:9985,[q]:9987};function T(c,f,g){if(g?(a.texParameteri(c,10242,R[f.wrapS]),a.texParameteri(c,10243,R[f.wrapT]),(32879===c||35866===c)&&a.texParameteri(c,32882,R[f.wrapR]),a.texParameteri(c,10240,S[f.magFilter]),a.texParameteri(c,10241,S[f.minFilter])):(a.texParameteri(c,10242,33071),a.texParameteri(c,10243,33071),(32879===c||35866===c)&&a.texParameteri(c,32882,33071),(f.wrapS!==j||f.wrapT!==j)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(c,10240,J(f.magFilter)),a.texParameteri(c,10241,J(f.minFilter)),f.minFilter!==l&&f.minFilter!==o&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===b.has("EXT_texture_filter_anisotropic")){const i=b.get("EXT_texture_filter_anisotropic");(1015!==f.type|| !1!==b.has("OES_texture_float_linear"))&&(!1!==h||1016!==f.type|| !1!==b.has("OES_texture_half_float_linear"))&&(f.anisotropy>1||d.get(f).__currentAnisotropy)&&(a.texParameterf(c,i.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(f.anisotropy,e.getMaxAnisotropy())),d.get(f).__currentAnisotropy=f.anisotropy)}}function U(b,c){void 0===b.__webglInit&&(b.__webglInit=!0,c.addEventListener("dispose",K),b.__webglTexture=a.createTexture(),g.memory.textures++)}function V(b,d,e){var g;let i=3553;d.isDataTexture2DArray&&(i=35866),d.isDataTexture3D&&(i=32879),U(b,d),c.activeTexture(33984+e),c.bindTexture(i,b.__webglTexture),a.pixelStorei(37440,d.flipY),a.pixelStorei(37441,d.premultiplyAlpha),a.pixelStorei(3317,d.unpackAlignment),a.pixelStorei(37443,0);const k=(g=d,!h&&(g.wrapS!==j||g.wrapT!==j||g.minFilter!==l&&g.minFilter!==o)&& !1===E(d.image));let m=D(d.image,k,!1,t);m=ca(d,m);const n=E(m)||h,p=f.convert(d.format,d.encoding);let q=f.convert(d.type),r=H(d.internalFormat,p,q,d.encoding,d.isVideoTexture);T(i,d,n);let s;const u=d.mipmaps,v=h&& !0!==d.isVideoTexture,w=void 0===b.__version,x=I(d,m,n);if(d.isDepthTexture)r=6402,h?r=1015===d.type?36012:1014===d.type?33190:1020===d.type?35056:33189:1015===d.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===d.format&&6402===r&&1012!==d.type&&1014!==d.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),d.type=1012,q=f.convert(d.type)),1027===d.format&&6402===r&&(r=34041,1020!==d.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),d.type=1020,q=f.convert(d.type))),v&&w?c.texStorage2D(3553,1,r,m.width,m.height):c.texImage2D(3553,0,r,m.width,m.height,0,p,q,null);else if(d.isDataTexture)if(u.length>0&&n){v&&w&&c.texStorage2D(3553,x,r,u[0].width,u[0].height);for(let y=0,z=u.length;y<z;y++)s=u[y],v?c.texSubImage2D(3553,0,0,0,s.width,s.height,p,q,s.data):c.texImage2D(3553,y,r,s.width,s.height,0,p,q,s.data);d.generateMipmaps=!1}else v?(w&&c.texStorage2D(3553,x,r,m.width,m.height),c.texSubImage2D(3553,0,0,0,m.width,m.height,p,q,m.data)):c.texImage2D(3553,0,r,m.width,m.height,0,p,q,m.data);else if(d.isCompressedTexture){v&&w&&c.texStorage2D(3553,x,r,u[0].width,u[0].height);for(let A=0,B=u.length;A<B;A++)s=u[A],1023!==d.format?null!==p?v?c.compressedTexSubImage2D(3553,A,0,0,s.width,s.height,p,s.data):c.compressedTexImage2D(3553,A,r,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):v?c.texSubImage2D(3553,A,0,0,s.width,s.height,p,q,s.data):c.texImage2D(3553,A,r,s.width,s.height,0,p,q,s.data)}else if(d.isDataTexture2DArray)v?(w&&c.texStorage3D(35866,x,r,m.width,m.height,m.depth),c.texSubImage3D(35866,0,0,0,0,m.width,m.height,m.depth,p,q,m.data)):c.texImage3D(35866,0,r,m.width,m.height,m.depth,0,p,q,m.data);else if(d.isDataTexture3D)v?(w&&c.texStorage3D(32879,x,r,m.width,m.height,m.depth),c.texSubImage3D(32879,0,0,0,0,m.width,m.height,m.depth,p,q,m.data)):c.texImage3D(32879,0,r,m.width,m.height,m.depth,0,p,q,m.data);else if(d.isFramebufferTexture)v&&w?c.texStorage2D(3553,x,r,m.width,m.height):c.texImage2D(3553,0,r,m.width,m.height,0,p,q,null);else if(u.length>0&&n){v&&w&&c.texStorage2D(3553,x,r,u[0].width,u[0].height);for(let C=0,J=u.length;C<J;C++)s=u[C],v?c.texSubImage2D(3553,C,0,0,p,q,s):c.texImage2D(3553,C,r,p,q,s);d.generateMipmaps=!1}else v?(w&&c.texStorage2D(3553,x,r,m.width,m.height),c.texSubImage2D(3553,0,0,0,p,q,m)):c.texImage2D(3553,0,r,p,q,m);F(d,n)&&G(i),b.__version=d.version,d.onUpdate&&d.onUpdate(d)}function W(b,d,e){if(6!==d.image.length)return;U(b,d),c.activeTexture(33984+e),c.bindTexture(34067,b.__webglTexture),a.pixelStorei(37440,d.flipY),a.pixelStorei(37441,d.premultiplyAlpha),a.pixelStorei(3317,d.unpackAlignment),a.pixelStorei(37443,0);const g=d&&(d.isCompressedTexture||d.image[0].isCompressedTexture),i=d.image[0]&&d.image[0].isDataTexture,j=[];for(let k=0;k<6;k++)g||i?j[k]=i?d.image[k].image:d.image[k]:j[k]=D(d.image[k],!1,!0,s),j[k]=ca(d,j[k]);const l=j[0],m=E(l)||h,n=f.convert(d.format,d.encoding),o=f.convert(d.type),p=H(d.internalFormat,n,o,d.encoding),q=h&& !0!==d.isVideoTexture,r=void 0===b.__version;let t=I(d,l,m);T(34067,d,m);let u;if(g){q&&r&&c.texStorage2D(34067,t,p,l.width,l.height);for(let v=0;v<6;v++){u=j[v].mipmaps;for(let w=0;w<u.length;w++){const x=u[w];1023!==d.format?null!==n?q?c.compressedTexSubImage2D(34069+v,w,0,0,x.width,x.height,n,x.data):c.compressedTexImage2D(34069+v,w,p,x.width,x.height,0,x.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):q?c.texSubImage2D(34069+v,w,0,0,x.width,x.height,n,o,x.data):c.texImage2D(34069+v,w,p,x.width,x.height,0,n,o,x.data)}}}else{u=d.mipmaps,q&&r&&(u.length>0&&t++,c.texStorage2D(34067,t,p,j[0].width,j[0].height));for(let y=0;y<6;y++)if(i){q?c.texSubImage2D(34069+y,0,0,0,j[y].width,j[y].height,n,o,j[y].data):c.texImage2D(34069+y,0,p,j[y].width,j[y].height,0,n,o,j[y].data);for(let z=0;z<u.length;z++){const A=u[z],B=A.image[y].image;q?c.texSubImage2D(34069+y,z+1,0,0,B.width,B.height,n,o,B.data):c.texImage2D(34069+y,z+1,p,B.width,B.height,0,n,o,B.data)}}else{q?c.texSubImage2D(34069+y,0,0,0,n,o,j[y]):c.texImage2D(34069+y,0,p,n,o,j[y]);for(let C=0;C<u.length;C++){const J=u[C];q?c.texSubImage2D(34069+y,C+1,0,0,n,o,J.image[y]):c.texImage2D(34069+y,C+1,p,n,o,J.image[y])}}}F(d,m)&&G(34067),b.__version=d.version,d.onUpdate&&d.onUpdate(d)}function X(b,e,g,h,i){const j=f.convert(g.format,g.encoding),k=f.convert(g.type),l=H(g.internalFormat,j,k,g.encoding),m=d.get(e);m.__hasExternalTextures||(32879===i||35866===i?c.texImage3D(i,0,l,e.width,e.height,e.depth,0,j,k,null):c.texImage2D(i,0,l,e.width,e.height,0,j,k,null)),c.bindFramebuffer(36160,b),e.useRenderToTexture?x.framebufferTexture2DMultisampleEXT(36160,h,i,d.get(g).__webglTexture,0,aa(e)):a.framebufferTexture2D(36160,h,i,d.get(g).__webglTexture,0),c.bindFramebuffer(36160,null)}function Y(b,c,d){if(a.bindRenderbuffer(36161,b),c.depthBuffer&&!c.stencilBuffer){let e=33189;if(d||c.useRenderToTexture){const g=c.depthTexture;g&&g.isDepthTexture&&(1015===g.type?e=36012:1014===g.type&&(e=33190));const h=aa(c);c.useRenderToTexture?x.renderbufferStorageMultisampleEXT(36161,h,e,c.width,c.height):a.renderbufferStorageMultisample(36161,h,e,c.width,c.height)}else a.renderbufferStorage(36161,e,c.width,c.height);a.framebufferRenderbuffer(36160,36096,36161,b)}else if(c.depthBuffer&&c.stencilBuffer){const i=aa(c);d&&c.useRenderbuffer?a.renderbufferStorageMultisample(36161,i,35056,c.width,c.height):c.useRenderToTexture?x.renderbufferStorageMultisampleEXT(36161,i,35056,c.width,c.height):a.renderbufferStorage(36161,34041,c.width,c.height),a.framebufferRenderbuffer(36160,33306,36161,b)}else{const j=!0===c.isWebGLMultipleRenderTargets?c.texture[0]:c.texture,k=f.convert(j.format,j.encoding),l=f.convert(j.type),m=H(j.internalFormat,k,l,j.encoding),n=aa(c);d&&c.useRenderbuffer?a.renderbufferStorageMultisample(36161,n,m,c.width,c.height):c.useRenderToTexture?x.renderbufferStorageMultisampleEXT(36161,n,m,c.width,c.height):a.renderbufferStorage(36161,m,c.width,c.height)}a.bindRenderbuffer(36161,null)}function $(b){const e=d.get(b),f=!0===b.isWebGLCubeRenderTarget;if(b.depthTexture&&!e.__autoAllocateDepthBuffer){if(f)throw new Error("target.depthTexture not supported in Cube render targets");!function(b,e){const f=e&&e.isWebGLCubeRenderTarget;if(f)throw new Error("Depth Texture with cube render targets is not supported");if(c.bindFramebuffer(36160,b),!(e.depthTexture&&e.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");d.get(e.depthTexture).__webglTexture&&e.depthTexture.image.width===e.width&&e.depthTexture.image.height===e.height||(e.depthTexture.image.width=e.width,e.depthTexture.image.height=e.height,e.depthTexture.needsUpdate=!0),P(e.depthTexture,0);const g=d.get(e.depthTexture).__webglTexture,h=aa(e);if(1026===e.depthTexture.format)e.useRenderToTexture?x.framebufferTexture2DMultisampleEXT(36160,36096,3553,g,0,h):a.framebufferTexture2D(36160,36096,3553,g,0);else if(1027===e.depthTexture.format)e.useRenderToTexture?x.framebufferTexture2DMultisampleEXT(36160,33306,3553,g,0,h):a.framebufferTexture2D(36160,33306,3553,g,0);else throw new Error("Unknown depthTexture format")}(e.__webglFramebuffer,b)}else if(f){e.__webglDepthbuffer=[];for(let g=0;g<6;g++)c.bindFramebuffer(36160,e.__webglFramebuffer[g]),e.__webglDepthbuffer[g]=a.createRenderbuffer(),Y(e.__webglDepthbuffer[g],b,!1)}else c.bindFramebuffer(36160,e.__webglFramebuffer),e.__webglDepthbuffer=a.createRenderbuffer(),Y(e.__webglDepthbuffer,b,!1);c.bindFramebuffer(36160,null)}function aa(a){return h&&(a.useRenderbuffer||a.useRenderToTexture)?Math.min(u,a.samples):0}function ba(a){const b=g.render.frame;y.get(a)!==b&&(y.set(a,b),a.update())}function ca(a,c){const d=a.encoding,e=a.format,f=a.type;return!0===a.isCompressedTexture|| !0===a.isVideoTexture||1035===a.format||3e3!==d&&(d===v?!1===h?!0===b.has("EXT_sRGB")&&1023===e?(a.format=1035,a.minFilter=o,a.generateMipmaps=!1):c=Se.sRGBToLinear(c):(1023!==e||1009!==f)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",d)),c}let da=!1,ea=!1;this.allocateTextureUnit=function(){const a=O;return a>=r&&console.warn("THREE.WebGLTextures: Trying to use "+a+" texture units while this GPU supports only "+r),O+=1,a},this.resetTextureUnits=function(){O=0},this.setTexture2D=P,this.setTexture2DArray=function(a,b){const e=d.get(a);if(a.version>0&&e.__version!==a.version){V(e,a,b);return}c.activeTexture(33984+b),c.bindTexture(35866,e.__webglTexture)},this.setTexture3D=function(a,b){const e=d.get(a);if(a.version>0&&e.__version!==a.version){V(e,a,b);return}c.activeTexture(33984+b),c.bindTexture(32879,e.__webglTexture)},this.setTextureCube=Q,this.rebindTextures=function(a,b,c){const e=d.get(a);void 0!==b&&X(e.__webglFramebuffer,a,a.texture,36064,3553),void 0!==c&&$(a)},this.setupRenderTarget=function(b){const i=b.texture,j=d.get(b),k=d.get(i);b.addEventListener("dispose",L),!0!==b.isWebGLMultipleRenderTargets&&(void 0===k.__webglTexture&&(k.__webglTexture=a.createTexture()),k.__version=i.version,g.memory.textures++);const l=!0===b.isWebGLCubeRenderTarget,m=!0===b.isWebGLMultipleRenderTargets,n=i.isDataTexture3D||i.isDataTexture2DArray,o=E(b)||h;if(l){j.__webglFramebuffer=[];for(let p=0;p<6;p++)j.__webglFramebuffer[p]=a.createFramebuffer()}else if(j.__webglFramebuffer=a.createFramebuffer(),m)if(e.drawBuffers){const q=b.texture;for(let r=0,s=q.length;r<s;r++){const t=d.get(q[r]);void 0===t.__webglTexture&&(t.__webglTexture=a.createTexture(),g.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(b.useRenderbuffer)if(h){j.__webglMultisampledFramebuffer=a.createFramebuffer(),j.__webglColorRenderbuffer=a.createRenderbuffer(),a.bindRenderbuffer(36161,j.__webglColorRenderbuffer);const u=f.convert(i.format,i.encoding),v=f.convert(i.type),w=H(i.internalFormat,u,v,i.encoding),x=aa(b);a.renderbufferStorageMultisample(36161,x,w,b.width,b.height),c.bindFramebuffer(36160,j.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064,36161,j.__webglColorRenderbuffer),a.bindRenderbuffer(36161,null),b.depthBuffer&&(j.__webglDepthRenderbuffer=a.createRenderbuffer(),Y(j.__webglDepthRenderbuffer,b,!0)),c.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(l){c.bindTexture(34067,k.__webglTexture),T(34067,i,o);for(let y=0;y<6;y++)X(j.__webglFramebuffer[y],b,i,36064,34069+y);F(i,o)&&G(34067),c.unbindTexture()}else if(m){const z=b.texture;for(let A=0,B=z.length;A<B;A++){const C=z[A],D=d.get(C);c.bindTexture(3553,D.__webglTexture),T(3553,C,o),X(j.__webglFramebuffer,b,C,36064+A,3553),F(C,o)&&G(3553)}c.unbindTexture()}else{let I=3553;if(n)if(h){const J=i.isDataTexture3D;I=J?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");c.bindTexture(I,k.__webglTexture),T(I,i,o),X(j.__webglFramebuffer,b,i,36064,I),F(i,o)&&G(I),c.unbindTexture()}b.depthBuffer&&$(b)},this.updateRenderTargetMipmap=function(a){const b=E(a)||h,e=!0===a.isWebGLMultipleRenderTargets?a.texture:[a.texture];for(let f=0,g=e.length;f<g;f++){const i=e[f];if(F(i,b)){const j=a.isWebGLCubeRenderTarget?34067:3553,k=d.get(i).__webglTexture;c.bindTexture(j,k),G(j),c.unbindTexture()}}},this.updateMultisampleRenderTarget=function(b){if(b.useRenderbuffer)if(h){const e=b.width,f=b.height;let g=16384;const i=[36064],j=b.stencilBuffer?33306:36096;b.depthBuffer&&i.push(j),!b.ignoreDepthForMultisampleCopy&&(b.depthBuffer&&(g|=256),b.stencilBuffer&&(g|=1024));const k=d.get(b);c.bindFramebuffer(36008,k.__webglMultisampledFramebuffer),c.bindFramebuffer(36009,k.__webglFramebuffer),b.ignoreDepthForMultisampleCopy&&(a.invalidateFramebuffer(36008,[j]),a.invalidateFramebuffer(36009,[j])),a.blitFramebuffer(0,0,e,f,0,0,e,f,g,9728),a.invalidateFramebuffer(36008,i),c.bindFramebuffer(36008,null),c.bindFramebuffer(36009,k.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.setupDepthRenderbuffer=$,this.setupFrameBufferTexture=X,this.safeSetTexture2D=function(a,b){a&&a.isWebGLRenderTarget&&(!1===da&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),da=!0),a=a.texture),P(a,b)},this.safeSetTextureCube=function(a,b){a&&a.isWebGLCubeRenderTarget&&(!1===ea&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),ea=!0),a=a.texture),Q(a,b)}}function $Q(a,b,c){const d=c.isWebGL2;return{convert:function(a,c=null){let e;if(1009===a)return 5121;if(1017===a)return 32819;if(1018===a)return 32820;if(1010===a)return 5120;if(1011===a)return 5122;if(1012===a)return 5123;if(1013===a)return 5124;if(1014===a)return 5125;if(1015===a)return 5126;if(1016===a)return d?5131:null!==(e=b.get("OES_texture_half_float"))?e.HALF_FLOAT_OES:null;if(1021===a)return 6406;if(1023===a)return 6408;if(1024===a)return 6409;if(1025===a)return 6410;if(1026===a)return 6402;if(1027===a)return 34041;if(1028===a)return 6403;if(1022===a)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(1035===a)return null!==(e=b.get("EXT_sRGB"))?e.SRGB_ALPHA_EXT:null;if(1029===a)return 36244;if(1030===a)return 33319;if(1031===a)return 33320;if(1033===a)return 36249;if(33776===a||33777===a||33778===a||33779===a)if(c===v){if(null===(e=b.get("WEBGL_compressed_texture_s3tc_srgb")))return null;if(33776===a)return e.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(33777===a)return e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(33778===a)return e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(33779===a)return e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(null===(e=b.get("WEBGL_compressed_texture_s3tc")))return null;if(33776===a)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===a)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===a)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===a)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===a||35841===a||35842===a||35843===a){if(null===(e=b.get("WEBGL_compressed_texture_pvrtc")))return null;if(35840===a)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===a)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===a)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===a)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===a)return null!==(e=b.get("WEBGL_compressed_texture_etc1"))?e.COMPRESSED_RGB_ETC1_WEBGL:null;if(37492===a||37496===a){if(null===(e=b.get("WEBGL_compressed_texture_etc")))return null;if(37492===a)return c===v?e.COMPRESSED_SRGB8_ETC2:e.COMPRESSED_RGB8_ETC2;if(37496===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:e.COMPRESSED_RGBA8_ETC2_EAC}if(37808===a||37809===a||37810===a||37811===a||37812===a||37813===a||37814===a||37815===a||37816===a||37817===a||37818===a||37819===a||37820===a||37821===a){if(null===(e=b.get("WEBGL_compressed_texture_astc")))return null;if(37808===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:e.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:e.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:e.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:e.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:e.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:e.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:e.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:e.COMPRESSED_RGBA_ASTC_8x8_KHR;if(37816===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:e.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:e.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:e.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:e.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:e.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===a)return c===v?e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:e.COMPRESSED_RGBA_ASTC_12x12_KHR}if(36492===a){if(null===(e=b.get("EXT_texture_compression_bptc")))return null;if(36492===a)return c===v?e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:e.COMPRESSED_RGBA_BPTC_UNORM_EXT}if(1020===a)return d?34042:null!==(e=b.get("WEBGL_depth_texture"))?e.UNSIGNED_INT_24_8_WEBGL:null}}}UQ.prototype.isMeshDistanceMaterial=!0;class _Q extends nI{constructor(aR=[]){super(),this.cameras=aR}}_Q.prototype.isArrayCamera=!0;class bR extends Sw{constructor(){super(),this.type="Group"}}bR.prototype.isGroup=!0;const cR={type:"move"};class dR{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new bR(),this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new bR(),this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new nk(),this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new nk()),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new bR(),this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new nk(),this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new nk()),this._grip}dispatchEvent(eR){return null!==this._targetRay&&this._targetRay.dispatchEvent(eR),null!==this._grip&&this._grip.dispatchEvent(eR),null!==this._hand&&this._hand.dispatchEvent(eR),this}disconnect(fR){return this.dispatchEvent({type:"disconnected",data:fR}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(gR,hR,iR){let jR=null,kR=null,lR=null;const mR=this._targetRay,nR=this._grip,oR=this._hand;if(gR&&"visible-blurred"!==hR.session.visibilityState)if(null!==mR&&null!==(jR=hR.getPose(gR.targetRaySpace,iR))&&(mR.matrix.fromArray(jR.transform.matrix),mR.matrix.decompose(mR.position,mR.rotation,mR.scale),jR.linearVelocity?(mR.hasLinearVelocity=!0,mR.linearVelocity.copy(jR.linearVelocity)):mR.hasLinearVelocity=!1,jR.angularVelocity?(mR.hasAngularVelocity=!0,mR.angularVelocity.copy(jR.angularVelocity)):mR.hasAngularVelocity=!1,this.dispatchEvent(cR)),oR&&gR.hand){for(const pR of(lR=!0,gR.hand.values())){const qR=hR.getJointPose(pR,iR);if(void 0===oR.joints[pR.jointName]){const rR=new bR();rR.matrixAutoUpdate=!1,rR.visible=!1,oR.joints[pR.jointName]=rR,oR.add(rR)}const sR=oR.joints[pR.jointName];null!==qR&&(sR.matrix.fromArray(qR.transform.matrix),sR.matrix.decompose(sR.position,sR.rotation,sR.scale),sR.jointRadius=qR.radius),sR.visible=null!==qR}const tR=oR.joints["index-finger-tip"],uR=oR.joints["thumb-tip"],vR=tR.position.distanceTo(uR.position),wR=.02,xR=.005;oR.inputState.pinching&&vR>wR+xR?(oR.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:gR.handedness,target:this})):!oR.inputState.pinching&&vR<=wR-xR&&(oR.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:gR.handedness,target:this}))}else null!==nR&&gR.gripSpace&&null!==(kR=hR.getPose(gR.gripSpace,iR))&&(nR.matrix.fromArray(kR.transform.matrix),nR.matrix.decompose(nR.position,nR.rotation,nR.scale),kR.linearVelocity?(nR.hasLinearVelocity=!0,nR.linearVelocity.copy(kR.linearVelocity)):nR.hasLinearVelocity=!1,kR.angularVelocity?(nR.hasAngularVelocity=!0,nR.angularVelocity.copy(kR.angularVelocity)):nR.hasAngularVelocity=!1);return null!==mR&&(mR.visible=null!==jR),null!==nR&&(nR.visible=null!==kR),null!==oR&&(oR.visible=null!==lR),this}}class yR extends df{constructor(zR,AR,BR,CR,DR,ER,FR,GR,HR,IR){if(1026!==(IR=void 0!==IR?IR:1026)&&1027!==IR)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===BR&&1026===IR&&(BR=1012),void 0===BR&&1027===IR&&(BR=1020),super(null,CR,DR,ER,FR,GR,IR,BR,HR),this.image={width:zR,height:AR},this.magFilter=void 0!==FR?FR:l,this.minFilter=void 0!==GR?GR:l,this.flipY=!1,this.generateMipmaps=!1}}yR.prototype.isDepthTexture=!0;class JR extends y{constructor(KR,LR){super();const MR=this;let NR=null,OR=1,PR=null,QR="local-floor";const RR=KR.extensions.has("WEBGL_multisampled_render_to_texture");let SR=null,TR=null,UR=null,VR=null,WR=!1,XR=null;const YR=LR.getContextAttributes();let ZR=null,$R=null;const _R=[],aS=new Map(),bS=new nI();bS.layers.enable(1),bS.viewport=new Af();const cS=new nI();cS.layers.enable(2),cS.viewport=new Af();const dS=[bS,cS],eS=new _Q();eS.layers.enable(1),eS.layers.enable(2);let fS=null,gS=null;function hS(a){const b=aS.get(a.inputSource);b&&b.dispatchEvent({type:a.type,data:a.inputSource})}function iS(){aS.forEach(function(a,b){a.disconnect(b)}),aS.clear(),fS=null,gS=null,KR.setRenderTarget(ZR),VR=null,UR=null,TR=null,NR=null,$R=null,oS.stop(),MR.isPresenting=!1,MR.dispatchEvent({type:"sessionend"})}function jS(a){const b=NR.inputSources;for(let c=0;c<_R.length;c++)aS.set(b[c],_R[c]);for(let d=0;d<a.removed.length;d++){const e=a.removed[d],f=aS.get(e);f&&(f.dispatchEvent({type:"disconnected",data:e}),aS.delete(e))}for(let g=0;g<a.added.length;g++){const h=a.added[g],i=aS.get(h);i&&i.dispatchEvent({type:"connected",data:h})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(a){let b=_R[a];return void 0===b&&(b=new dR(),_R[a]=b),b.getTargetRaySpace()},this.getControllerGrip=function(a){let b=_R[a];return void 0===b&&(b=new dR(),_R[a]=b),b.getGripSpace()},this.getHand=function(a){let b=_R[a];return void 0===b&&(b=new dR(),_R[a]=b),b.getHandSpace()},this.setFramebufferScaleFactor=function(a){OR=a,!0===MR.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(a){QR=a,!0===MR.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return PR},this.getBaseLayer=function(){return null!==UR?UR:VR},this.getBinding=function(){return TR},this.getFrame=function(){return XR},this.getSession=function(){return NR},this.setSession=async function(a){if(null!==(NR=a)){if(ZR=KR.getRenderTarget(),NR.addEventListener("select",hS),NR.addEventListener("selectstart",hS),NR.addEventListener("selectend",hS),NR.addEventListener("squeeze",hS),NR.addEventListener("squeezestart",hS),NR.addEventListener("squeezeend",hS),NR.addEventListener("end",iS),NR.addEventListener("inputsourceschange",jS),!0!==YR.xrCompatible&&await LR.makeXRCompatible(),void 0===NR.renderState.layers|| !1===KR.capabilities.isWebGL2){const b={antialias:void 0!==NR.renderState.layers||YR.antialias,alpha:YR.alpha,depth:YR.depth,stencil:YR.stencil,framebufferScaleFactor:OR};VR=new XRWebGLLayer(NR,LR,b),NR.updateRenderState({baseLayer:VR}),$R=new hh(VR.framebufferWidth,VR.framebufferHeight,{format:1023,type:1009,encoding:KR.outputEncoding})}else{WR=YR.antialias;let c=null,d=null,e=null;YR.depth&&(e=YR.stencil?35056:33190,c=YR.stencil?1027:1026,d=YR.stencil?1020:1012);const f={colorFormat:KR.outputEncoding===v?35907:32856,depthFormat:e,scaleFactor:OR};UR=(TR=new XRWebGLBinding(NR,LR)).createProjectionLayer(f),NR.updateRenderState({layers:[UR]}),$R=WR?new Dh(UR.textureWidth,UR.textureHeight,{format:1023,type:1009,depthTexture:new yR(UR.textureWidth,UR.textureHeight,d,void 0,void 0,void 0,void 0,void 0,void 0,c),stencilBuffer:YR.stencil,ignoreDepth:UR.ignoreDepthValues,useRenderToTexture:RR,encoding:KR.outputEncoding}):new hh(UR.textureWidth,UR.textureHeight,{format:1023,type:1009,depthTexture:new yR(UR.textureWidth,UR.textureHeight,d,void 0,void 0,void 0,void 0,void 0,void 0,c),stencilBuffer:YR.stencil,ignoreDepth:UR.ignoreDepthValues,encoding:KR.outputEncoding})}$R.isXRRenderTarget=!0,this.setFoveation(1),PR=await NR.requestReferenceSpace(QR),oS.setContext(NR),oS.start(),MR.isPresenting=!0,MR.dispatchEvent({type:"sessionstart"})}};const kS=new nk(),lS=new nk();function mS(a,b){null===b?a.matrixWorld.copy(a.matrix):a.matrixWorld.multiplyMatrices(b.matrixWorld,a.matrix),a.matrixWorldInverse.copy(a.matrixWorld).invert()}this.updateCamera=function(a){if(null===NR)return;eS.near=cS.near=bS.near=a.near,eS.far=cS.far=bS.far=a.far,(fS!==eS.near||gS!==eS.far)&&(NR.updateRenderState({depthNear:eS.near,depthFar:eS.far}),fS=eS.near,gS=eS.far);const b=a.parent,c=eS.cameras;mS(eS,b);for(let d=0;d<c.length;d++)mS(c[d],b);eS.matrixWorld.decompose(eS.position,eS.quaternion,eS.scale),a.position.copy(eS.position),a.quaternion.copy(eS.quaternion),a.scale.copy(eS.scale),a.matrix.copy(eS.matrix),a.matrixWorld.copy(eS.matrixWorld);const e=a.children;for(let f=0,g=e.length;f<g;f++)e[f].updateMatrixWorld(!0);2===c.length?(function(a,b,c){kS.setFromMatrixPosition(b.matrixWorld),lS.setFromMatrixPosition(c.matrixWorld);const d=kS.distanceTo(lS),e=b.projectionMatrix.elements,f=c.projectionMatrix.elements,g=e[14]/(e[10]-1),h=e[14]/(e[10]+1),i=(e[9]+1)/e[5],j=(e[9]-1)/e[5],k=(e[8]-1)/e[0],l=(f[8]+1)/f[0],m=d/(-k+l),n=-(m*k);b.matrixWorld.decompose(a.position,a.quaternion,a.scale),a.translateX(n),a.translateZ(m),a.matrixWorld.compose(a.position,a.quaternion,a.scale),a.matrixWorldInverse.copy(a.matrixWorld).invert();const o=g+m,p=h+m;a.projectionMatrix.makePerspective(g*k-n,g*l+(d-n),i*h/p*o,j*h/p*o,o,p)})(eS,bS,cS):eS.projectionMatrix.copy(bS.projectionMatrix)},this.getCamera=function(){return eS},this.getFoveation=function(){return null!==UR?UR.fixedFoveation:null!==VR?VR.fixedFoveation:void 0},this.setFoveation=function(a){null!==UR&&(UR.fixedFoveation=a),null!==VR&& void 0!==VR.fixedFoveation&&(VR.fixedFoveation=a)};let nS=null;const oS=new AL();oS.setAnimationLoop(function(a,b){if(SR=b.getViewerPose(PR),XR=b,null!==SR){const c=SR.views;null!==VR&&(KR.setRenderTargetFramebuffer($R,VR.framebuffer),KR.setRenderTarget($R));let d=!1;c.length!==eS.cameras.length&&(eS.cameras.length=0,d=!0);for(let e=0;e<c.length;e++){const f=c[e];let g=null;if(null!==VR)g=VR.getViewport(f);else{const h=TR.getViewSubImage(UR,f);g=h.viewport,0===e&&(KR.setRenderTargetTextures($R,h.colorTexture,UR.ignoreDepthValues?void 0:h.depthStencilTexture),KR.setRenderTarget($R))}const i=dS[e];i.matrix.fromArray(f.transform.matrix),i.projectionMatrix.fromArray(f.projectionMatrix),i.viewport.set(g.x,g.y,g.width,g.height),0===e&&eS.matrix.copy(i.matrix),!0===d&&eS.cameras.push(i)}}const j=NR.inputSources;for(let k=0;k<_R.length;k++){const l=_R[k],m=j[k];l.update(m,b,PR)}nS&&nS(a,b),XR=null}),this.setAnimationLoop=function(a){nS=a},this.dispose=function(){}}}function pS(a){function b(b,c){b.opacity.value=c.opacity,c.color&&b.diffuse.value.copy(c.color),c.emissive&&b.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity),c.map&&(b.map.value=c.map),c.alphaMap&&(b.alphaMap.value=c.alphaMap),c.specularMap&&(b.specularMap.value=c.specularMap),c.alphaTest>0&&(b.alphaTest.value=c.alphaTest);const d=a.get(c).envMap;d&&(b.envMap.value=d,b.flipEnvMap.value=d.isCubeTexture&& !1===d.isRenderTargetTexture?-1:1,b.reflectivity.value=c.reflectivity,b.ior.value=c.ior,b.refractionRatio.value=c.refractionRatio),c.lightMap&&(b.lightMap.value=c.lightMap,b.lightMapIntensity.value=c.lightMapIntensity),c.aoMap&&(b.aoMap.value=c.aoMap,b.aoMapIntensity.value=c.aoMapIntensity);let e;c.map?e=c.map:c.specularMap?e=c.specularMap:c.displacementMap?e=c.displacementMap:c.normalMap?e=c.normalMap:c.bumpMap?e=c.bumpMap:c.roughnessMap?e=c.roughnessMap:c.metalnessMap?e=c.metalnessMap:c.alphaMap?e=c.alphaMap:c.emissiveMap?e=c.emissiveMap:c.clearcoatMap?e=c.clearcoatMap:c.clearcoatNormalMap?e=c.clearcoatNormalMap:c.clearcoatRoughnessMap?e=c.clearcoatRoughnessMap:c.specularIntensityMap?e=c.specularIntensityMap:c.specularColorMap?e=c.specularColorMap:c.transmissionMap?e=c.transmissionMap:c.thicknessMap?e=c.thicknessMap:c.sheenColorMap?e=c.sheenColorMap:c.sheenRoughnessMap&&(e=c.sheenRoughnessMap),void 0!==e&&(e.isWebGLRenderTarget&&(e=e.texture),!0===e.matrixAutoUpdate&&e.updateMatrix(),b.uvTransform.value.copy(e.matrix));let f;c.aoMap?f=c.aoMap:c.lightMap&&(f=c.lightMap),void 0!==f&&(f.isWebGLRenderTarget&&(f=f.texture),!0===f.matrixAutoUpdate&&f.updateMatrix(),b.uv2Transform.value.copy(f.matrix))}function c(b,c){b.roughness.value=c.roughness,b.metalness.value=c.metalness,c.roughnessMap&&(b.roughnessMap.value=c.roughnessMap),c.metalnessMap&&(b.metalnessMap.value=c.metalnessMap),c.emissiveMap&&(b.emissiveMap.value=c.emissiveMap),c.bumpMap&&(b.bumpMap.value=c.bumpMap,b.bumpScale.value=c.bumpScale,c.side===g&&(b.bumpScale.value*=-1)),c.normalMap&&(b.normalMap.value=c.normalMap,b.normalScale.value.copy(c.normalScale),c.side===g&&b.normalScale.value.negate()),c.displacementMap&&(b.displacementMap.value=c.displacementMap,b.displacementScale.value=c.displacementScale,b.displacementBias.value=c.displacementBias);const d=a.get(c).envMap;d&&(b.envMapIntensity.value=c.envMapIntensity)}return{refreshFogUniforms:function(a,b){a.fogColor.value.copy(b.color),b.isFog?(a.fogNear.value=b.near,a.fogFar.value=b.far):b.isFogExp2&&(a.fogDensity.value=b.density)},refreshMaterialUniforms:function(a,d,e,f,h){var i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I;let J,K;d.isMeshBasicMaterial?b(a,d):d.isMeshLambertMaterial?(b(a,d),i=a,(j=d).emissiveMap&&(i.emissiveMap.value=j.emissiveMap)):d.isMeshToonMaterial?(b(a,d),k=a,(l=d).gradientMap&&(k.gradientMap.value=l.gradientMap),l.emissiveMap&&(k.emissiveMap.value=l.emissiveMap),l.bumpMap&&(k.bumpMap.value=l.bumpMap,k.bumpScale.value=l.bumpScale,l.side===g&&(k.bumpScale.value*=-1)),l.normalMap&&(k.normalMap.value=l.normalMap,k.normalScale.value.copy(l.normalScale),l.side===g&&k.normalScale.value.negate()),l.displacementMap&&(k.displacementMap.value=l.displacementMap,k.displacementScale.value=l.displacementScale,k.displacementBias.value=l.displacementBias)):d.isMeshPhongMaterial?(b(a,d),m=a,n=d,m.specular.value.copy(n.specular),m.shininess.value=Math.max(n.shininess,1e-4),n.emissiveMap&&(m.emissiveMap.value=n.emissiveMap),n.bumpMap&&(m.bumpMap.value=n.bumpMap,m.bumpScale.value=n.bumpScale,n.side===g&&(m.bumpScale.value*=-1)),n.normalMap&&(m.normalMap.value=n.normalMap,m.normalScale.value.copy(n.normalScale),n.side===g&&m.normalScale.value.negate()),n.displacementMap&&(m.displacementMap.value=n.displacementMap,m.displacementScale.value=n.displacementScale,m.displacementBias.value=n.displacementBias)):d.isMeshStandardMaterial?(b(a,d),d.isMeshPhysicalMaterial?(o=a,p=d,q=h,c(o,p),o.ior.value=p.ior,p.sheen>0&&(o.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),o.sheenRoughness.value=p.sheenRoughness,p.sheenColorMap&&(o.sheenColorMap.value=p.sheenColorMap),p.sheenRoughnessMap&&(o.sheenRoughnessMap.value=p.sheenRoughnessMap)),p.clearcoat>0&&(o.clearcoat.value=p.clearcoat,o.clearcoatRoughness.value=p.clearcoatRoughness,p.clearcoatMap&&(o.clearcoatMap.value=p.clearcoatMap),p.clearcoatRoughnessMap&&(o.clearcoatRoughnessMap.value=p.clearcoatRoughnessMap),p.clearcoatNormalMap&&(o.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),o.clearcoatNormalMap.value=p.clearcoatNormalMap,p.side===g&&o.clearcoatNormalScale.value.negate())),p.transmission>0&&(o.transmission.value=p.transmission,o.transmissionSamplerMap.value=q.texture,o.transmissionSamplerSize.value.set(q.width,q.height),p.transmissionMap&&(o.transmissionMap.value=p.transmissionMap),o.thickness.value=p.thickness,p.thicknessMap&&(o.thicknessMap.value=p.thicknessMap),o.attenuationDistance.value=p.attenuationDistance,o.attenuationColor.value.copy(p.attenuationColor)),o.specularIntensity.value=p.specularIntensity,o.specularColor.value.copy(p.specularColor),p.specularIntensityMap&&(o.specularIntensityMap.value=p.specularIntensityMap),p.specularColorMap&&(o.specularColorMap.value=p.specularColorMap)):c(a,d)):d.isMeshMatcapMaterial?(b(a,d),r=a,(s=d).matcap&&(r.matcap.value=s.matcap),s.bumpMap&&(r.bumpMap.value=s.bumpMap,r.bumpScale.value=s.bumpScale,s.side===g&&(r.bumpScale.value*=-1)),s.normalMap&&(r.normalMap.value=s.normalMap,r.normalScale.value.copy(s.normalScale),s.side===g&&r.normalScale.value.negate()),s.displacementMap&&(r.displacementMap.value=s.displacementMap,r.displacementScale.value=s.displacementScale,r.displacementBias.value=s.displacementBias)):d.isMeshDepthMaterial?(b(a,d),t=a,(u=d).displacementMap&&(t.displacementMap.value=u.displacementMap,t.displacementScale.value=u.displacementScale,t.displacementBias.value=u.displacementBias)):d.isMeshDistanceMaterial?(b(a,d),v=a,(w=d).displacementMap&&(v.displacementMap.value=w.displacementMap,v.displacementScale.value=w.displacementScale,v.displacementBias.value=w.displacementBias),v.referencePosition.value.copy(w.referencePosition),v.nearDistance.value=w.nearDistance,v.farDistance.value=w.farDistance):d.isMeshNormalMaterial?(b(a,d),x=a,(y=d).bumpMap&&(x.bumpMap.value=y.bumpMap,x.bumpScale.value=y.bumpScale,y.side===g&&(x.bumpScale.value*=-1)),y.normalMap&&(x.normalMap.value=y.normalMap,x.normalScale.value.copy(y.normalScale),y.side===g&&x.normalScale.value.negate()),y.displacementMap&&(x.displacementMap.value=y.displacementMap,x.displacementScale.value=y.displacementScale,x.displacementBias.value=y.displacementBias)):d.isLineBasicMaterial?(z=a,A=d,z.diffuse.value.copy(A.color),z.opacity.value=A.opacity,d.isLineDashedMaterial&&(B=a,C=d,B.dashSize.value=C.dashSize,B.totalSize.value=C.dashSize+C.gapSize,B.scale.value=C.scale)):d.isPointsMaterial?(D=a,E=d,F=e,G=f,D.diffuse.value.copy(E.color),D.opacity.value=E.opacity,D.size.value=E.size*F,D.scale.value=.5*G,E.map&&(D.map.value=E.map),E.alphaMap&&(D.alphaMap.value=E.alphaMap),E.alphaTest>0&&(D.alphaTest.value=E.alphaTest),E.map?J=E.map:E.alphaMap&&(J=E.alphaMap),void 0!==J&&(!0===J.matrixAutoUpdate&&J.updateMatrix(),D.uvTransform.value.copy(J.matrix))):d.isSpriteMaterial?(H=a,I=d,H.diffuse.value.copy(I.color),H.opacity.value=I.opacity,H.rotation.value=I.rotation,I.map&&(H.map.value=I.map),I.alphaMap&&(H.alphaMap.value=I.alphaMap),I.alphaTest>0&&(H.alphaTest.value=I.alphaTest),I.map?K=I.map:I.alphaMap&&(K=I.alphaMap),void 0!==K&&(!0===K.matrixAutoUpdate&&K.updateMatrix(),H.uvTransform.value.copy(K.matrix))):d.isShadowMaterial?(a.color.value.copy(d.color),a.opacity.value=d.opacity):d.isShaderMaterial&&(d.uniformsNeedUpdate=!1)}}}function qS(a={}){const b=void 0!==a.canvas?a.canvas:function(){const a=wd("canvas");return a.style.display="block",a}(),c=void 0!==a.context?a.context:null,d=void 0!==a.alpha&&a.alpha,e=void 0===a.depth||a.depth,i=void 0===a.stencil||a.stencil,k=void 0!==a.antialias&&a.antialias,m=void 0===a.premultipliedAlpha||a.premultipliedAlpha,n=void 0!==a.preserveDrawingBuffer&&a.preserveDrawingBuffer,o=void 0!==a.powerPreference?a.powerPreference:"default",p=void 0!==a.failIfMajorPerformanceCaveat&&a.failIfMajorPerformanceCaveat;let r=null,s=null;const t=[],u=[];this.domElement=b,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const v=this;let w=!1,x=0,y=0,z=null,A=-1,B=null;const C=new Af(),D=new Af();let E=null,F=b.width,G=b.height,H=1,I=null,J=null;const K=new Af(0,0,F,G),L=new Af(0,0,F,G);let M=!1;const N=new CK();let O=!1,P=!1,Q=null;const R=new Hq(),S=new nk(),T={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function U(){return null===z?H:1}let V=c;function W(a,c){for(let d=0;d<a.length;d++){const e=a[d],f=b.getContext(e,c);if(null!==f)return f}return null}try{const X={alpha:!0,depth:e,stencil:i,antialias:k,premultipliedAlpha:m,preserveDrawingBuffer:n,powerPreference:o,failIfMajorPerformanceCaveat:p};if("setAttribute"in b&&b.setAttribute("data-engine","three.js r137"),b.addEventListener("webglcontextlost",xa,!1),b.addEventListener("webglcontextrestored",ya,!1),null===V){const Y=["webgl2","webgl","experimental-webgl"];if(!0===v.isWebGL1Renderer&&Y.shift(),V=W(Y,X),null===V){if(W(Y))throw new Error("Error creating WebGL context with your selected attributes.");throw new Error("Error creating WebGL context.")}}void 0===V.getShaderPrecisionFormat&&(V.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Z){throw console.error("THREE.WebGLRenderer: "+Z.message),Z}let $,_,aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la,ma,na,oa,pa,qa,ra,sa,ta,ua;function va(){$=new BO(V),_=new iM(V,$,a),$.init(_),ta=new $Q(V,$,_),aa=new YQ(V,$,_),ba=new EO(V),ca=new GQ(),da=new ZQ(V,$,aa,ca,_,ta,ba),ea=new kM(v),fa=new AO(v),ga=new BL(V,_),ua=new gM(V,$,ga,_),ha=new CO(V,ga,ba,ua),ia=new OO(V,ha,ga,ba),qa=new NO(V,_,da),na=new jM(ca),ja=new FQ(v,ea,fa,$,_,ua,na),ka=new pS(ca),la=new KQ(),ma=new QQ($,_),pa=new fM(v,ea,aa,ia,d,m),oa=new XQ(v,ia,_),ra=new hM(V,$,ba,_),sa=new DO(V,$,ba,_),ba.programs=ja.programs,v.capabilities=_,v.extensions=$,v.properties=ca,v.renderLists=la,v.shadowMap=oa,v.state=aa,v.info=ba}va();const wa=new JR(v,V);function xa(a){a.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function ya(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const a=ba.autoReset,b=oa.enabled,c=oa.autoUpdate,d=oa.needsUpdate,e=oa.type;va(),ba.autoReset=a,oa.enabled=b,oa.autoUpdate=c,oa.needsUpdate=d,oa.type=e}function za(a){const b=a.target;b.removeEventListener("dispose",za),Aa(b)}function Aa(a){Ba(a),ca.remove(a)}function Ba(a){const b=ca.get(a).programs;void 0!==b&&(b.forEach(function(a){ja.releaseProgram(a)}),a.isShaderMaterial&&ja.releaseShaderCache(a))}this.xr=wa,this.getContext=function(){return V},this.getContextAttributes=function(){return V.getContextAttributes()},this.forceContextLoss=function(){const a=$.get("WEBGL_lose_context");a&&a.loseContext()},this.forceContextRestore=function(){const a=$.get("WEBGL_lose_context");a&&a.restoreContext()},this.getPixelRatio=function(){return H},this.setPixelRatio=function(a){void 0!==a&&(H=a,this.setSize(F,G,!1))},this.getSize=function(a){return a.set(F,G)},this.setSize=function(a,c,d){if(wa.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}F=a,G=c,b.width=Math.floor(a*H),b.height=Math.floor(c*H),!1!==d&&(b.style.width=a+"px",b.style.height=c+"px"),this.setViewport(0,0,a,c)},this.getDrawingBufferSize=function(a){return a.set(F*H,G*H).floor()},this.setDrawingBufferSize=function(a,c,d){F=a,G=c,H=d,b.width=Math.floor(a*d),b.height=Math.floor(c*d),this.setViewport(0,0,a,c)},this.getCurrentViewport=function(a){return a.copy(C)},this.getViewport=function(a){return a.copy(K)},this.setViewport=function(a,b,c,d){a.isVector4?K.set(a.x,a.y,a.z,a.w):K.set(a,b,c,d),aa.viewport(C.copy(K).multiplyScalar(H).floor())},this.getScissor=function(a){return a.copy(L)},this.setScissor=function(a,b,c,d){a.isVector4?L.set(a.x,a.y,a.z,a.w):L.set(a,b,c,d),aa.scissor(D.copy(L).multiplyScalar(H).floor())},this.getScissorTest=function(){return M},this.setScissorTest=function(a){aa.setScissorTest(M=a)},this.setOpaqueSort=function(a){I=a},this.setTransparentSort=function(a){J=a},this.getClearColor=function(a){return a.copy(pa.getClearColor())},this.setClearColor=function(){pa.setClearColor.apply(pa,arguments)},this.getClearAlpha=function(){return pa.getClearAlpha()},this.setClearAlpha=function(){pa.setClearAlpha.apply(pa,arguments)},this.clear=function(a,b,c){let d=0;(void 0===a||a)&&(d|=16384),(void 0===b||b)&&(d|=256),(void 0===c||c)&&(d|=1024),V.clear(d)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){b.removeEventListener("webglcontextlost",xa,!1),b.removeEventListener("webglcontextrestored",ya,!1),la.dispose(),ma.dispose(),ca.dispose(),ea.dispose(),fa.dispose(),ia.dispose(),ua.dispose(),ja.dispose(),wa.dispose(),wa.removeEventListener("sessionstart",Da),wa.removeEventListener("sessionend",Ea),Q&&(Q.dispose(),Q=null),Fa.stop()},this.renderBufferDirect=function(a,b,c,d,e,f){null===b&&(b=T);const g=e.isMesh&&0>e.matrixWorld.determinant(),h=Na(a,b,c,d,e);aa.setMaterial(d,g);let i=c.index;const j=c.attributes.position;if(null===i){if(void 0===j||0===j.count)return}else if(0===i.count)return;let k=1;!0===d.wireframe&&(i=ha.getWireframeAttribute(c),k=2),ua.setup(e,d,h,c,i);let l,m=ra;null!==i&&(l=ga.get(i),(m=sa).setIndex(l));const n=null!==i?i.count:j.count,o=c.drawRange.start*k,p=c.drawRange.count*k,q=null!==f?f.start*k:0,r=null!==f?f.count*k:1/0,s=Math.max(o,q),t=Math.max(0,Math.min(n,o+p,q+r)-1-s+1);if(0!==t){if(e.isMesh)!0===d.wireframe?(aa.setLineWidth(d.wireframeLinewidth*U()),m.setMode(1)):m.setMode(4);else if(e.isLine){let u=d.linewidth;void 0===u&&(u=1),aa.setLineWidth(u*U()),e.isLineSegments?m.setMode(1):e.isLineLoop?m.setMode(2):m.setMode(3)}else e.isPoints?m.setMode(0):e.isSprite&&m.setMode(4);if(e.isInstancedMesh)m.renderInstances(s,t,e.count);else if(c.isInstancedBufferGeometry){const v=Math.min(c.instanceCount,c._maxInstanceCount);m.renderInstances(s,t,v)}else m.render(s,t)}},this.compile=function(a,b){(s=ma.get(a)).init(),u.push(s),a.traverseVisible(function(a){a.isLight&&a.layers.test(b.layers)&&(s.pushLight(a),a.castShadow&&s.pushShadow(a))}),s.setupLights(v.physicallyCorrectLights),a.traverse(function(b){const c=b.material;if(c)if(Array.isArray(c))for(let d=0;d<c.length;d++){const e=c[d];La(e,a,b)}else La(c,a,b)}),u.pop(),s=null};let Ca=null;function Da(){Fa.stop()}function Ea(){Fa.start()}const Fa=new AL();function Ga(a,b,c,d){if(!1===a.visible)return;const e=a.layers.test(b.layers);if(e){if(a.isGroup)c=a.renderOrder;else if(a.isLOD)!0===a.autoUpdate&&a.update(b);else if(a.isLight)s.pushLight(a),a.castShadow&&s.pushShadow(a);else if(a.isSprite){if(!a.frustumCulled||N.intersectsSprite(a)){d&&S.setFromMatrixPosition(a.matrixWorld).applyMatrix4(R);const f=ia.update(a),g=a.material;g.visible&&r.push(a,f,g,c,S.z,null)}}else if((a.isMesh||a.isLine||a.isPoints)&&(a.isSkinnedMesh&&a.skeleton.frame!==ba.render.frame&&(a.skeleton.update(),a.skeleton.frame=ba.render.frame),!a.frustumCulled||N.intersectsObject(a))){d&&S.setFromMatrixPosition(a.matrixWorld).applyMatrix4(R);const h=ia.update(a),i=a.material;if(Array.isArray(i)){const j=h.groups;for(let k=0,l=j.length;k<l;k++){const m=j[k],n=i[m.materialIndex];n&&n.visible&&r.push(a,h,n,c,S.z,m)}}else i.visible&&r.push(a,h,i,c,S.z,null)}}const o=a.children;for(let p=0,q=o.length;p<q;p++)Ga(o[p],b,c,d)}function Ha(a,b,c,d){const e=a.opaque,f=a.transmissive,g=a.transparent;s.setupLightsView(c),f.length>0&&Ia(e,b,c),d&&aa.viewport(C.copy(d)),e.length>0&&Ja(e,b,c),f.length>0&&Ja(f,b,c),g.length>0&&Ja(g,b,c)}function Ia(a,b,c){if(null===Q){const d=!0===k&& !0===_.isWebGL2,e=d?Dh:hh;Q=new e(1024,1024,{generateMipmaps:!0,type:null!==ta.convert(1016)?1016:1009,minFilter:q,magFilter:l,wrapS:j,wrapT:j,useRenderToTexture:$.has("WEBGL_multisampled_render_to_texture")})}const f=v.getRenderTarget();v.setRenderTarget(Q),v.clear();const g=v.toneMapping;v.toneMapping=0,Ja(a,b,c),v.toneMapping=g,da.updateMultisampleRenderTarget(Q),da.updateRenderTargetMipmap(Q),v.setRenderTarget(f)}function Ja(a,b,c){const d=!0===b.isScene?b.overrideMaterial:null;for(let e=0,f=a.length;e<f;e++){const g=a[e],h=g.object,i=g.geometry,j=null===d?g.material:d,k=g.group;h.layers.test(c.layers)&&Ka(h,b,c,i,j,k)}}function Ka(a,b,c,d,e,i){a.onBeforeRender(v,b,c,d,e,i),a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,a.matrixWorld),a.normalMatrix.getNormalMatrix(a.modelViewMatrix),e.onBeforeRender(v,b,c,d,a,i),!0===e.transparent&&e.side===h?(e.side=g,e.needsUpdate=!0,v.renderBufferDirect(c,b,d,e,a,i),e.side=f,e.needsUpdate=!0,v.renderBufferDirect(c,b,d,e,a,i),e.side=h):v.renderBufferDirect(c,b,d,e,a,i),a.onAfterRender(v,b,c,d,e,i)}function La(a,b,c){!0!==b.isScene&&(b=T);const d=ca.get(a),e=s.state.lights,f=s.state.shadowsArray,g=e.state.version,h=ja.getParameters(a,e.state,f,b,c),i=ja.getProgramCacheKey(h);let j=d.programs;d.environment=a.isMeshStandardMaterial?b.environment:null,d.fog=b.fog,d.envMap=(a.isMeshStandardMaterial?fa:ea).get(a.envMap||d.environment),void 0===j&&(a.addEventListener("dispose",za),j=new Map(),d.programs=j);let k=j.get(i);if(void 0!==k){if(d.currentProgram===k&&d.lightsStateVersion===g)return Ma(a,h),k}else h.uniforms=ja.getUniforms(a),a.onBuild(c,h,v),a.onBeforeCompile(h,v),k=ja.acquireProgram(h,i),j.set(i,k),d.uniforms=h.uniforms;const l=d.uniforms;(a.isShaderMaterial||a.isRawShaderMaterial)&& !0!==a.clipping||(l.clippingPlanes=na.uniform),Ma(a,h),d.needsLights=Pa(a),d.lightsStateVersion=g,d.needsLights&&(l.ambientLightColor.value=e.state.ambient,l.lightProbe.value=e.state.probe,l.directionalLights.value=e.state.directional,l.directionalLightShadows.value=e.state.directionalShadow,l.spotLights.value=e.state.spot,l.spotLightShadows.value=e.state.spotShadow,l.rectAreaLights.value=e.state.rectArea,l.ltc_1.value=e.state.rectAreaLTC1,l.ltc_2.value=e.state.rectAreaLTC2,l.pointLights.value=e.state.point,l.pointLightShadows.value=e.state.pointShadow,l.hemisphereLights.value=e.state.hemi,l.directionalShadowMap.value=e.state.directionalShadowMap,l.directionalShadowMatrix.value=e.state.directionalShadowMatrix,l.spotShadowMap.value=e.state.spotShadowMap,l.spotShadowMatrix.value=e.state.spotShadowMatrix,l.pointShadowMap.value=e.state.pointShadowMap,l.pointShadowMatrix.value=e.state.pointShadowMatrix);const m=k.getUniforms(),n=XP.seqWithValue(m.seq,l);return d.currentProgram=k,d.uniformsList=n,k}function Ma(a,b){const c=ca.get(a);c.outputEncoding=b.outputEncoding,c.instancing=b.instancing,c.skinning=b.skinning,c.morphTargets=b.morphTargets,c.morphNormals=b.morphNormals,c.morphTargetsCount=b.morphTargetsCount,c.numClippingPlanes=b.numClippingPlanes,c.numIntersection=b.numClipIntersection,c.vertexAlphas=b.vertexAlphas,c.vertexTangents=b.vertexTangents,c.toneMapping=b.toneMapping}function Na(a,b,c,d,e){!0!==b.isScene&&(b=T),da.resetTextureUnits();const f=b.fog,g=d.isMeshStandardMaterial?b.environment:null,h=null===z?v.outputEncoding:!0===z.isXRRenderTarget?z.texture.encoding:3e3,i=(d.isMeshStandardMaterial?fa:ea).get(d.envMap||g),j=!0===d.vertexColors&&!!c.attributes.color&&4===c.attributes.color.itemSize,k=!!d.normalMap&&!!c.attributes.tangent,l=!!c.morphAttributes.position,m=!!c.morphAttributes.normal,n=c.morphAttributes.position?c.morphAttributes.position.length:0,o=d.toneMapped?v.toneMapping:0,p=ca.get(d),q=s.state.lights;if(!0===O&&(!0===P||a!==B)){const r=a===B&&d.id===A;na.setState(d,a,r)}let t=!1;d.version===p.__version?p.needsLights&&p.lightsStateVersion!==q.state.version?t=!0:p.outputEncoding!==h?t=!0:e.isInstancedMesh&& !1===p.instancing?t=!0:e.isInstancedMesh|| !0!==p.instancing?e.isSkinnedMesh&& !1===p.skinning?t=!0:e.isSkinnedMesh|| !0!==p.skinning?p.envMap!==i?t=!0:d.fog&&p.fog!==f?t=!0:void 0!==p.numClippingPlanes&&(p.numClippingPlanes!==na.numPlanes||p.numIntersection!==na.numIntersection)?t=!0:p.vertexAlphas!==j?t=!0:p.vertexTangents!==k?t=!0:p.morphTargets!==l?t=!0:p.morphNormals!==m?t=!0:p.toneMapping!==o?t=!0:!0===_.isWebGL2&&p.morphTargetsCount!==n&&(t=!0):t=!0:t=!0:(t=!0,p.__version=d.version);let u=p.currentProgram;!0===t&&(u=La(d,b,e));let w=!1,x=!1,y=!1;const C=u.getUniforms(),D=p.uniforms;if(aa.useProgram(u.program)&&(w=!0,x=!0,y=!0),d.id!==A&&(A=d.id,x=!0),w||B!==a){if(C.setValue(V,"projectionMatrix",a.projectionMatrix),_.logarithmicDepthBuffer&&C.setValue(V,"logDepthBufFC",2/(Math.log(a.far+1)/Math.LN2)),B!==a&&(B=a,x=!0,y=!0),d.isShaderMaterial||d.isMeshPhongMaterial||d.isMeshToonMaterial||d.isMeshStandardMaterial||d.envMap){const E=C.map.cameraPosition;void 0!==E&&E.setValue(V,S.setFromMatrixPosition(a.matrixWorld))}(d.isMeshPhongMaterial||d.isMeshToonMaterial||d.isMeshLambertMaterial||d.isMeshBasicMaterial||d.isMeshStandardMaterial||d.isShaderMaterial)&&C.setValue(V,"isOrthographic",!0===a.isOrthographicCamera),(d.isMeshPhongMaterial||d.isMeshToonMaterial||d.isMeshLambertMaterial||d.isMeshBasicMaterial||d.isMeshStandardMaterial||d.isShaderMaterial||d.isShadowMaterial||e.isSkinnedMesh)&&C.setValue(V,"viewMatrix",a.matrixWorldInverse)}if(e.isSkinnedMesh){C.setOptional(V,e,"bindMatrix"),C.setOptional(V,e,"bindMatrixInverse");const F=e.skeleton;F&&(_.floatVertexTextures?(null===F.boneTexture&&F.computeBoneTexture(),C.setValue(V,"boneTexture",F.boneTexture,da),C.setValue(V,"boneTextureSize",F.boneTextureSize)):C.setOptional(V,F,"boneMatrices"))}return c&&(void 0!==c.morphAttributes.position|| void 0!==c.morphAttributes.normal)&&qa.update(e,c,d,u),(x||p.receiveShadow!==e.receiveShadow)&&(p.receiveShadow=e.receiveShadow,C.setValue(V,"receiveShadow",e.receiveShadow)),x&&(C.setValue(V,"toneMappingExposure",v.toneMappingExposure),p.needsLights&&Oa(D,y),f&&d.fog&&ka.refreshFogUniforms(D,f),ka.refreshMaterialUniforms(D,d,H,G,Q),XP.upload(V,p.uniformsList,D,da)),d.isShaderMaterial&& !0===d.uniformsNeedUpdate&&(XP.upload(V,p.uniformsList,D,da),d.uniformsNeedUpdate=!1),d.isSpriteMaterial&&C.setValue(V,"center",e.center),C.setValue(V,"modelViewMatrix",e.modelViewMatrix),C.setValue(V,"normalMatrix",e.normalMatrix),C.setValue(V,"modelMatrix",e.matrixWorld),u}function Oa(a,b){a.ambientLightColor.needsUpdate=b,a.lightProbe.needsUpdate=b,a.directionalLights.needsUpdate=b,a.directionalLightShadows.needsUpdate=b,a.pointLights.needsUpdate=b,a.pointLightShadows.needsUpdate=b,a.spotLights.needsUpdate=b,a.spotLightShadows.needsUpdate=b,a.rectAreaLights.needsUpdate=b,a.hemisphereLights.needsUpdate=b}function Pa(a){return a.isMeshLambertMaterial||a.isMeshToonMaterial||a.isMeshPhongMaterial||a.isMeshStandardMaterial||a.isShadowMaterial||a.isShaderMaterial&& !0===a.lights}Fa.setAnimationLoop(function(a){Ca&&Ca(a)}),"undefined"!=typeof window&&Fa.setContext(window),this.setAnimationLoop=function(a){Ca=a,wa.setAnimationLoop(a),null===a?Fa.stop():Fa.start()},wa.addEventListener("sessionstart",Da),wa.addEventListener("sessionend",Ea),this.render=function(a,b){if(void 0!==b&& !0!==b.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(!0===w)return;!0===a.autoUpdate&&a.updateMatrixWorld(),null===b.parent&&b.updateMatrixWorld(),!0===wa.enabled&& !0===wa.isPresenting&&(!0===wa.cameraAutoUpdate&&wa.updateCamera(b),b=wa.getCamera()),!0===a.isScene&&a.onBeforeRender(v,a,b,z),(s=ma.get(a,u.length)).init(),u.push(s),R.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse),N.setFromProjectionMatrix(R),P=this.localClippingEnabled,O=na.init(this.clippingPlanes,P,b),(r=la.get(a,t.length)).init(),t.push(r),Ga(a,b,0,v.sortObjects),r.finish(),!0===v.sortObjects&&r.sort(I,J),!0===O&&na.beginShadows();const c=s.state.shadowsArray;if(oa.render(c,a,b),!0===O&&na.endShadows(),!0===this.info.autoReset&&this.info.reset(),pa.render(r,a),s.setupLights(v.physicallyCorrectLights),b.isArrayCamera){const d=b.cameras;for(let e=0,f=d.length;e<f;e++){const g=d[e];Ha(r,a,g,g.viewport)}}else Ha(r,a,b);null!==z&&(da.updateMultisampleRenderTarget(z),da.updateRenderTargetMipmap(z)),!0===a.isScene&&a.onAfterRender(v,a,b),aa.buffers.depth.setTest(!0),aa.buffers.depth.setMask(!0),aa.buffers.color.setMask(!0),aa.setPolygonOffset(!1),ua.resetDefaultState(),A=-1,B=null,u.pop(),s=u.length>0?u[u.length-1]:null,t.pop(),r=t.length>0?t[t.length-1]:null},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return z},this.setRenderTargetTextures=function(a,b,c){ca.get(a.texture).__webglTexture=b,ca.get(a.depthTexture).__webglTexture=c;const d=ca.get(a);d.__hasExternalTextures=!0,d.__hasExternalTextures&&(d.__autoAllocateDepthBuffer=void 0===c,!d.__autoAllocateDepthBuffer&&a.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),a.useRenderToTexture=!1,a.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(a,b){const c=ca.get(a);c.__webglFramebuffer=b,c.__useDefaultFramebuffer=void 0===b},this.setRenderTarget=function(a,b=0,c=0){z=a,x=b,y=c;let d=!0;if(a){const e=ca.get(a);void 0!==e.__useDefaultFramebuffer?(aa.bindFramebuffer(36160,null),d=!1):void 0===e.__webglFramebuffer?da.setupRenderTarget(a):e.__hasExternalTextures&&da.rebindTextures(a,ca.get(a.texture).__webglTexture,ca.get(a.depthTexture).__webglTexture)}let f=null,g=!1,h=!1;if(a){const i=a.texture;(i.isDataTexture3D||i.isDataTexture2DArray)&&(h=!0);const j=ca.get(a).__webglFramebuffer;a.isWebGLCubeRenderTarget?(f=j[b],g=!0):f=a.useRenderbuffer?ca.get(a).__webglMultisampledFramebuffer:j,C.copy(a.viewport),D.copy(a.scissor),E=a.scissorTest}else C.copy(K).multiplyScalar(H).floor(),D.copy(L).multiplyScalar(H).floor(),E=M;const k=aa.bindFramebuffer(36160,f);if(k&&_.drawBuffers&&d&&aa.drawBuffers(a,f),aa.viewport(C),aa.scissor(D),aa.setScissorTest(E),g){const l=ca.get(a.texture);V.framebufferTexture2D(36160,36064,34069+b,l.__webglTexture,c)}else if(h){const m=ca.get(a.texture),n=b||0;V.framebufferTextureLayer(36160,36064,m.__webglTexture,c||0,n)}A=-1},this.readRenderTargetPixels=function(a,b,c,d,e,f,g){if(!(a&&a.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let h=ca.get(a).__webglFramebuffer;if(a.isWebGLCubeRenderTarget&& void 0!==g&&(h=h[g]),h){aa.bindFramebuffer(36160,h);try{const i=a.texture,j=i.format,k=i.type;if(1023!==j&&ta.convert(j)!==V.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const l=1016===k&&($.has("EXT_color_buffer_half_float")||_.isWebGL2&&$.has("EXT_color_buffer_float"));if(1009!==k&&ta.convert(k)!==V.getParameter(35738)&&!(1015===k&&(_.isWebGL2||$.has("OES_texture_float")||$.has("WEBGL_color_buffer_float")))&&!l){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}36053===V.checkFramebufferStatus(36160)?b>=0&&b<=a.width-d&&c>=0&&c<=a.height-e&&V.readPixels(b,c,d,e,ta.convert(j),ta.convert(k),f):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const m=null!==z?ca.get(z).__webglFramebuffer:null;aa.bindFramebuffer(36160,m)}}},this.copyFramebufferToTexture=function(a,b,c=0){if(!0!==b.isFramebufferTexture){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const d=Math.pow(2,-c),e=Math.floor(b.image.width*d),f=Math.floor(b.image.height*d);da.setTexture2D(b,0),V.copyTexSubImage2D(3553,c,0,0,a.x,a.y,e,f),aa.unbindTexture()},this.copyTextureToTexture=function(a,b,c,d=0){const e=b.image.width,f=b.image.height,g=ta.convert(c.format),h=ta.convert(c.type);da.setTexture2D(c,0),V.pixelStorei(37440,c.flipY),V.pixelStorei(37441,c.premultiplyAlpha),V.pixelStorei(3317,c.unpackAlignment),b.isDataTexture?V.texSubImage2D(3553,d,a.x,a.y,e,f,g,h,b.image.data):b.isCompressedTexture?V.compressedTexSubImage2D(3553,d,a.x,a.y,b.mipmaps[0].width,b.mipmaps[0].height,g,b.mipmaps[0].data):V.texSubImage2D(3553,d,a.x,a.y,g,h,b.image),0===d&&c.generateMipmaps&&V.generateMipmap(3553),aa.unbindTexture()},this.copyTextureToTexture3D=function(a,b,c,d,e=0){if(v.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const f=a.max.x-a.min.x+1,g=a.max.y-a.min.y+1,h=a.max.z-a.min.z+1,i=ta.convert(d.format),j=ta.convert(d.type);let k;if(d.isDataTexture3D)da.setTexture3D(d,0),k=32879;else if(d.isDataTexture2DArray)da.setTexture2DArray(d,0),k=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}V.pixelStorei(37440,d.flipY),V.pixelStorei(37441,d.premultiplyAlpha),V.pixelStorei(3317,d.unpackAlignment);const l=V.getParameter(3314),m=V.getParameter(32878),n=V.getParameter(3316),o=V.getParameter(3315),p=V.getParameter(32877),q=c.isCompressedTexture?c.mipmaps[0]:c.image;V.pixelStorei(3314,q.width),V.pixelStorei(32878,q.height),V.pixelStorei(3316,a.min.x),V.pixelStorei(3315,a.min.y),V.pixelStorei(32877,a.min.z),c.isDataTexture||c.isDataTexture3D?V.texSubImage3D(k,e,b.x,b.y,b.z,f,g,h,i,j,q.data):c.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),V.compressedTexSubImage3D(k,e,b.x,b.y,b.z,f,g,h,i,q.data)):V.texSubImage3D(k,e,b.x,b.y,b.z,f,g,h,i,j,q),V.pixelStorei(3314,l),V.pixelStorei(32878,m),V.pixelStorei(3316,n),V.pixelStorei(3315,o),V.pixelStorei(32877,p),0===e&&d.generateMipmaps&&V.generateMipmap(k),aa.unbindTexture()},this.initTexture=function(a){da.setTexture2D(a,0),aa.unbindTexture()},this.resetState=function(){x=0,y=0,z=null,aa.reset(),ua.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}qS.prototype.isWebGLRenderer=!0,(class extends qS{}).prototype.isWebGL1Renderer=!0;class rS{constructor(sS,tS=25e-5){this.name="",this.color=new Dd(sS),this.density=tS}clone(){return new rS(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}rS.prototype.isFogExp2=!0;class uS{constructor(vS,wS=1,xS=1e3){this.name="",this.color=new Dd(vS),this.near=wS,this.far=xS}clone(){return new uS(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}uS.prototype.isFog=!0;class yS extends Sw{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(zS,AS){return super.copy(zS,AS),null!==zS.background&&(this.background=zS.background.clone()),null!==zS.environment&&(this.environment=zS.environment.clone()),null!==zS.fog&&(this.fog=zS.fog.clone()),null!==zS.overrideMaterial&&(this.overrideMaterial=zS.overrideMaterial.clone()),this.autoUpdate=zS.autoUpdate,this.matrixAutoUpdate=zS.matrixAutoUpdate,this}toJSON(BS){const CS=super.toJSON(BS);return null!==this.fog&&(CS.object.fog=this.fog.toJSON()),CS}}yS.prototype.isScene=!0;class DS{constructor(ES,FS){this.array=ES,this.stride=FS,this.count=void 0!==ES?ES.length/FS:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=V()}onUploadCallback(){}set needsUpdate(GS){!0===GS&&this.version++}setUsage(HS){return this.usage=HS,this}copy(IS){return this.array=new IS.array.constructor(IS.array),this.count=IS.count,this.stride=IS.stride,this.usage=IS.usage,this}copyAt(JS,KS,LS){JS*=this.stride,LS*=KS.stride;for(let MS=0,NS=this.stride;MS<NS;MS++)this.array[JS+MS]=KS.array[LS+MS];return this}set(OS,PS=0){return this.array.set(OS,PS),this}clone(QS){void 0===QS.arrayBuffers&&(QS.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=V()),void 0===QS.arrayBuffers[this.array.buffer._uuid]&&(QS.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const RS=new this.array.constructor(QS.arrayBuffers[this.array.buffer._uuid]),SS=new this.constructor(RS,this.stride);return SS.setUsage(this.usage),SS}onUpload(TS){return this.onUploadCallback=TS,this}toJSON(US){return void 0===US.arrayBuffers&&(US.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=V()),void 0===US.arrayBuffers[this.array.buffer._uuid]&&(US.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}DS.prototype.isInterleavedBuffer=!0;const VS=new nk();class WS{constructor(XS,YS,ZS,$S=!1){this.name="",this.data=XS,this.itemSize=YS,this.offset=ZS,this.normalized=!0===$S}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(_S){this.data.needsUpdate=_S}applyMatrix4(aT){for(let bT=0,cT=this.data.count;bT<cT;bT++)VS.x=this.getX(bT),VS.y=this.getY(bT),VS.z=this.getZ(bT),VS.applyMatrix4(aT),this.setXYZ(bT,VS.x,VS.y,VS.z);return this}applyNormalMatrix(dT){for(let eT=0,fT=this.count;eT<fT;eT++)VS.x=this.getX(eT),VS.y=this.getY(eT),VS.z=this.getZ(eT),VS.applyNormalMatrix(dT),this.setXYZ(eT,VS.x,VS.y,VS.z);return this}transformDirection(gT){for(let hT=0,iT=this.count;hT<iT;hT++)VS.x=this.getX(hT),VS.y=this.getY(hT),VS.z=this.getZ(hT),VS.transformDirection(gT),this.setXYZ(hT,VS.x,VS.y,VS.z);return this}setX(jT,kT){return this.data.array[jT*this.data.stride+this.offset]=kT,this}setY(lT,mT){return this.data.array[lT*this.data.stride+this.offset+1]=mT,this}setZ(nT,oT){return this.data.array[nT*this.data.stride+this.offset+2]=oT,this}setW(pT,qT){return this.data.array[pT*this.data.stride+this.offset+3]=qT,this}getX(rT){return this.data.array[rT*this.data.stride+this.offset]}getY(sT){return this.data.array[sT*this.data.stride+this.offset+1]}getZ(tT){return this.data.array[tT*this.data.stride+this.offset+2]}getW(uT){return this.data.array[uT*this.data.stride+this.offset+3]}setXY(vT,wT,xT){return vT=vT*this.data.stride+this.offset,this.data.array[vT+0]=wT,this.data.array[vT+1]=xT,this}setXYZ(yT,zT,AT,BT){return yT=yT*this.data.stride+this.offset,this.data.array[yT+0]=zT,this.data.array[yT+1]=AT,this.data.array[yT+2]=BT,this}setXYZW(CT,DT,ET,FT,GT){return CT=CT*this.data.stride+this.offset,this.data.array[CT+0]=DT,this.data.array[CT+1]=ET,this.data.array[CT+2]=FT,this.data.array[CT+3]=GT,this}clone(HT){if(void 0!==HT)return void 0===HT.interleavedBuffers&&(HT.interleavedBuffers={}),void 0===HT.interleavedBuffers[this.data.uuid]&&(HT.interleavedBuffers[this.data.uuid]=this.data.clone(HT)),new WS(HT.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);{console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const IT=[];for(let JT=0;JT<this.count;JT++){const KT=JT*this.data.stride+this.offset;for(let LT=0;LT<this.itemSize;LT++)IT.push(this.data.array[KT+LT])}return new TA(new this.array.constructor(IT),this.itemSize,this.normalized)}}toJSON(MT){if(void 0!==MT)return void 0===MT.interleavedBuffers&&(MT.interleavedBuffers={}),void 0===MT.interleavedBuffers[this.data.uuid]&&(MT.interleavedBuffers[this.data.uuid]=this.data.toJSON(MT)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};{console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const NT=[];for(let OT=0;OT<this.count;OT++){const PT=OT*this.data.stride+this.offset;for(let QT=0;QT<this.itemSize;QT++)NT.push(this.data.array[PT+QT])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:NT,normalized:this.normalized}}}}WS.prototype.isInterleavedBufferAttribute=!0;class RT extends wA{constructor(ST){super(),this.type="SpriteMaterial",this.color=new Dd(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(ST)}copy(TT){return super.copy(TT),this.color.copy(TT.color),this.map=TT.map,this.alphaMap=TT.alphaMap,this.rotation=TT.rotation,this.sizeAttenuation=TT.sizeAttenuation,this}}RT.prototype.isSpriteMaterial=!0;let UT;const VT=new nk(),WT=new nk(),XT=new nk(),YT=new ba(),ZT=new ba(),$T=new Hq(),_T=new nk(),aU=new nk(),bU=new nk(),cU=new ba(),dU=new ba(),eU=new ba();function fU(a,b,c,d,e,f){YT.subVectors(a,c).addScalar(.5).multiply(d),void 0!==e?(ZT.x=f*YT.x-e*YT.y,ZT.y=e*YT.x+f*YT.y):ZT.copy(YT),a.copy(b),a.x+=ZT.x,a.y+=ZT.y,a.applyMatrix4($T)}(class extends Sw{constructor(gU){if(super(),this.type="Sprite",void 0===UT){UT=new MC();const hU=new Float32Array([-0.5,-0.5,0,0,0,.5,-0.5,0,1,0,.5,.5,0,1,1,-0.5,.5,0,0,1]),iU=new DS(hU,5);UT.setIndex([0,1,2,0,2,3]),UT.setAttribute("position",new WS(iU,3,0,!1)),UT.setAttribute("uv",new WS(iU,2,3,!1))}this.geometry=UT,this.material=void 0!==gU?gU:new RT(),this.center=new ba(.5,.5)}raycast(jU,kU){null===jU.camera&&console.error("THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites."),WT.setFromMatrixScale(this.matrixWorld),$T.copy(jU.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(jU.camera.matrixWorldInverse,this.matrixWorld),XT.setFromMatrixPosition(this.modelViewMatrix),jU.camera.isPerspectiveCamera&& !1===this.material.sizeAttenuation&&WT.multiplyScalar(-XT.z);const lU=this.material.rotation;let mU,nU;0!==lU&&(nU=Math.cos(lU),mU=Math.sin(lU));const oU=this.center;fU(_T.set(-0.5,-0.5,0),XT,oU,WT,mU,nU),fU(aU.set(.5,-0.5,0),XT,oU,WT,mU,nU),fU(bU.set(.5,.5,0),XT,oU,WT,mU,nU),cU.set(0,0),dU.set(1,0),eU.set(1,1);let pU=jU.ray.intersectTriangle(_T,aU,bU,!1,VT);if(null===pU&&(fU(aU.set(-0.5,.5,0),XT,oU,WT,mU,nU),dU.set(0,1),null===(pU=jU.ray.intersectTriangle(_T,bU,aU,!1,VT))))return;const qU=jU.ray.origin.distanceTo(VT);qU<jU.near||qU>jU.far||kU.push({distance:qU,point:VT.clone(),uv:Vy.getUV(VT,_T,aU,bU,cU,dU,eU,new ba()),face:null,object:this})}copy(rU){return super.copy(rU),void 0!==rU.center&&this.center.copy(rU.center),this.material=rU.material,this}}).prototype.isSprite=!0,new nk(),new nk();const sU=new nk(),tU=new Af(),uU=new Af(),vU=new nk(),wU=new Hq();class xU extends vG{constructor(yU,zU){super(yU,zU),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Hq(),this.bindMatrixInverse=new Hq()}copy(AU){return super.copy(AU),this.bindMode=AU.bindMode,this.bindMatrix.copy(AU.bindMatrix),this.bindMatrixInverse.copy(AU.bindMatrixInverse),this.skeleton=AU.skeleton,this}bind(BU,CU){this.skeleton=BU,void 0===CU&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),CU=this.matrixWorld),this.bindMatrix.copy(CU),this.bindMatrixInverse.copy(CU).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const DU=new Af(),EU=this.geometry.attributes.skinWeight;for(let FU=0,GU=EU.count;FU<GU;FU++){DU.x=EU.getX(FU),DU.y=EU.getY(FU),DU.z=EU.getZ(FU),DU.w=EU.getW(FU);const HU=1/DU.manhattanLength();HU!==1/0?DU.multiplyScalar(HU):DU.set(1,0,0,0),EU.setXYZW(FU,DU.x,DU.y,DU.z,DU.w)}}updateMatrixWorld(IU){super.updateMatrixWorld(IU),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(JU,KU){const LU=this.skeleton,MU=this.geometry;tU.fromBufferAttribute(MU.attributes.skinIndex,JU),uU.fromBufferAttribute(MU.attributes.skinWeight,JU),sU.copy(KU).applyMatrix4(this.bindMatrix),KU.set(0,0,0);for(let NU=0;NU<4;NU++){const OU=uU.getComponent(NU);if(0!==OU){const PU=tU.getComponent(NU);wU.multiplyMatrices(LU.bones[PU].matrixWorld,LU.boneInverses[PU]),KU.addScaledVector(vU.copy(sU).applyMatrix4(wU),OU)}}return KU.applyMatrix4(this.bindMatrixInverse)}}xU.prototype.isSkinnedMesh=!0;class QU extends Sw{constructor(){super(),this.type="Bone"}}QU.prototype.isBone=!0;class RU extends df{constructor(SU=null,TU=1,UU=1,VU,WU,XU,YU,ZU,$U=l,_U=l,aV,bV){super(null,XU,YU,ZU,$U,_U,VU,WU,aV,bV),this.image={data:SU,width:TU,height:UU},this.magFilter=$U,this.minFilter=_U,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}RU.prototype.isDataTexture=!0;const cV=new Hq(),dV=new Hq();class eV{constructor(fV=[],gV=[]){this.uuid=V(),this.bones=fV.slice(0),this.boneInverses=gV,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const hV=this.bones,iV=this.boneInverses;if(this.boneMatrices=new Float32Array(16*hV.length),0===iV.length)this.calculateInverses();else if(hV.length!==iV.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let jV=0,kV=this.bones.length;jV<kV;jV++)this.boneInverses.push(new Hq())}}calculateInverses(){this.boneInverses.length=0;for(let lV=0,mV=this.bones.length;lV<mV;lV++){const nV=new Hq();this.bones[lV]&&nV.copy(this.bones[lV].matrixWorld).invert(),this.boneInverses.push(nV)}}pose(){for(let oV=0,pV=this.bones.length;oV<pV;oV++){const qV=this.bones[oV];qV&&qV.matrixWorld.copy(this.boneInverses[oV]).invert()}for(let rV=0,sV=this.bones.length;rV<sV;rV++){const tV=this.bones[rV];tV&&(tV.parent&&tV.parent.isBone?(tV.matrix.copy(tV.parent.matrixWorld).invert(),tV.matrix.multiply(tV.matrixWorld)):tV.matrix.copy(tV.matrixWorld),tV.matrix.decompose(tV.position,tV.quaternion,tV.scale))}}update(){const uV=this.bones,vV=this.boneInverses,wV=this.boneMatrices,xV=this.boneTexture;for(let yV=0,zV=uV.length;yV<zV;yV++){const AV=uV[yV]?uV[yV].matrixWorld:dV;cV.multiplyMatrices(AV,vV[yV]),cV.toArray(wV,16*yV)}null!==xV&&(xV.needsUpdate=!0)}clone(){return new eV(this.bones,this.boneInverses)}computeBoneTexture(){let BV=Math.sqrt(4*this.bones.length);BV=Math.max(BV=$(BV),4);const CV=new Float32Array(BV*BV*4);CV.set(this.boneMatrices);const DV=new RU(CV,BV,BV,1023,1015);return DV.needsUpdate=!0,this.boneMatrices=CV,this.boneTexture=DV,this.boneTextureSize=BV,this}getBoneByName(EV){for(let FV=0,GV=this.bones.length;FV<GV;FV++){const HV=this.bones[FV];if(HV.name===EV)return HV}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(IV,JV){this.uuid=IV.uuid;for(let KV=0,LV=IV.bones.length;KV<LV;KV++){const MV=IV.bones[KV];let NV=JV[MV];void 0===NV&&(console.warn("THREE.Skeleton: No bone found with UUID:",MV),NV=new QU()),this.bones.push(NV),this.boneInverses.push(new Hq().fromArray(IV.boneInverses[KV]))}return this.init(),this}toJSON(){const OV={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};OV.uuid=this.uuid;const PV=this.bones,QV=this.boneInverses;for(let RV=0,SV=PV.length;RV<SV;RV++){const TV=PV[RV];OV.bones.push(TV.uuid);const UV=QV[RV];OV.boneInverses.push(UV.toArray())}return OV}}class VV extends TA{constructor(WV,XV,YV,ZV=1){"number"==typeof YV&&(ZV=YV,YV=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(WV,XV,YV),this.meshPerAttribute=ZV}copy($V){return super.copy($V),this.meshPerAttribute=$V.meshPerAttribute,this}toJSON(){const _V=super.toJSON();return _V.meshPerAttribute=this.meshPerAttribute,_V.isInstancedBufferAttribute=!0,_V}}VV.prototype.isInstancedBufferAttribute=!0;const aW=new Hq(),bW=new Hq(),cW=[],dW=new vG();(class extends vG{constructor(eW,fW,gW){super(eW,fW),this.instanceMatrix=new VV(new Float32Array(16*gW),16),this.instanceColor=null,this.count=gW,this.frustumCulled=!1}copy(hW){return super.copy(hW),this.instanceMatrix.copy(hW.instanceMatrix),null!==hW.instanceColor&&(this.instanceColor=hW.instanceColor.clone()),this.count=hW.count,this}getColorAt(iW,jW){jW.fromArray(this.instanceColor.array,3*iW)}getMatrixAt(kW,lW){lW.fromArray(this.instanceMatrix.array,16*kW)}raycast(mW,nW){const oW=this.matrixWorld,pW=this.count;if(dW.geometry=this.geometry,dW.material=this.material,void 0!==dW.material)for(let qW=0;qW<pW;qW++){this.getMatrixAt(qW,aW),bW.multiplyMatrices(oW,aW),dW.matrixWorld=bW,dW.raycast(mW,cW);for(let rW=0,sW=cW.length;rW<sW;rW++){const tW=cW[rW];tW.instanceId=qW,tW.object=this,nW.push(tW)}cW.length=0}}setColorAt(uW,vW){null===this.instanceColor&&(this.instanceColor=new VV(new Float32Array(3*this.instanceMatrix.count),3)),vW.toArray(this.instanceColor.array,3*uW)}setMatrixAt(wW,xW){xW.toArray(this.instanceMatrix.array,16*wW)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}).prototype.isInstancedMesh=!0;class yW extends wA{constructor(zW){super(),this.type="LineBasicMaterial",this.color=new Dd(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(zW)}copy(AW){return super.copy(AW),this.color.copy(AW.color),this.linewidth=AW.linewidth,this.linecap=AW.linecap,this.linejoin=AW.linejoin,this}}yW.prototype.isLineBasicMaterial=!0;const BW=new nk(),CW=new nk(),DW=new Hq(),EW=new np(),FW=new Eo();class GW extends Sw{constructor(HW=new MC(),IW=new yW()){super(),this.type="Line",this.geometry=HW,this.material=IW,this.updateMorphTargets()}copy(JW){return super.copy(JW),this.material=JW.material,this.geometry=JW.geometry,this}computeLineDistances(){const KW=this.geometry;if(KW.isBufferGeometry)if(null===KW.index){const LW=KW.attributes.position,MW=[0];for(let NW=1,OW=LW.count;NW<OW;NW++)BW.fromBufferAttribute(LW,NW-1),CW.fromBufferAttribute(LW,NW),MW[NW]=MW[NW-1],MW[NW]+=BW.distanceTo(CW);KW.setAttribute("lineDistance",new BC(MW,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else KW.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(PW,QW){const RW=this.geometry,SW=this.matrixWorld,TW=PW.params.Line.threshold,UW=RW.drawRange;if(null===RW.boundingSphere&&RW.computeBoundingSphere(),FW.copy(RW.boundingSphere),FW.applyMatrix4(SW),FW.radius+=TW,!1===PW.ray.intersectsSphere(FW))return;DW.copy(SW).invert(),EW.copy(PW.ray).applyMatrix4(DW);const VW=TW/((this.scale.x+this.scale.y+this.scale.z)/3),WW=VW*VW,XW=new nk(),YW=new nk(),ZW=new nk(),$W=new nk(),_W=this.isLineSegments?2:1;if(RW.isBufferGeometry){const aX=RW.index,bX=RW.attributes,cX=bX.position;if(null!==aX){const dX=Math.max(0,UW.start),eX=Math.min(aX.count,UW.start+UW.count);for(let fX=dX,gX=eX-1;fX<gX;fX+=_W){const hX=aX.getX(fX),iX=aX.getX(fX+1);XW.fromBufferAttribute(cX,hX),YW.fromBufferAttribute(cX,iX);const jX=EW.distanceSqToSegment(XW,YW,$W,ZW);if(jX>WW)continue;$W.applyMatrix4(this.matrixWorld);const kX=PW.ray.origin.distanceTo($W);kX<PW.near||kX>PW.far||QW.push({distance:kX,point:ZW.clone().applyMatrix4(this.matrixWorld),index:fX,face:null,faceIndex:null,object:this})}}else{const lX=Math.max(0,UW.start),mX=Math.min(cX.count,UW.start+UW.count);for(let nX=lX,oX=mX-1;nX<oX;nX+=_W){XW.fromBufferAttribute(cX,nX),YW.fromBufferAttribute(cX,nX+1);const pX=EW.distanceSqToSegment(XW,YW,$W,ZW);if(pX>WW)continue;$W.applyMatrix4(this.matrixWorld);const qX=PW.ray.origin.distanceTo($W);qX<PW.near||qX>PW.far||QW.push({distance:qX,point:ZW.clone().applyMatrix4(this.matrixWorld),index:nX,face:null,faceIndex:null,object:this})}}}else RW.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const rX=this.geometry;if(rX.isBufferGeometry){const sX=rX.morphAttributes,tX=Object.keys(sX);if(tX.length>0){const uX=sX[tX[0]];if(void 0!==uX){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let vX=0,wX=uX.length;vX<wX;vX++){const xX=uX[vX].name||String(vX);this.morphTargetInfluences.push(0),this.morphTargetDictionary[xX]=vX}}}}else{const yX=rX.morphTargets;void 0!==yX&&yX.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}GW.prototype.isLine=!0;const zX=new nk(),AX=new nk();class BX extends GW{constructor(CX,DX){super(CX,DX),this.type="LineSegments"}computeLineDistances(){const EX=this.geometry;if(EX.isBufferGeometry)if(null===EX.index){const FX=EX.attributes.position,GX=[];for(let HX=0,IX=FX.count;HX<IX;HX+=2)zX.fromBufferAttribute(FX,HX),AX.fromBufferAttribute(FX,HX+1),GX[HX]=0===HX?0:GX[HX-1],GX[HX+1]=GX[HX]+zX.distanceTo(AX);EX.setAttribute("lineDistance",new BC(GX,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else EX.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}BX.prototype.isLineSegments=!0;class JX extends GW{constructor(KX,LX){super(KX,LX),this.type="LineLoop"}}JX.prototype.isLineLoop=!0;class MX extends wA{constructor(NX){super(),this.type="PointsMaterial",this.color=new Dd(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(NX)}copy(OX){return super.copy(OX),this.color.copy(OX.color),this.map=OX.map,this.alphaMap=OX.alphaMap,this.size=OX.size,this.sizeAttenuation=OX.sizeAttenuation,this}}MX.prototype.isPointsMaterial=!0;const PX=new Hq(),QX=new np(),RX=new Eo(),SX=new nk();class TX extends Sw{constructor(UX=new MC(),VX=new MX()){super(),this.type="Points",this.geometry=UX,this.material=VX,this.updateMorphTargets()}copy(WX){return super.copy(WX),this.material=WX.material,this.geometry=WX.geometry,this}raycast(XX,YX){const ZX=this.geometry,$X=this.matrixWorld,_X=XX.params.Points.threshold,aY=ZX.drawRange;if(null===ZX.boundingSphere&&ZX.computeBoundingSphere(),RX.copy(ZX.boundingSphere),RX.applyMatrix4($X),RX.radius+=_X,!1===XX.ray.intersectsSphere(RX))return;PX.copy($X).invert(),QX.copy(XX.ray).applyMatrix4(PX);const bY=_X/((this.scale.x+this.scale.y+this.scale.z)/3),cY=bY*bY;if(ZX.isBufferGeometry){const dY=ZX.index,eY=ZX.attributes,fY=eY.position;if(null!==dY){const gY=Math.max(0,aY.start),hY=Math.min(dY.count,aY.start+aY.count);for(let iY=gY,jY=hY;iY<jY;iY++){const kY=dY.getX(iY);SX.fromBufferAttribute(fY,kY),xY(SX,kY,cY,$X,XX,YX,this)}}else{const lY=Math.max(0,aY.start),mY=Math.min(fY.count,aY.start+aY.count);for(let nY=lY,oY=mY;nY<oY;nY++)SX.fromBufferAttribute(fY,nY),xY(SX,nY,cY,$X,XX,YX,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const pY=this.geometry;if(pY.isBufferGeometry){const qY=pY.morphAttributes,rY=Object.keys(qY);if(rY.length>0){const sY=qY[rY[0]];if(void 0!==sY){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let tY=0,uY=sY.length;tY<uY;tY++){const vY=sY[tY].name||String(tY);this.morphTargetInfluences.push(0),this.morphTargetDictionary[vY]=tY}}}}else{const wY=pY.morphTargets;void 0!==wY&&wY.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function xY(a,b,c,d,e,f,g){const h=QX.distanceSqToPoint(a);if(h<c){const i=new nk();QX.closestPointToPoint(a,i),i.applyMatrix4(d);const j=e.ray.origin.distanceTo(i);if(j<e.near||j>e.far)return;f.push({distance:j,distanceToRay:Math.sqrt(h),point:i,index:b,face:null,object:g})}}TX.prototype.isPoints=!0,(class extends df{constructor(yY,zY,AY,BY,CY,DY,EY,FY,GY){super(yY,zY,AY,BY,CY,DY,EY,FY,GY),this.minFilter=void 0!==DY?DY:o,this.magFilter=void 0!==CY?CY:o,this.generateMipmaps=!1;const HY=this;function IY(){HY.needsUpdate=!0,yY.requestVideoFrameCallback(IY)}"requestVideoFrameCallback"in yY&&yY.requestVideoFrameCallback(IY)}clone(){return new this.constructor(this.image).copy(this)}update(){const JY=this.image;!1=="requestVideoFrameCallback"in JY&&JY.readyState>=JY.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}).prototype.isVideoTexture=!0,(class extends df{constructor(KY,LY,MY){super({width:KY,height:LY}),this.format=MY,this.magFilter=l,this.minFilter=l,this.generateMipmaps=!1,this.needsUpdate=!0}}).prototype.isFramebufferTexture=!0,(class extends df{constructor(NY,OY,PY,QY,RY,SY,TY,UY,VY,WY,XY,YY){super(null,SY,TY,UY,VY,WY,QY,RY,XY,YY),this.image={width:OY,height:PY},this.mipmaps=NY,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isCompressedTexture=!0,(class extends df{constructor(ZY,$Y,_Y,aZ,bZ,cZ,dZ,eZ,fZ){super(ZY,$Y,_Y,aZ,bZ,cZ,dZ,eZ,fZ),this.needsUpdate=!0}}).prototype.isCanvasTexture=!0;class gZ extends MC{constructor(hZ=1,iZ=8,jZ=0,kZ=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:hZ,segments:iZ,thetaStart:jZ,thetaLength:kZ},iZ=Math.max(3,iZ);const lZ=[],mZ=[],nZ=[],oZ=[],pZ=new nk(),qZ=new ba();mZ.push(0,0,0),nZ.push(0,0,1),oZ.push(.5,.5);for(let rZ=0,sZ=3;rZ<=iZ;rZ++,sZ+=3){const tZ=jZ+rZ/iZ*kZ;pZ.x=hZ*Math.cos(tZ),pZ.y=hZ*Math.sin(tZ),mZ.push(pZ.x,pZ.y,pZ.z),nZ.push(0,0,1),qZ.x=(mZ[sZ]/hZ+1)/2,qZ.y=(mZ[sZ+1]/hZ+1)/2,oZ.push(qZ.x,qZ.y)}for(let uZ=1;uZ<=iZ;uZ++)lZ.push(uZ,uZ+1,0);this.setIndex(lZ),this.setAttribute("position",new BC(mZ,3)),this.setAttribute("normal",new BC(nZ,3)),this.setAttribute("uv",new BC(oZ,2))}static fromJSON(vZ){return new gZ(vZ.radius,vZ.segments,vZ.thetaStart,vZ.thetaLength)}}class wZ extends MC{constructor(xZ=1,yZ=1,zZ=1,AZ=8,BZ=1,CZ=!1,DZ=0,EZ=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:xZ,radiusBottom:yZ,height:zZ,radialSegments:AZ,heightSegments:BZ,openEnded:CZ,thetaStart:DZ,thetaLength:EZ};const FZ=this;AZ=Math.floor(AZ),BZ=Math.floor(BZ);const GZ=[],HZ=[],IZ=[],JZ=[];let KZ=0;const LZ=[],MZ=zZ/2;let NZ=0;function OZ(a){const b=KZ,c=new ba(),d=new nk();let e=0;const f=!0===a?xZ:yZ,g=!0===a?1:-1;for(let h=1;h<=AZ;h++)HZ.push(0,MZ*g,0),IZ.push(0,g,0),JZ.push(.5,.5),KZ++;const i=KZ;for(let j=0;j<=AZ;j++){const k=j/AZ,l=k*EZ+DZ,m=Math.cos(l),n=Math.sin(l);d.x=f*n,d.y=MZ*g,d.z=f*m,HZ.push(d.x,d.y,d.z),IZ.push(0,g,0),c.x=.5*m+.5,c.y=.5*n*g+.5,JZ.push(c.x,c.y),KZ++}for(let o=0;o<AZ;o++){const p=b+o,q=i+o;!0===a?GZ.push(q,q+1,p):GZ.push(q+1,q,p),e+=3}FZ.addGroup(NZ,e,!0===a?1:2),NZ+=e}(function(){const a=new nk(),b=new nk();let c=0;const d=(yZ-xZ)/zZ;for(let e=0;e<=BZ;e++){const f=[],g=e/BZ,h=g*(yZ-xZ)+xZ;for(let i=0;i<=AZ;i++){const j=i/AZ,k=j*EZ+DZ,l=Math.sin(k),m=Math.cos(k);b.x=h*l,b.y=-g*zZ+MZ,b.z=h*m,HZ.push(b.x,b.y,b.z),a.set(l,d,m).normalize(),IZ.push(a.x,a.y,a.z),JZ.push(j,1-g),f.push(KZ++)}LZ.push(f)}for(let n=0;n<AZ;n++)for(let o=0;o<BZ;o++){const p=LZ[o][n],q=LZ[o+1][n],r=LZ[o+1][n+1],s=LZ[o][n+1];GZ.push(p,q,s),GZ.push(q,r,s),c+=6}FZ.addGroup(NZ,c,0),NZ+=c})(),!1===CZ&&(xZ>0&&OZ(!0),yZ>0&&OZ(!1)),this.setIndex(GZ),this.setAttribute("position",new BC(HZ,3)),this.setAttribute("normal",new BC(IZ,3)),this.setAttribute("uv",new BC(JZ,2))}static fromJSON(PZ){return new wZ(PZ.radiusTop,PZ.radiusBottom,PZ.height,PZ.radialSegments,PZ.heightSegments,PZ.openEnded,PZ.thetaStart,PZ.thetaLength)}}class QZ extends wZ{constructor(RZ=1,SZ=1,TZ=8,UZ=1,VZ=!1,WZ=0,XZ=2*Math.PI){super(0,RZ,SZ,TZ,UZ,VZ,WZ,XZ),this.type="ConeGeometry",this.parameters={radius:RZ,height:SZ,radialSegments:TZ,heightSegments:UZ,openEnded:VZ,thetaStart:WZ,thetaLength:XZ}}static fromJSON(YZ){return new QZ(YZ.radius,YZ.height,YZ.radialSegments,YZ.heightSegments,YZ.openEnded,YZ.thetaStart,YZ.thetaLength)}}class ZZ extends MC{constructor($Z=[],_Z=[],a$=1,b$=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:$Z,indices:_Z,radius:a$,detail:b$};const c$=[],d$=[];function e$(a,b,c,d){const e=d+1,f=[];for(let g=0;g<=e;g++){f[g]=[];const h=a.clone().lerp(c,g/e),i=b.clone().lerp(c,g/e),j=e-g;for(let k=0;k<=j;k++)0===k&&g===e?f[g][k]=h:f[g][k]=h.clone().lerp(i,k/j)}for(let l=0;l<e;l++)for(let m=0;m<2*(e-l)-1;m++){const n=Math.floor(m/2);m%2==0?(f$(f[l][n+1]),f$(f[l+1][n]),f$(f[l][n])):(f$(f[l][n+1]),f$(f[l+1][n+1]),f$(f[l+1][n]))}}function f$(a){c$.push(a.x,a.y,a.z)}function g$(a,b){const c=3*a;b.x=$Z[c+0],b.y=$Z[c+1],b.z=$Z[c+2]}function h$(a,b,c,d){d<0&&1===a.x&&(d$[b]=a.x-1),0===c.x&&0===c.z&&(d$[b]=d/2/Math.PI+.5)}function i$(a){return Math.atan2(a.z,-a.x)}function j$(a){return Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))}(function(a){const b=new nk(),c=new nk(),d=new nk();for(let e=0;e<_Z.length;e+=3)g$(_Z[e+0],b),g$(_Z[e+1],c),g$(_Z[e+2],d),e$(b,c,d,a)})(b$),(function(a){const b=new nk();for(let c=0;c<c$.length;c+=3)b.x=c$[c+0],b.y=c$[c+1],b.z=c$[c+2],b.normalize().multiplyScalar(a),c$[c+0]=b.x,c$[c+1]=b.y,c$[c+2]=b.z})(a$),(function(){const a=new nk();for(let b=0;b<c$.length;b+=3){a.x=c$[b+0],a.y=c$[b+1],a.z=c$[b+2];const c=i$(a)/2/Math.PI+.5,d=j$(a)/Math.PI+.5;d$.push(c,1-d)}(function(){const a=new nk(),b=new nk(),c=new nk(),d=new nk(),e=new ba(),f=new ba(),g=new ba();for(let h=0,i=0;h<c$.length;h+=9,i+=6){a.set(c$[h+0],c$[h+1],c$[h+2]),b.set(c$[h+3],c$[h+4],c$[h+5]),c.set(c$[h+6],c$[h+7],c$[h+8]),e.set(d$[i+0],d$[i+1]),f.set(d$[i+2],d$[i+3]),g.set(d$[i+4],d$[i+5]),d.copy(a).add(b).add(c).divideScalar(3);const j=i$(d);h$(e,i+0,a,j),h$(f,i+2,b,j),h$(g,i+4,c,j)}})(),(function(){for(let a=0;a<d$.length;a+=6){const b=d$[a+0],c=d$[a+2],d=d$[a+4],e=Math.max(b,c,d),f=Math.min(b,c,d);e>.9&&f<.1&&(b<.2&&(d$[a+0]+=1),c<.2&&(d$[a+2]+=1),d<.2&&(d$[a+4]+=1))}})()})(),this.setAttribute("position",new BC(c$,3)),this.setAttribute("normal",new BC(c$.slice(),3)),this.setAttribute("uv",new BC(d$,2)),0===b$?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(k$){return new ZZ(k$.vertices,k$.indices,k$.radius,k$.details)}}class l$ extends ZZ{constructor(m$=1,n$=0){const o$=(1+Math.sqrt(5))/2,p$=1/o$;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-p$,-o$,0,-p$,o$,0,p$,-o$,0,p$,o$,-p$,-o$,0,-p$,o$,0,p$,-o$,0,p$,o$,0,-o$,0,-p$,o$,0,-p$,-o$,0,p$,o$,0,p$],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],m$,n$),this.type="DodecahedronGeometry",this.parameters={radius:m$,detail:n$}}static fromJSON(q$){return new l$(q$.radius,q$.detail)}}const r$=new nk(),s$=new nk(),t$=new nk(),u$=new Vy();class v${constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(w$,x$){const y$=this.getUtoTmapping(w$);return this.getPoint(y$,x$)}getPoints(z$=5){const A$=[];for(let B$=0;B$<=z$;B$++)A$.push(this.getPoint(B$/z$));return A$}getSpacedPoints(C$=5){const D$=[];for(let E$=0;E$<=C$;E$++)D$.push(this.getPointAt(E$/C$));return D$}getLength(){const F$=this.getLengths();return F$[F$.length-1]}getLengths(G$=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===G$+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const H$=[];let I$,J$=this.getPoint(0),K$=0;H$.push(0);for(let L$=1;L$<=G$;L$++)K$+=(I$=this.getPoint(L$/G$)).distanceTo(J$),H$.push(K$),J$=I$;return this.cacheArcLengths=H$,H$}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(M$,N$){const O$=this.getLengths();let P$=0;const Q$=O$.length;let R$;R$=N$||M$*O$[Q$-1];let S$=0,T$=Q$-1,U$;for(;S$<=T$;)if((U$=O$[P$=Math.floor(S$+(T$-S$)/2)]-R$)<0)S$=P$+1;else if(U$>0)T$=P$-1;else{T$=P$;break}if(O$[P$=T$]===R$)return P$/(Q$-1);const V$=O$[P$],W$=O$[P$+1];return(P$+(R$-V$)/(W$-V$))/(Q$-1)}getTangent(X$,Y$){const Z$=1e-4;let $$=X$-Z$,_$=X$+Z$;$$<0&&($$=0),_$>1&&(_$=1);const a_=this.getPoint($$),b_=this.getPoint(_$),c_=Y$||(a_.isVector2?new ba():new nk());return c_.copy(b_).sub(a_).normalize(),c_}getTangentAt(d_,e_){const f_=this.getUtoTmapping(d_);return this.getTangent(f_,e_)}computeFrenetFrames(g_,h_){const i_=new nk(),j_=[],k_=[],l_=[],m_=new nk(),n_=new Hq();for(let o_=0;o_<=g_;o_++){const p_=o_/g_;j_[o_]=this.getTangentAt(p_,new nk())}k_[0]=new nk(),l_[0]=new nk();let q_=Number.MAX_VALUE;const r_=Math.abs(j_[0].x),s_=Math.abs(j_[0].y),t_=Math.abs(j_[0].z);r_<=q_&&(q_=r_,i_.set(1,0,0)),s_<=q_&&(q_=s_,i_.set(0,1,0)),t_<=q_&&i_.set(0,0,1),m_.crossVectors(j_[0],i_).normalize(),k_[0].crossVectors(j_[0],m_),l_[0].crossVectors(j_[0],k_[0]);for(let u_=1;u_<=g_;u_++){if(k_[u_]=k_[u_-1].clone(),l_[u_]=l_[u_-1].clone(),m_.crossVectors(j_[u_-1],j_[u_]),m_.length()>Number.EPSILON){m_.normalize();const v_=Math.acos(W(j_[u_-1].dot(j_[u_]),-1,1));k_[u_].applyMatrix4(n_.makeRotationAxis(m_,v_))}l_[u_].crossVectors(j_[u_],k_[u_])}if(!0===h_){let w_=Math.acos(W(k_[0].dot(k_[g_]),-1,1));w_/=g_,j_[0].dot(m_.crossVectors(k_[0],k_[g_]))>0&&(w_=-w_);for(let x_=1;x_<=g_;x_++)k_[x_].applyMatrix4(n_.makeRotationAxis(j_[x_],w_*x_)),l_[x_].crossVectors(j_[x_],k_[x_])}return{tangents:j_,normals:k_,binormals:l_}}clone(){return new this.constructor().copy(this)}copy(y_){return this.arcLengthDivisions=y_.arcLengthDivisions,this}toJSON(){const z_={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return z_.arcLengthDivisions=this.arcLengthDivisions,z_.type=this.type,z_}fromJSON(A_){return this.arcLengthDivisions=A_.arcLengthDivisions,this}}class B_ extends v${constructor(C_=0,D_=0,E_=1,F_=1,G_=0,H_=2*Math.PI,I_=!1,J_=0){super(),this.type="EllipseCurve",this.aX=C_,this.aY=D_,this.xRadius=E_,this.yRadius=F_,this.aStartAngle=G_,this.aEndAngle=H_,this.aClockwise=I_,this.aRotation=J_}getPoint(K_,L_){const M_=L_||new ba(),N_=2*Math.PI;let O_=this.aEndAngle-this.aStartAngle;const P_=Math.abs(O_)<Number.EPSILON;for(;O_<0;)O_+=N_;for(;O_>N_;)O_-=N_;O_<Number.EPSILON&&(O_=P_?0:N_),!0!==this.aClockwise||P_||(O_===N_?O_=-N_:O_-=N_);const Q_=this.aStartAngle+K_*O_;let R_=this.aX+this.xRadius*Math.cos(Q_),S_=this.aY+this.yRadius*Math.sin(Q_);if(0!==this.aRotation){const T_=Math.cos(this.aRotation),U_=Math.sin(this.aRotation),V_=R_-this.aX,W_=S_-this.aY;R_=V_*T_-W_*U_+this.aX,S_=V_*U_+W_*T_+this.aY}return M_.set(R_,S_)}copy(X_){return super.copy(X_),this.aX=X_.aX,this.aY=X_.aY,this.xRadius=X_.xRadius,this.yRadius=X_.yRadius,this.aStartAngle=X_.aStartAngle,this.aEndAngle=X_.aEndAngle,this.aClockwise=X_.aClockwise,this.aRotation=X_.aRotation,this}toJSON(){const Y_=super.toJSON();return Y_.aX=this.aX,Y_.aY=this.aY,Y_.xRadius=this.xRadius,Y_.yRadius=this.yRadius,Y_.aStartAngle=this.aStartAngle,Y_.aEndAngle=this.aEndAngle,Y_.aClockwise=this.aClockwise,Y_.aRotation=this.aRotation,Y_}fromJSON(Z_){return super.fromJSON(Z_),this.aX=Z_.aX,this.aY=Z_.aY,this.xRadius=Z_.xRadius,this.yRadius=Z_.yRadius,this.aStartAngle=Z_.aStartAngle,this.aEndAngle=Z_.aEndAngle,this.aClockwise=Z_.aClockwise,this.aRotation=Z_.aRotation,this}}B_.prototype.isEllipseCurve=!0;class $_ extends B_{constructor(__,a0,b0,c0,d0,e0){super(__,a0,b0,b0,c0,d0,e0),this.type="ArcCurve"}}function f0(){let a=0,b=0,c=0,d=0;function e(e,f,g,h){a=e,b=g,c=-3*e+3*f-2*g-h,d=2*e-2*f+g+h}return{initCatmullRom:function(a,b,c,d,f){e(b,c,f*(c-a),f*(d-b))},initNonuniformCatmullRom:function(a,b,c,d,f,g,h){let i=(b-a)/f-(c-a)/(f+g)+(c-b)/g,j=(c-b)/g-(d-b)/(g+h)+(d-c)/h;i*=g,j*=g,e(b,c,i,j)},calc:function(e){const f=e*e;return a+b*e+c*f+d*(f*e)}}}$_.prototype.isArcCurve=!0;const g0=new nk(),h0=new f0(),i0=new f0(),j0=new f0();class k0 extends v${constructor(l0=[],m0=!1,n0="centripetal",o0=.5){super(),this.type="CatmullRomCurve3",this.points=l0,this.closed=m0,this.curveType=n0,this.tension=o0}getPoint(p0,q0=new nk()){const r0=q0,s0=this.points,t0=s0.length,u0=(t0-(this.closed?0:1))*p0;let v0=Math.floor(u0),w0=u0-v0;this.closed?v0+=v0>0?0:(Math.floor(Math.abs(v0)/t0)+1)*t0:0===w0&&v0===t0-1&&(v0=t0-2,w0=1);let x0,y0;this.closed||v0>0?x0=s0[(v0-1)%t0]:(g0.subVectors(s0[0],s0[1]).add(s0[0]),x0=g0);const z0=s0[v0%t0],A0=s0[(v0+1)%t0];if(this.closed||v0+2<t0?y0=s0[(v0+2)%t0]:(g0.subVectors(s0[t0-1],s0[t0-2]).add(s0[t0-1]),y0=g0),"centripetal"===this.curveType||"chordal"===this.curveType){const B0="chordal"===this.curveType?.5:.25;let C0=Math.pow(x0.distanceToSquared(z0),B0),D0=Math.pow(z0.distanceToSquared(A0),B0),E0=Math.pow(A0.distanceToSquared(y0),B0);D0<1e-4&&(D0=1),C0<1e-4&&(C0=D0),E0<1e-4&&(E0=D0),h0.initNonuniformCatmullRom(x0.x,z0.x,A0.x,y0.x,C0,D0,E0),i0.initNonuniformCatmullRom(x0.y,z0.y,A0.y,y0.y,C0,D0,E0),j0.initNonuniformCatmullRom(x0.z,z0.z,A0.z,y0.z,C0,D0,E0)}else"catmullrom"===this.curveType&&(h0.initCatmullRom(x0.x,z0.x,A0.x,y0.x,this.tension),i0.initCatmullRom(x0.y,z0.y,A0.y,y0.y,this.tension),j0.initCatmullRom(x0.z,z0.z,A0.z,y0.z,this.tension));return r0.set(h0.calc(w0),i0.calc(w0),j0.calc(w0)),r0}copy(F0){super.copy(F0),this.points=[];for(let G0=0,H0=F0.points.length;G0<H0;G0++){const I0=F0.points[G0];this.points.push(I0.clone())}return this.closed=F0.closed,this.curveType=F0.curveType,this.tension=F0.tension,this}toJSON(){const J0=super.toJSON();J0.points=[];for(let K0=0,L0=this.points.length;K0<L0;K0++){const M0=this.points[K0];J0.points.push(M0.toArray())}return J0.closed=this.closed,J0.curveType=this.curveType,J0.tension=this.tension,J0}fromJSON(N0){super.fromJSON(N0),this.points=[];for(let O0=0,P0=N0.points.length;O0<P0;O0++){const Q0=N0.points[O0];this.points.push(new nk().fromArray(Q0))}return this.closed=N0.closed,this.curveType=N0.curveType,this.tension=N0.tension,this}}function R0(a,b,c,d,e){const f=(d-b)*.5,g=(e-c)*.5,h=a*a;return(2*c-2*d+f+g)*(a*h)+(-3*c+3*d-2*f-g)*h+f*a+c}function S0(a,b,c,d){var e,f;return(function(a,b){const c=1-a;return c*c*b})(a,b)+2*(1-(e=a))*e*c+(f=a)*f*d}function T0(a,b,c,d,e){var f,g;return(function(a,b){const c=1-a;return c*c*c*b})(a,b)+(function(a,b){const c=1-a;return 3*c*c*a*b})(a,c)+3*(1-(f=a))*f*f*d+(g=a)*g*g*e}k0.prototype.isCatmullRomCurve3=!0;class U0 extends v${constructor(V0=new ba(),W0=new ba(),X0=new ba(),Y0=new ba()){super(),this.type="CubicBezierCurve",this.v0=V0,this.v1=W0,this.v2=X0,this.v3=Y0}getPoint(Z0,$0=new ba()){const _0=$0,a1=this.v0,b1=this.v1,c1=this.v2,d1=this.v3;return _0.set(T0(Z0,a1.x,b1.x,c1.x,d1.x),T0(Z0,a1.y,b1.y,c1.y,d1.y)),_0}copy(e1){return super.copy(e1),this.v0.copy(e1.v0),this.v1.copy(e1.v1),this.v2.copy(e1.v2),this.v3.copy(e1.v3),this}toJSON(){const f1=super.toJSON();return f1.v0=this.v0.toArray(),f1.v1=this.v1.toArray(),f1.v2=this.v2.toArray(),f1.v3=this.v3.toArray(),f1}fromJSON(g1){return super.fromJSON(g1),this.v0.fromArray(g1.v0),this.v1.fromArray(g1.v1),this.v2.fromArray(g1.v2),this.v3.fromArray(g1.v3),this}}U0.prototype.isCubicBezierCurve=!0;class h1 extends v${constructor(i1=new nk(),j1=new nk(),k1=new nk(),l1=new nk()){super(),this.type="CubicBezierCurve3",this.v0=i1,this.v1=j1,this.v2=k1,this.v3=l1}getPoint(m1,n1=new nk()){const o1=n1,p1=this.v0,q1=this.v1,r1=this.v2,s1=this.v3;return o1.set(T0(m1,p1.x,q1.x,r1.x,s1.x),T0(m1,p1.y,q1.y,r1.y,s1.y),T0(m1,p1.z,q1.z,r1.z,s1.z)),o1}copy(t1){return super.copy(t1),this.v0.copy(t1.v0),this.v1.copy(t1.v1),this.v2.copy(t1.v2),this.v3.copy(t1.v3),this}toJSON(){const u1=super.toJSON();return u1.v0=this.v0.toArray(),u1.v1=this.v1.toArray(),u1.v2=this.v2.toArray(),u1.v3=this.v3.toArray(),u1}fromJSON(v1){return super.fromJSON(v1),this.v0.fromArray(v1.v0),this.v1.fromArray(v1.v1),this.v2.fromArray(v1.v2),this.v3.fromArray(v1.v3),this}}h1.prototype.isCubicBezierCurve3=!0;class w1 extends v${constructor(x1=new ba(),y1=new ba()){super(),this.type="LineCurve",this.v1=x1,this.v2=y1}getPoint(z1,A1=new ba()){const B1=A1;return 1===z1?B1.copy(this.v2):(B1.copy(this.v2).sub(this.v1),B1.multiplyScalar(z1).add(this.v1)),B1}getPointAt(C1,D1){return this.getPoint(C1,D1)}getTangent(E1,F1){const G1=F1||new ba();return G1.copy(this.v2).sub(this.v1).normalize(),G1}copy(H1){return super.copy(H1),this.v1.copy(H1.v1),this.v2.copy(H1.v2),this}toJSON(){const I1=super.toJSON();return I1.v1=this.v1.toArray(),I1.v2=this.v2.toArray(),I1}fromJSON(J1){return super.fromJSON(J1),this.v1.fromArray(J1.v1),this.v2.fromArray(J1.v2),this}}w1.prototype.isLineCurve=!0;class K1 extends v${constructor(L1=new ba(),M1=new ba(),N1=new ba()){super(),this.type="QuadraticBezierCurve",this.v0=L1,this.v1=M1,this.v2=N1}getPoint(O1,P1=new ba()){const Q1=P1,R1=this.v0,S1=this.v1,T1=this.v2;return Q1.set(S0(O1,R1.x,S1.x,T1.x),S0(O1,R1.y,S1.y,T1.y)),Q1}copy(U1){return super.copy(U1),this.v0.copy(U1.v0),this.v1.copy(U1.v1),this.v2.copy(U1.v2),this}toJSON(){const V1=super.toJSON();return V1.v0=this.v0.toArray(),V1.v1=this.v1.toArray(),V1.v2=this.v2.toArray(),V1}fromJSON(W1){return super.fromJSON(W1),this.v0.fromArray(W1.v0),this.v1.fromArray(W1.v1),this.v2.fromArray(W1.v2),this}}K1.prototype.isQuadraticBezierCurve=!0;class X1 extends v${constructor(Y1=new nk(),Z1=new nk(),$1=new nk()){super(),this.type="QuadraticBezierCurve3",this.v0=Y1,this.v1=Z1,this.v2=$1}getPoint(_1,a2=new nk()){const b2=a2,c2=this.v0,d2=this.v1,e2=this.v2;return b2.set(S0(_1,c2.x,d2.x,e2.x),S0(_1,c2.y,d2.y,e2.y),S0(_1,c2.z,d2.z,e2.z)),b2}copy(f2){return super.copy(f2),this.v0.copy(f2.v0),this.v1.copy(f2.v1),this.v2.copy(f2.v2),this}toJSON(){const g2=super.toJSON();return g2.v0=this.v0.toArray(),g2.v1=this.v1.toArray(),g2.v2=this.v2.toArray(),g2}fromJSON(h2){return super.fromJSON(h2),this.v0.fromArray(h2.v0),this.v1.fromArray(h2.v1),this.v2.fromArray(h2.v2),this}}X1.prototype.isQuadraticBezierCurve3=!0;class i2 extends v${constructor(j2=[]){super(),this.type="SplineCurve",this.points=j2}getPoint(k2,l2=new ba()){const m2=l2,n2=this.points,o2=(n2.length-1)*k2,p2=Math.floor(o2),q2=o2-p2,r2=n2[0===p2?p2:p2-1],s2=n2[p2],t2=n2[p2>n2.length-2?n2.length-1:p2+1],u2=n2[p2>n2.length-3?n2.length-1:p2+2];return m2.set(R0(q2,r2.x,s2.x,t2.x,u2.x),R0(q2,r2.y,s2.y,t2.y,u2.y)),m2}copy(v2){super.copy(v2),this.points=[];for(let w2=0,x2=v2.points.length;w2<x2;w2++){const y2=v2.points[w2];this.points.push(y2.clone())}return this}toJSON(){const z2=super.toJSON();z2.points=[];for(let A2=0,B2=this.points.length;A2<B2;A2++){const C2=this.points[A2];z2.points.push(C2.toArray())}return z2}fromJSON(D2){super.fromJSON(D2),this.points=[];for(let E2=0,F2=D2.points.length;E2<F2;E2++){const G2=D2.points[E2];this.points.push(new ba().fromArray(G2))}return this}}i2.prototype.isSplineCurve=!0;var H2=Object.freeze({__proto__:null,ArcCurve:$_,CatmullRomCurve3:k0,CubicBezierCurve:U0,CubicBezierCurve3:h1,EllipseCurve:B_,LineCurve:w1,LineCurve3:class extends v${constructor(I2=new nk(),J2=new nk()){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=I2,this.v2=J2}getPoint(K2,L2=new nk()){const M2=L2;return 1===K2?M2.copy(this.v2):(M2.copy(this.v2).sub(this.v1),M2.multiplyScalar(K2).add(this.v1)),M2}getPointAt(N2,O2){return this.getPoint(N2,O2)}copy(P2){return super.copy(P2),this.v1.copy(P2.v1),this.v2.copy(P2.v2),this}toJSON(){const Q2=super.toJSON();return Q2.v1=this.v1.toArray(),Q2.v2=this.v2.toArray(),Q2}fromJSON(R2){return super.fromJSON(R2),this.v1.fromArray(R2.v1),this.v2.fromArray(R2.v2),this}},QuadraticBezierCurve:K1,QuadraticBezierCurve3:X1,SplineCurve:i2});class S2 extends v${constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(T2){this.curves.push(T2)}closePath(){const U2=this.curves[0].getPoint(0),V2=this.curves[this.curves.length-1].getPoint(1);U2.equals(V2)||this.curves.push(new w1(V2,U2))}getPoint(W2,X2){const Y2=W2*this.getLength(),Z2=this.getCurveLengths();let $2=0;for(;$2<Z2.length;){if(Z2[$2]>=Y2){const _2=Z2[$2]-Y2,a3=this.curves[$2],b3=a3.getLength(),c3=0===b3?0:1-_2/b3;return a3.getPointAt(c3,X2)}$2++}return null}getLength(){const d3=this.getCurveLengths();return d3[d3.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e3=[];let f3=0;for(let g3=0,h3=this.curves.length;g3<h3;g3++)f3+=this.curves[g3].getLength(),e3.push(f3);return this.cacheLengths=e3,e3}getSpacedPoints(i3=40){const j3=[];for(let k3=0;k3<=i3;k3++)j3.push(this.getPoint(k3/i3));return this.autoClose&&j3.push(j3[0]),j3}getPoints(l3=12){const m3=[];let n3;for(let o3=0,p3=this.curves;o3<p3.length;o3++){const q3=p3[o3],r3=q3&&q3.isEllipseCurve?2*l3:q3&&(q3.isLineCurve||q3.isLineCurve3)?1:q3&&q3.isSplineCurve?l3*q3.points.length:l3,s3=q3.getPoints(r3);for(let t3=0;t3<s3.length;t3++){const u3=s3[t3];n3&&n3.equals(u3)||(m3.push(u3),n3=u3)}}return this.autoClose&&m3.length>1&&!m3[m3.length-1].equals(m3[0])&&m3.push(m3[0]),m3}copy(v3){super.copy(v3),this.curves=[];for(let w3=0,x3=v3.curves.length;w3<x3;w3++){const y3=v3.curves[w3];this.curves.push(y3.clone())}return this.autoClose=v3.autoClose,this}toJSON(){const z3=super.toJSON();z3.autoClose=this.autoClose,z3.curves=[];for(let A3=0,B3=this.curves.length;A3<B3;A3++){const C3=this.curves[A3];z3.curves.push(C3.toJSON())}return z3}fromJSON(D3){super.fromJSON(D3),this.autoClose=D3.autoClose,this.curves=[];for(let E3=0,F3=D3.curves.length;E3<F3;E3++){const G3=D3.curves[E3];this.curves.push(new H2[G3.type]().fromJSON(G3))}return this}}class H3 extends S2{constructor(I3){super(),this.type="Path",this.currentPoint=new ba(),I3&&this.setFromPoints(I3)}setFromPoints(J3){this.moveTo(J3[0].x,J3[0].y);for(let K3=1,L3=J3.length;K3<L3;K3++)this.lineTo(J3[K3].x,J3[K3].y);return this}moveTo(M3,N3){return this.currentPoint.set(M3,N3),this}lineTo(O3,P3){const Q3=new w1(this.currentPoint.clone(),new ba(O3,P3));return this.curves.push(Q3),this.currentPoint.set(O3,P3),this}quadraticCurveTo(R3,S3,T3,U3){const V3=new K1(this.currentPoint.clone(),new ba(R3,S3),new ba(T3,U3));return this.curves.push(V3),this.currentPoint.set(T3,U3),this}bezierCurveTo(W3,X3,Y3,Z3,$3,_3){const a4=new U0(this.currentPoint.clone(),new ba(W3,X3),new ba(Y3,Z3),new ba($3,_3));return this.curves.push(a4),this.currentPoint.set($3,_3),this}splineThru(b4){const c4=[this.currentPoint.clone()].concat(b4),d4=new i2(c4);return this.curves.push(d4),this.currentPoint.copy(b4[b4.length-1]),this}arc(e4,f4,g4,h4,i4,j4){const k4=this.currentPoint.x,l4=this.currentPoint.y;return this.absarc(e4+k4,f4+l4,g4,h4,i4,j4),this}absarc(m4,n4,o4,p4,q4,r4){return this.absellipse(m4,n4,o4,o4,p4,q4,r4),this}ellipse(s4,t4,u4,v4,w4,x4,y4,z4){const A4=this.currentPoint.x,B4=this.currentPoint.y;return this.absellipse(s4+A4,t4+B4,u4,v4,w4,x4,y4,z4),this}absellipse(C4,D4,E4,F4,G4,H4,I4,J4){const K4=new B_(C4,D4,E4,F4,G4,H4,I4,J4);if(this.curves.length>0){const L4=K4.getPoint(0);L4.equals(this.currentPoint)||this.lineTo(L4.x,L4.y)}this.curves.push(K4);const M4=K4.getPoint(1);return this.currentPoint.copy(M4),this}copy(N4){return super.copy(N4),this.currentPoint.copy(N4.currentPoint),this}toJSON(){const O4=super.toJSON();return O4.currentPoint=this.currentPoint.toArray(),O4}fromJSON(P4){return super.fromJSON(P4),this.currentPoint.fromArray(P4.currentPoint),this}}class Q4 extends H3{constructor(R4){super(R4),this.uuid=V(),this.type="Shape",this.holes=[]}getPointsHoles(S4){const T4=[];for(let U4=0,V4=this.holes.length;U4<V4;U4++)T4[U4]=this.holes[U4].getPoints(S4);return T4}extractPoints(W4){return{shape:this.getPoints(W4),holes:this.getPointsHoles(W4)}}copy(X4){super.copy(X4),this.holes=[];for(let Y4=0,Z4=X4.holes.length;Y4<Z4;Y4++){const $4=X4.holes[Y4];this.holes.push($4.clone())}return this}toJSON(){const _4=super.toJSON();_4.uuid=this.uuid,_4.holes=[];for(let a5=0,b5=this.holes.length;a5<b5;a5++){const c5=this.holes[a5];_4.holes.push(c5.toJSON())}return _4}fromJSON(d5){super.fromJSON(d5),this.uuid=d5.uuid,this.holes=[];for(let e5=0,f5=d5.holes.length;e5<f5;e5++){const g5=d5.holes[e5];this.holes.push(new H3().fromJSON(g5))}return this}}const h5={triangulate:function(a,b,c=2){const d=b&&b.length,e=d?b[0]*c:a.length;let f=i5(a,0,e,c,!0);const g=[];if(!f||f.next===f.prev)return g;let h,i,j,k,l,m,n;if(d&&(f=p5(a,b,f,c)),a.length>80*c){h=j=a[0],i=k=a[1];for(let o=c;o<e;o+=c)l=a[o],m=a[o+1],l<h&&(h=l),m<i&&(i=m),l>j&&(j=l),m>k&&(k=m);n=0!==(n=Math.max(j-h,k-i))?1/n:0}return k5(f,g,c,h,i,n),g}};function i5(a,b,c,d,e){let f,g;if(e===M5(a,b,c,d)>0)for(f=b;f<c;f+=d)g=J5(f,a[f],a[f+1],g);else for(f=c-d;f>=b;f-=d)g=J5(f,a[f],a[f+1],g);return g&&B5(g,g.next)&&(K5(g),g=g.next),g}function j5(a,b){if(!a)return a;b||(b=a);let c=a,d;do if(d=!1,!c.steiner&&(B5(c,c.next)||0===A5(c.prev,c,c.next))){if(K5(c),(c=b=c.prev)===c.next)break;d=!0}else c=c.next;while(d||c!==b);return b}function k5(a,b,c,d,e,f,g){if(!a)return;!g&&f&&u5(a,d,e,f);let h=a,i,j;for(;a.prev!==a.next;){if(i=a.prev,j=a.next,f?m5(a,d,e,f):l5(a)){b.push(i.i/c),b.push(a.i/c),b.push(j.i/c),K5(a),a=j.next,h=j.next;continue}if((a=j)===h){g?1===g?k5(a=n5(j5(a),b,c),b,c,d,e,f,2):2===g&&o5(a,b,c,d,e,f):k5(j5(a),b,c,d,e,f,1);break}}}function l5(a){const b=a.prev,c=a,d=a.next;if(A5(b,c,d)>=0)return!1;let e=a.next.next;for(;e!==a.prev;){if(y5(b.x,b.y,c.x,c.y,d.x,d.y,e.x,e.y)&&A5(e.prev,e,e.next)>=0)return!1;e=e.next}return!0}function m5(a,b,c,d){const e=a.prev,f=a,g=a.next;if(A5(e,f,g)>=0)return!1;const h=e.x<f.x?e.x<g.x?e.x:g.x:f.x<g.x?f.x:g.x,i=e.y<f.y?e.y<g.y?e.y:g.y:f.y<g.y?f.y:g.y,j=e.x>f.x?e.x>g.x?e.x:g.x:f.x>g.x?f.x:g.x,k=e.y>f.y?e.y>g.y?e.y:g.y:f.y>g.y?f.y:g.y,l=w5(h,i,b,c,d),m=w5(j,k,b,c,d);let n=a.prevZ,o=a.nextZ;for(;n&&n.z>=l&&o&&o.z<=m;){if(n!==a.prev&&n!==a.next&&y5(e.x,e.y,f.x,f.y,g.x,g.y,n.x,n.y)&&A5(n.prev,n,n.next)>=0)return!1;if(n=n.prevZ,o!==a.prev&&o!==a.next&&y5(e.x,e.y,f.x,f.y,g.x,g.y,o.x,o.y)&&A5(o.prev,o,o.next)>=0)return!1;o=o.nextZ}for(;n&&n.z>=l;){if(n!==a.prev&&n!==a.next&&y5(e.x,e.y,f.x,f.y,g.x,g.y,n.x,n.y)&&A5(n.prev,n,n.next)>=0)return!1;n=n.prevZ}for(;o&&o.z<=m;){if(o!==a.prev&&o!==a.next&&y5(e.x,e.y,f.x,f.y,g.x,g.y,o.x,o.y)&&A5(o.prev,o,o.next)>=0)return!1;o=o.nextZ}return!0}function n5(a,b,c){let d=a;do{const e=d.prev,f=d.next.next;!B5(e,f)&&C5(e,d,d.next,f)&&G5(e,f)&&G5(f,e)&&(b.push(e.i/c),b.push(d.i/c),b.push(f.i/c),K5(d),K5(d.next),d=a=f),d=d.next}while(d!==a);return j5(d)}function o5(a,b,c,d,e,f){let g=a;do{let h=g.next.next;for(;h!==g.prev;){if(g.i!==h.i&&z5(g,h)){let i=I5(g,h);g=j5(g,g.next),i=j5(i,i.next),k5(g,b,c,d,e,f),k5(i,b,c,d,e,f);return}h=h.next}g=g.next}while(g!==a)}function p5(a,b,c,d){const e=[];let f,g,h,i,j;for(f=0,g=b.length;f<g;f++)h=b[f]*d,i=f<g-1?b[f+1]*d:a.length,j=i5(a,h,i,d,!1),j===j.next&&(j.steiner=!0),e.push(x5(j));for(e.sort(q5),f=0;f<e.length;f++)r5(e[f],c),c=j5(c,c.next);return c}function q5(a,b){return a.x-b.x}function r5(a,b){if(b=s5(a,b)){const c=I5(b,a);j5(b,b.next),j5(c,c.next)}}function s5(a,b){let c=b;const d=a.x,e=a.y;let f=-1/0,g;do{if(e<=c.y&&e>=c.next.y&&c.next.y!==c.y){const h=c.x+(e-c.y)*(c.next.x-c.x)/(c.next.y-c.y);if(h<=d&&h>f){if(f=h,h===d){if(e===c.y)return c;if(e===c.next.y)return c.next}g=c.x<c.next.x?c:c.next}}c=c.next}while(c!==b);if(!g)return null;if(d===f)return g;const i=g,j=g.x,k=g.y;let l=1/0,m;c=g;do d>=c.x&&c.x>=j&&d!==c.x&&y5(e<k?d:f,e,j,k,e<k?f:d,e,c.x,c.y)&&(m=Math.abs(e-c.y)/(d-c.x),G5(c,a)&&(m<l||m===l&&(c.x>g.x||c.x===g.x&&t5(g,c)))&&(g=c,l=m)),c=c.next;while(c!==i);return g}function t5(a,b){return 0>A5(a.prev,a,b.prev)&&0>A5(b.next,a,a.next)}function u5(a,b,c,d){let e=a;do null===e.z&&(e.z=w5(e.x,e.y,b,c,d)),e.prevZ=e.prev,e.nextZ=e.next,e=e.next;while(e!==a);e.prevZ.nextZ=null,e.prevZ=null,v5(e)}function v5(a){let b,c,d,e,f,g,h,i,j=1;do{for(c=a,a=null,f=null,g=0;c;){for(g++,d=c,h=0,b=0;b<j&&(h++,d=d.nextZ);b++);for(i=j;h>0||i>0&&d;)0!==h&&(0===i||!d||c.z<=d.z)?(e=c,c=c.nextZ,h--):(e=d,d=d.nextZ,i--),f?f.nextZ=e:a=e,e.prevZ=f,f=e;c=d}f.nextZ=null,j*=2}while(g>1);return a}function w5(a,b,c,d,e){return a=32767*(a-c)*e,b=32767*(b-d)*e,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,b=(b|b<<8)&16711935,b=(b|b<<4)&252645135,b=(b|b<<2)&858993459,b=(b|b<<1)&1431655765,a|b<<1}function x5(a){let b=a,c=a;do(b.x<c.x||b.x===c.x&&b.y<c.y)&&(c=b),b=b.next;while(b!==a);return c}function y5(a,b,c,d,e,f,g,h){return(e-g)*(b-h)-(a-g)*(f-h)>=0&&(a-g)*(d-h)-(c-g)*(b-h)>=0&&(c-g)*(f-h)-(e-g)*(d-h)>=0}function z5(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!F5(a,b)&&(G5(a,b)&&G5(b,a)&&H5(a,b)&&(A5(a.prev,a,b.prev)||A5(a,b.prev,b))||B5(a,b)&&A5(a.prev,a,a.next)>0&&A5(b.prev,b,b.next)>0)}function A5(a,b,c){return(b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y)}function B5(a,b){return a.x===b.x&&a.y===b.y}function C5(a,b,c,d){const e=E5(A5(a,b,c)),f=E5(A5(a,b,d)),g=E5(A5(c,d,a)),h=E5(A5(c,d,b));return e!==f&&g!==h|| !!(0===e&&D5(a,c,b))|| !!(0===f&&D5(a,d,b))|| !!(0===g&&D5(c,a,d))||!!(0===h&&D5(c,b,d))}function D5(a,b,c){return b.x<=Math.max(a.x,c.x)&&b.x>=Math.min(a.x,c.x)&&b.y<=Math.max(a.y,c.y)&&b.y>=Math.min(a.y,c.y)}function E5(a){return a>0?1:a<0?-1:0}function F5(a,b){let c=a;do{if(c.i!==a.i&&c.next.i!==a.i&&c.i!==b.i&&c.next.i!==b.i&&C5(c,c.next,a,b))return!0;c=c.next}while(c!==a);return!1}function G5(a,b){return 0>A5(a.prev,a,a.next)?A5(a,b,a.next)>=0&&A5(a,a.prev,b)>=0:0>A5(a,b,a.prev)||0>A5(a,a.next,b)}function H5(a,b){let c=a,d=!1;const e=(a.x+b.x)/2,f=(a.y+b.y)/2;do c.y>f!=c.next.y>f&&c.next.y!==c.y&&e<(c.next.x-c.x)*(f-c.y)/(c.next.y-c.y)+c.x&&(d=!d),c=c.next;while(c!==a);return d}function I5(a,b){const c=new L5(a.i,a.x,a.y),d=new L5(b.i,b.x,b.y),e=a.next,f=b.prev;return a.next=b,b.prev=a,c.next=e,e.prev=c,d.next=c,c.prev=d,f.next=d,d.prev=f,d}function J5(a,b,c,d){const e=new L5(a,b,c);return d?(e.next=d.next,e.prev=d,d.next.prev=e,d.next=e):(e.prev=e,e.next=e),e}function K5(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function L5(a,b,c){this.i=a,this.x=b,this.y=c,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function M5(a,b,c,d){let e=0;for(let f=b,g=c-d;f<c;f+=d)e+=(a[g]-a[f])*(a[f+1]+a[g+1]),g=f;return e}class N5{static area(O5){const P5=O5.length;let Q5=0;for(let R5=P5-1,S5=0;S5<P5;R5=S5++)Q5+=O5[R5].x*O5[S5].y-O5[S5].x*O5[R5].y;return .5*Q5}static isClockWise(T5){return 0>N5.area(T5)}static triangulateShape(U5,V5){const W5=[],X5=[],Y5=[];b6(U5),c6(W5,U5);let Z5=U5.length;V5.forEach(b6);for(let $5=0;$5<V5.length;$5++)X5.push(Z5),Z5+=V5[$5].length,c6(W5,V5[$5]);const _5=h5.triangulate(W5,X5);for(let a6=0;a6<_5.length;a6+=3)Y5.push(_5.slice(a6,a6+3));return Y5}}function b6(a){const b=a.length;b>2&&a[b-1].equals(a[0])&&a.pop()}function c6(a,b){for(let c=0;c<b.length;c++)a.push(b[c].x),a.push(b[c].y)}class d6 extends MC{constructor(e6=new Q4([new ba(.5,.5),new ba(-0.5,.5),new ba(-0.5,-0.5),new ba(.5,-0.5)]),f6={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e6,options:f6},e6=Array.isArray(e6)?e6:[e6];const g6=this,h6=[],i6=[];for(let j6=0,k6=e6.length;j6<k6;j6++){const l6=e6[j6];m6(l6)}function m6(a){const b=[],c=void 0!==f6.curveSegments?f6.curveSegments:12,d=void 0!==f6.steps?f6.steps:1;let e=void 0!==f6.depth?f6.depth:1,f=void 0===f6.bevelEnabled||f6.bevelEnabled,g=void 0!==f6.bevelThickness?f6.bevelThickness:.2,h=void 0!==f6.bevelSize?f6.bevelSize:g-.1,i=void 0!==f6.bevelOffset?f6.bevelOffset:0,j=void 0!==f6.bevelSegments?f6.bevelSegments:3;const k=f6.extrudePath,l=void 0!==f6.UVGenerator?f6.UVGenerator:x6;void 0!==f6.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),e=f6.amount);let m,n=!1,o,p,q,r;k&&(m=k.getSpacedPoints(d),n=!0,f=!1,o=k.computeFrenetFrames(d,!1),p=new nk(),q=new nk(),r=new nk()),f||(j=0,g=0,h=0,i=0);const s=a.extractPoints(c);let t=s.shape;const u=s.holes,v=!N5.isClockWise(t);if(v){t=t.reverse();for(let w=0,x=u.length;w<x;w++){const y=u[w];N5.isClockWise(y)&&(u[w]=y.reverse())}}const z=N5.triangulateShape(t,u),A=t;for(let B=0,C=u.length;B<C;B++){const D=u[B];t=t.concat(D)}function E(a,b,c){return b||console.error("THREE.ExtrudeGeometry: vec does not exist"),b.clone().multiplyScalar(c).add(a)}const F=t.length,G=z.length;function H(a,b,c){let d,e,f;const g=a.x-b.x,h=a.y-b.y,i=c.x-a.x,j=c.y-a.y,k=g*g+h*h,l=g*j-h*i;if(Math.abs(l)>Number.EPSILON){const m=Math.sqrt(k),n=Math.sqrt(i*i+j*j),o=b.x-h/m,p=b.y+g/m,q=c.x-j/n,r=c.y+i/n,s=((q-o)*j-(r-p)*i)/(g*j-h*i);d=o+g*s-a.x,e=p+h*s-a.y;const t=d*d+e*e;if(t<=2)return new ba(d,e);f=Math.sqrt(t/2)}else{let u=!1;g>Number.EPSILON?i>Number.EPSILON&&(u=!0):g< -Number.EPSILON?i< -Number.EPSILON&&(u=!0):Math.sign(h)===Math.sign(j)&&(u=!0),u?(d=-h,e=g,f=Math.sqrt(k)):(d=g,e=h,f=Math.sqrt(k/2))}return new ba(d/f,e/f)}const I=[];for(let J=0,K=A.length,L=K-1,M=J+1;J<K;J++,L++,M++)L===K&&(L=0),M===K&&(M=0),I[J]=H(A[J],A[L],A[M]);const N=[];let O,P=I.concat();for(let Q=0,R=u.length;Q<R;Q++){const S=u[Q];O=[];for(let T=0,U=S.length,V=U-1,W=T+1;T<U;T++,V++,W++)V===U&&(V=0),W===U&&(W=0),O[T]=H(S[T],S[V],S[W]);N.push(O),P=P.concat(O)}for(let X=0;X<j;X++){const Y=X/j,Z=g*Math.cos(Y*Math.PI/2),$=h*Math.sin(Y*Math.PI/2)+i;for(let _=0,aa=A.length;_<aa;_++){const ca=E(A[_],I[_],$);Da(ca.x,ca.y,-Z)}for(let da=0,ea=u.length;da<ea;da++){const fa=u[da];O=N[da];for(let ga=0,ha=fa.length;ga<ha;ga++){const ia=E(fa[ga],O[ga],$);Da(ia.x,ia.y,-Z)}}}const ja=h+i;for(let ka=0;ka<F;ka++){const la=f?E(t[ka],P[ka],ja):t[ka];n?(q.copy(o.normals[0]).multiplyScalar(la.x),p.copy(o.binormals[0]).multiplyScalar(la.y),r.copy(m[0]).add(q).add(p),Da(r.x,r.y,r.z)):Da(la.x,la.y,0)}for(let ma=1;ma<=d;ma++)for(let na=0;na<F;na++){const oa=f?E(t[na],P[na],ja):t[na];n?(q.copy(o.normals[ma]).multiplyScalar(oa.x),p.copy(o.binormals[ma]).multiplyScalar(oa.y),r.copy(m[ma]).add(q).add(p),Da(r.x,r.y,r.z)):Da(oa.x,oa.y,e/d*ma)}for(let pa=j-1;pa>=0;pa--){const qa=pa/j,ra=g*Math.cos(qa*Math.PI/2),sa=h*Math.sin(qa*Math.PI/2)+i;for(let ta=0,ua=A.length;ta<ua;ta++){const va=E(A[ta],I[ta],sa);Da(va.x,va.y,e+ra)}for(let wa=0,xa=u.length;wa<xa;wa++){const ya=u[wa];O=N[wa];for(let za=0,Aa=ya.length;za<Aa;za++){const Ba=E(ya[za],O[za],sa);n?Da(Ba.x,Ba.y+m[d-1].y,m[d-1].x+ra):Da(Ba.x,Ba.y,e+ra)}}}function Ca(a,b){let c=a.length;for(;--c>=0;){const e=c;let f=c-1;f<0&&(f=a.length-1);for(let g=0,h=d+2*j;g<h;g++){const i=F*g,k=F*(g+1),l=b+e+i,m=b+f+i,n=b+f+k,o=b+e+k;Fa(l,m,n,o)}}}function Da(a,c,d){b.push(a),b.push(c),b.push(d)}function Ea(a,b,c){Ga(a),Ga(b),Ga(c);const d=h6.length/3,e=l.generateTopUV(g6,h6,d-3,d-2,d-1);Ha(e[0]),Ha(e[1]),Ha(e[2])}function Fa(a,b,c,d){Ga(a),Ga(b),Ga(d),Ga(b),Ga(c),Ga(d);const e=h6.length/3,f=l.generateSideWallUV(g6,h6,e-6,e-3,e-2,e-1);Ha(f[0]),Ha(f[1]),Ha(f[3]),Ha(f[1]),Ha(f[2]),Ha(f[3])}function Ga(a){h6.push(b[3*a+0]),h6.push(b[3*a+1]),h6.push(b[3*a+2])}function Ha(a){i6.push(a.x),i6.push(a.y)}(function(){const a=h6.length/3;if(f){let b=0,c=F*b;for(let e=0;e<G;e++){const g=z[e];Ea(g[2]+c,g[1]+c,g[0]+c)}c=F*(b=d+2*j);for(let h=0;h<G;h++){const i=z[h];Ea(i[0]+c,i[1]+c,i[2]+c)}}else{for(let k=0;k<G;k++){const l=z[k];Ea(l[2],l[1],l[0])}for(let m=0;m<G;m++){const n=z[m];Ea(n[0]+F*d,n[1]+F*d,n[2]+F*d)}}g6.addGroup(a,h6.length/3-a,0)})(),(function(){const a=h6.length/3;let b=0;Ca(A,b),b+=A.length;for(let c=0,d=u.length;c<d;c++){const e=u[c];Ca(e,b),b+=e.length}g6.addGroup(a,h6.length/3-a,1)})()}this.setAttribute("position",new BC(h6,3)),this.setAttribute("uv",new BC(i6,2)),this.computeVertexNormals()}toJSON(){const n6=super.toJSON(),o6=this.parameters.shapes,p6=this.parameters.options;return y6(o6,p6,n6)}static fromJSON(q6,r6){const s6=[];for(let t6=0,u6=q6.shapes.length;t6<u6;t6++){const v6=r6[q6.shapes[t6]];s6.push(v6)}const w6=q6.options.extrudePath;return void 0!==w6&&(q6.options.extrudePath=new H2[w6.type]().fromJSON(w6)),new d6(s6,q6.options)}}const x6={generateTopUV:function(a,b,c,d,e){const f=b[3*c],g=b[3*c+1],h=b[3*d],i=b[3*d+1],j=b[3*e],k=b[3*e+1];return[new ba(f,g),new ba(h,i),new ba(j,k)]},generateSideWallUV:function(a,b,c,d,e,f){const g=b[3*c],h=b[3*c+1],i=b[3*c+2],j=b[3*d],k=b[3*d+1],l=b[3*d+2],m=b[3*e],n=b[3*e+1],o=b[3*e+2],p=b[3*f],q=b[3*f+1],r=b[3*f+2];return Math.abs(h-k)<Math.abs(g-j)?[new ba(g,1-i),new ba(j,1-l),new ba(m,1-o),new ba(p,1-r)]:[new ba(h,1-i),new ba(k,1-l),new ba(n,1-o),new ba(q,1-r)]}};function y6(a,b,c){if(c.shapes=[],Array.isArray(a))for(let d=0,e=a.length;d<e;d++){const f=a[d];c.shapes.push(f.uuid)}else c.shapes.push(a.uuid);return void 0!==b.extrudePath&&(c.options.extrudePath=b.extrudePath.toJSON()),c}class z6 extends ZZ{constructor(A6=1,B6=0){const C6=(1+Math.sqrt(5))/2;super([-1,C6,0,1,C6,0,-1,-C6,0,1,-C6,0,0,-1,C6,0,1,C6,0,-1,-C6,0,1,-C6,C6,0,-1,C6,0,1,-C6,0,-1,-C6,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],A6,B6),this.type="IcosahedronGeometry",this.parameters={radius:A6,detail:B6}}static fromJSON(D6){return new z6(D6.radius,D6.detail)}}class E6 extends MC{constructor(F6=[new ba(0,.5),new ba(.5,0),new ba(0,-0.5)],G6=12,H6=0,I6=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:F6,segments:G6,phiStart:H6,phiLength:I6},G6=Math.floor(G6),I6=W(I6,0,2*Math.PI);const J6=[],K6=[],L6=[],M6=[],N6=[],O6=1/G6,P6=new nk(),Q6=new ba(),R6=new nk(),S6=new nk(),T6=new nk();let U6=0,V6=0;for(let W6=0;W6<=F6.length-1;W6++)switch(W6){case 0:U6=F6[W6+1].x-F6[W6].x,V6=F6[W6+1].y-F6[W6].y,R6.x=1*V6,R6.y=-U6,R6.z=0*V6,T6.copy(R6),R6.normalize(),M6.push(R6.x,R6.y,R6.z);break;case F6.length-1:M6.push(T6.x,T6.y,T6.z);break;default:U6=F6[W6+1].x-F6[W6].x,V6=F6[W6+1].y-F6[W6].y,R6.x=1*V6,R6.y=-U6,R6.z=0*V6,S6.copy(R6),R6.x+=T6.x,R6.y+=T6.y,R6.z+=T6.z,R6.normalize(),M6.push(R6.x,R6.y,R6.z),T6.copy(S6)}for(let X6=0;X6<=G6;X6++){const Y6=H6+X6*O6*I6,Z6=Math.sin(Y6),$6=Math.cos(Y6);for(let _6=0;_6<=F6.length-1;_6++){P6.x=F6[_6].x*Z6,P6.y=F6[_6].y,P6.z=F6[_6].x*$6,K6.push(P6.x,P6.y,P6.z),Q6.x=X6/G6,Q6.y=_6/(F6.length-1),L6.push(Q6.x,Q6.y);const a7=M6[3*_6+0]*Z6,b7=M6[3*_6+1],c7=M6[3*_6+0]*$6;N6.push(a7,b7,c7)}}for(let d7=0;d7<G6;d7++)for(let e7=0;e7<F6.length-1;e7++){const f7=e7+d7*F6.length,g7=f7,h7=f7+F6.length,i7=f7+F6.length+1,j7=f7+1;J6.push(g7,h7,j7),J6.push(i7,j7,h7)}this.setIndex(J6),this.setAttribute("position",new BC(K6,3)),this.setAttribute("uv",new BC(L6,2)),this.setAttribute("normal",new BC(N6,3))}static fromJSON(k7){return new E6(k7.points,k7.segments,k7.phiStart,k7.phiLength)}}class l7 extends ZZ{constructor(m7=1,n7=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],m7,n7),this.type="OctahedronGeometry",this.parameters={radius:m7,detail:n7}}static fromJSON(o7){return new l7(o7.radius,o7.detail)}}class p7 extends MC{constructor(q7=.5,r7=1,s7=8,t7=1,u7=0,v7=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:q7,outerRadius:r7,thetaSegments:s7,phiSegments:t7,thetaStart:u7,thetaLength:v7},s7=Math.max(3,s7),t7=Math.max(1,t7);const w7=[],x7=[],y7=[],z7=[];let A7=q7;const B7=(r7-q7)/t7,C7=new nk(),D7=new ba();for(let E7=0;E7<=t7;E7++){for(let F7=0;F7<=s7;F7++){const G7=u7+F7/s7*v7;C7.x=A7*Math.cos(G7),C7.y=A7*Math.sin(G7),x7.push(C7.x,C7.y,C7.z),y7.push(0,0,1),D7.x=(C7.x/r7+1)/2,D7.y=(C7.y/r7+1)/2,z7.push(D7.x,D7.y)}A7+=B7}for(let H7=0;H7<t7;H7++){const I7=H7*(s7+1);for(let J7=0;J7<s7;J7++){const K7=J7+I7,L7=K7,M7=K7+s7+1,N7=K7+s7+2,O7=K7+1;w7.push(L7,M7,O7),w7.push(M7,N7,O7)}}this.setIndex(w7),this.setAttribute("position",new BC(x7,3)),this.setAttribute("normal",new BC(y7,3)),this.setAttribute("uv",new BC(z7,2))}static fromJSON(P7){return new p7(P7.innerRadius,P7.outerRadius,P7.thetaSegments,P7.phiSegments,P7.thetaStart,P7.thetaLength)}}class Q7 extends MC{constructor(R7=new Q4([new ba(0,.5),new ba(-0.5,-0.5),new ba(.5,-0.5)]),S7=12){super(),this.type="ShapeGeometry",this.parameters={shapes:R7,curveSegments:S7};const T7=[],U7=[],V7=[],W7=[];let X7=0,Y7=0;if(!1===Array.isArray(R7))$7(R7);else for(let Z7=0;Z7<R7.length;Z7++)$7(R7[Z7]),this.addGroup(X7,Y7,Z7),X7+=Y7,Y7=0;function $7(a){const b=U7.length/3,c=a.extractPoints(S7);let d=c.shape;const e=c.holes;!1===N5.isClockWise(d)&&(d=d.reverse());for(let f=0,g=e.length;f<g;f++){const h=e[f];!0===N5.isClockWise(h)&&(e[f]=h.reverse())}const i=N5.triangulateShape(d,e);for(let j=0,k=e.length;j<k;j++){const l=e[j];d=d.concat(l)}for(let m=0,n=d.length;m<n;m++){const o=d[m];U7.push(o.x,o.y,0),V7.push(0,0,1),W7.push(o.x,o.y)}for(let p=0,q=i.length;p<q;p++){const r=i[p],s=r[0]+b,t=r[1]+b,u=r[2]+b;T7.push(s,t,u),Y7+=3}}this.setIndex(T7),this.setAttribute("position",new BC(U7,3)),this.setAttribute("normal",new BC(V7,3)),this.setAttribute("uv",new BC(W7,2))}toJSON(){const _7=super.toJSON(),a8=this.parameters.shapes;return h8(a8,_7)}static fromJSON(b8,c8){const d8=[];for(let e8=0,f8=b8.shapes.length;e8<f8;e8++){const g8=c8[b8.shapes[e8]];d8.push(g8)}return new Q7(d8,b8.curveSegments)}}function h8(a,b){if(b.shapes=[],Array.isArray(a))for(let c=0,d=a.length;c<d;c++){const e=a[c];b.shapes.push(e.uuid)}else b.shapes.push(a.uuid);return b}class i8 extends MC{constructor(j8=1,k8=32,l8=16,m8=0,n8=2*Math.PI,o8=0,p8=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:j8,widthSegments:k8,heightSegments:l8,phiStart:m8,phiLength:n8,thetaStart:o8,thetaLength:p8},k8=Math.max(3,Math.floor(k8)),l8=Math.max(2,Math.floor(l8));const q8=Math.min(o8+p8,Math.PI);let r8=0;const s8=[],t8=new nk(),u8=new nk(),v8=[],w8=[],x8=[],y8=[];for(let z8=0;z8<=l8;z8++){const A8=[],B8=z8/l8;let C8=0;0==z8&&0==o8?C8=.5/k8:z8==l8&&q8==Math.PI&&(C8=-0.5/k8);for(let D8=0;D8<=k8;D8++){const E8=D8/k8;t8.x=-j8*Math.cos(m8+E8*n8)*Math.sin(o8+B8*p8),t8.y=j8*Math.cos(o8+B8*p8),t8.z=j8*Math.sin(m8+E8*n8)*Math.sin(o8+B8*p8),w8.push(t8.x,t8.y,t8.z),u8.copy(t8).normalize(),x8.push(u8.x,u8.y,u8.z),y8.push(E8+C8,1-B8),A8.push(r8++)}s8.push(A8)}for(let F8=0;F8<l8;F8++)for(let G8=0;G8<k8;G8++){const H8=s8[F8][G8+1],I8=s8[F8][G8],J8=s8[F8+1][G8],K8=s8[F8+1][G8+1];(0!==F8||o8>0)&&v8.push(H8,I8,K8),(F8!==l8-1||q8<Math.PI)&&v8.push(I8,J8,K8)}this.setIndex(v8),this.setAttribute("position",new BC(w8,3)),this.setAttribute("normal",new BC(x8,3)),this.setAttribute("uv",new BC(y8,2))}static fromJSON(L8){return new i8(L8.radius,L8.widthSegments,L8.heightSegments,L8.phiStart,L8.phiLength,L8.thetaStart,L8.thetaLength)}}class M8 extends ZZ{constructor(N8=1,O8=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],N8,O8),this.type="TetrahedronGeometry",this.parameters={radius:N8,detail:O8}}static fromJSON(P8){return new M8(P8.radius,P8.detail)}}class Q8 extends MC{constructor(R8=1,S8=.4,T8=8,U8=6,V8=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:R8,tube:S8,radialSegments:T8,tubularSegments:U8,arc:V8},T8=Math.floor(T8),U8=Math.floor(U8);const W8=[],X8=[],Y8=[],Z8=[],$8=new nk(),_8=new nk(),a9=new nk();for(let b9=0;b9<=T8;b9++)for(let c9=0;c9<=U8;c9++){const d9=c9/U8*V8,e9=b9/T8*Math.PI*2;_8.x=(R8+S8*Math.cos(e9))*Math.cos(d9),_8.y=(R8+S8*Math.cos(e9))*Math.sin(d9),_8.z=S8*Math.sin(e9),X8.push(_8.x,_8.y,_8.z),$8.x=R8*Math.cos(d9),$8.y=R8*Math.sin(d9),a9.subVectors(_8,$8).normalize(),Y8.push(a9.x,a9.y,a9.z),Z8.push(c9/U8),Z8.push(b9/T8)}for(let f9=1;f9<=T8;f9++)for(let g9=1;g9<=U8;g9++){const h9=(U8+1)*f9+g9-1,i9=(U8+1)*(f9-1)+g9-1,j9=(U8+1)*(f9-1)+g9,k9=(U8+1)*f9+g9;W8.push(h9,i9,k9),W8.push(i9,j9,k9)}this.setIndex(W8),this.setAttribute("position",new BC(X8,3)),this.setAttribute("normal",new BC(Y8,3)),this.setAttribute("uv",new BC(Z8,2))}static fromJSON(l9){return new Q8(l9.radius,l9.tube,l9.radialSegments,l9.tubularSegments,l9.arc)}}class m9 extends MC{constructor(n9=1,o9=.4,p9=64,q9=8,r9=2,s9=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:n9,tube:o9,tubularSegments:p9,radialSegments:q9,p:r9,q:s9},p9=Math.floor(p9),q9=Math.floor(q9);const t9=[],u9=[],v9=[],w9=[],x9=new nk(),y9=new nk(),z9=new nk(),A9=new nk(),B9=new nk(),C9=new nk(),D9=new nk();for(let E9=0;E9<=p9;++E9){const F9=E9/p9*r9*Math.PI*2;Q9(F9,r9,s9,n9,z9),Q9(F9+.01,r9,s9,n9,A9),C9.subVectors(A9,z9),D9.addVectors(A9,z9),B9.crossVectors(C9,D9),D9.crossVectors(B9,C9),B9.normalize(),D9.normalize();for(let G9=0;G9<=q9;++G9){const H9=G9/q9*Math.PI*2,I9=-o9*Math.cos(H9),J9=o9*Math.sin(H9);x9.x=z9.x+(I9*D9.x+J9*B9.x),x9.y=z9.y+(I9*D9.y+J9*B9.y),x9.z=z9.z+(I9*D9.z+J9*B9.z),u9.push(x9.x,x9.y,x9.z),y9.subVectors(x9,z9).normalize(),v9.push(y9.x,y9.y,y9.z),w9.push(E9/p9),w9.push(G9/q9)}}for(let K9=1;K9<=p9;K9++)for(let L9=1;L9<=q9;L9++){const M9=(q9+1)*(K9-1)+(L9-1),N9=(q9+1)*K9+(L9-1),O9=(q9+1)*K9+L9,P9=(q9+1)*(K9-1)+L9;t9.push(M9,N9,P9),t9.push(N9,O9,P9)}function Q9(a,b,c,d,e){const f=c/b*a,g=Math.cos(f);e.x=d*(2+g)*.5*Math.cos(a),e.y=d*(2+g)*Math.sin(a)*.5,e.z=d*Math.sin(f)*.5}this.setIndex(t9),this.setAttribute("position",new BC(u9,3)),this.setAttribute("normal",new BC(v9,3)),this.setAttribute("uv",new BC(w9,2))}static fromJSON(R9){return new m9(R9.radius,R9.tube,R9.tubularSegments,R9.radialSegments,R9.p,R9.q)}}class S9 extends MC{constructor(T9=new X1(new nk(-1,-1,0),new nk(-1,1,0),new nk(1,1,0)),U9=64,V9=1,W9=8,X9=!1){super(),this.type="TubeGeometry",this.parameters={path:T9,tubularSegments:U9,radius:V9,radialSegments:W9,closed:X9};const Y9=T9.computeFrenetFrames(U9,X9);this.tangents=Y9.tangents,this.normals=Y9.normals,this.binormals=Y9.binormals;const Z9=new nk(),$9=new nk(),_9=new ba();let aaa=new nk();const baa=[],caa=[],daa=[],eaa=[];function faa(a){aaa=T9.getPointAt(a/U9,aaa);const b=Y9.normals[a],c=Y9.binormals[a];for(let d=0;d<=W9;d++){const e=d/W9*Math.PI*2,f=Math.sin(e),g=-Math.cos(e);$9.x=g*b.x+f*c.x,$9.y=g*b.y+f*c.y,$9.z=g*b.z+f*c.z,$9.normalize(),caa.push($9.x,$9.y,$9.z),Z9.x=aaa.x+V9*$9.x,Z9.y=aaa.y+V9*$9.y,Z9.z=aaa.z+V9*$9.z,baa.push(Z9.x,Z9.y,Z9.z)}}(function(){for(let a=0;a<U9;a++)faa(a);faa(!1===X9?U9:0),(function(){for(let a=0;a<=U9;a++)for(let b=0;b<=W9;b++)_9.x=a/U9,_9.y=b/W9,daa.push(_9.x,_9.y)})(),(function(){for(let a=1;a<=U9;a++)for(let b=1;b<=W9;b++){const c=(W9+1)*(a-1)+(b-1),d=(W9+1)*a+(b-1),e=(W9+1)*a+b,f=(W9+1)*(a-1)+b;eaa.push(c,d,f),eaa.push(d,e,f)}})()})(),this.setIndex(eaa),this.setAttribute("position",new BC(baa,3)),this.setAttribute("normal",new BC(caa,3)),this.setAttribute("uv",new BC(daa,2))}toJSON(){const gaa=super.toJSON();return gaa.path=this.parameters.path.toJSON(),gaa}static fromJSON(haa){return new S9(new H2[haa.path.type]().fromJSON(haa.path),haa.tubularSegments,haa.radius,haa.radialSegments,haa.closed)}}function iaa(a,b,c){const d=`${a.x},${a.y},${a.z}-${b.x},${b.y},${b.z}`,e=`${b.x},${b.y},${b.z}-${a.x},${a.y},${a.z}`;return!0!==c.has(d)&& !0!==c.has(e)&&(c.add(d,e),!0)}Object.freeze({__proto__:null,BoxGeometry:EH,BoxBufferGeometry:EH,CircleGeometry:gZ,CircleBufferGeometry:gZ,ConeGeometry:QZ,ConeBufferGeometry:QZ,CylinderGeometry:wZ,CylinderBufferGeometry:wZ,DodecahedronGeometry:l$,DodecahedronBufferGeometry:l$,EdgesGeometry:class extends MC{constructor(jaa=null,kaa=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:jaa,thresholdAngle:kaa},null!==jaa){const laa=4,maa=Math.pow(10,laa),naa=Math.cos(T*kaa),oaa=jaa.getIndex(),paa=jaa.getAttribute("position"),qaa=oaa?oaa.count:paa.count,raa=[0,0,0],saa=["a","b","c"],taa=new Array(3),uaa={},vaa=[];for(let waa=0;waa<qaa;waa+=3){oaa?(raa[0]=oaa.getX(waa),raa[1]=oaa.getX(waa+1),raa[2]=oaa.getX(waa+2)):(raa[0]=waa,raa[1]=waa+1,raa[2]=waa+2);const{a:xaa,b:yaa,c:zaa}=u$;if(xaa.fromBufferAttribute(paa,raa[0]),yaa.fromBufferAttribute(paa,raa[1]),zaa.fromBufferAttribute(paa,raa[2]),u$.getNormal(t$),taa[0]=`${Math.round(xaa.x*maa)},${Math.round(xaa.y*maa)},${Math.round(xaa.z*maa)}`,taa[1]=`${Math.round(yaa.x*maa)},${Math.round(yaa.y*maa)},${Math.round(yaa.z*maa)}`,taa[2]=`${Math.round(zaa.x*maa)},${Math.round(zaa.y*maa)},${Math.round(zaa.z*maa)}`,taa[0]!==taa[1]&&taa[1]!==taa[2]&&taa[2]!==taa[0])for(let Aaa=0;Aaa<3;Aaa++){const Baa=(Aaa+1)%3,Caa=taa[Aaa],Daa=taa[Baa],Eaa=u$[saa[Aaa]],Faa=u$[saa[Baa]],Gaa=`${Caa}_${Daa}`,Haa=`${Daa}_${Caa}`;Haa in uaa&&uaa[Haa]?(t$.dot(uaa[Haa].normal)<=naa&&(vaa.push(Eaa.x,Eaa.y,Eaa.z),vaa.push(Faa.x,Faa.y,Faa.z)),uaa[Haa]=null):Gaa in uaa||(uaa[Gaa]={index0:raa[Aaa],index1:raa[Baa],normal:t$.clone()})}}for(const Iaa in uaa)if(uaa[Iaa]){const{index0:Jaa,index1:Kaa}=uaa[Iaa];r$.fromBufferAttribute(paa,Jaa),s$.fromBufferAttribute(paa,Kaa),vaa.push(r$.x,r$.y,r$.z),vaa.push(s$.x,s$.y,s$.z)}this.setAttribute("position",new BC(vaa,3))}}},ExtrudeGeometry:d6,ExtrudeBufferGeometry:d6,IcosahedronGeometry:z6,IcosahedronBufferGeometry:z6,LatheGeometry:E6,LatheBufferGeometry:E6,OctahedronGeometry:l7,OctahedronBufferGeometry:l7,PlaneGeometry:CL,PlaneBufferGeometry:CL,PolyhedronGeometry:ZZ,PolyhedronBufferGeometry:ZZ,RingGeometry:p7,RingBufferGeometry:p7,ShapeGeometry:Q7,ShapeBufferGeometry:Q7,SphereGeometry:i8,SphereBufferGeometry:i8,TetrahedronGeometry:M8,TetrahedronBufferGeometry:M8,TorusGeometry:Q8,TorusBufferGeometry:Q8,TorusKnotGeometry:m9,TorusKnotBufferGeometry:m9,TubeGeometry:S9,TubeBufferGeometry:S9,WireframeGeometry:class extends MC{constructor(Laa=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:Laa},null!==Laa){const Maa=[],Naa=new Set(),Oaa=new nk(),Paa=new nk();if(null!==Laa.index){const Qaa=Laa.attributes.position,Raa=Laa.index;let Saa=Laa.groups;0===Saa.length&&(Saa=[{start:0,count:Raa.count,materialIndex:0}]);for(let Taa=0,Uaa=Saa.length;Taa<Uaa;++Taa){const Vaa=Saa[Taa],Waa=Vaa.start,Xaa=Vaa.count;for(let Yaa=Waa,Zaa=Waa+Xaa;Yaa<Zaa;Yaa+=3)for(let $aa=0;$aa<3;$aa++){const _aa=Raa.getX(Yaa+$aa),aba=Raa.getX(Yaa+($aa+1)%3);Oaa.fromBufferAttribute(Qaa,_aa),Paa.fromBufferAttribute(Qaa,aba),!0===iaa(Oaa,Paa,Naa)&&(Maa.push(Oaa.x,Oaa.y,Oaa.z),Maa.push(Paa.x,Paa.y,Paa.z))}}}else{const bba=Laa.attributes.position;for(let cba=0,dba=bba.count/3;cba<dba;cba++)for(let eba=0;eba<3;eba++){const fba=3*cba+eba,gba=3*cba+(eba+1)%3;Oaa.fromBufferAttribute(bba,fba),Paa.fromBufferAttribute(bba,gba),!0===iaa(Oaa,Paa,Naa)&&(Maa.push(Oaa.x,Oaa.y,Oaa.z),Maa.push(Paa.x,Paa.y,Paa.z))}}this.setAttribute("position",new BC(Maa,3))}}}});class hba extends wA{constructor(iba){super(),this.type="ShadowMaterial",this.color=new Dd(0),this.transparent=!0,this.setValues(iba)}copy(jba){return super.copy(jba),this.color.copy(jba.color),this}}hba.prototype.isShadowMaterial=!0;class kba extends wA{constructor(lba){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Dd(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dd(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=w,this.normalScale=new ba(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(lba)}copy(mba){return super.copy(mba),this.defines={STANDARD:""},this.color.copy(mba.color),this.roughness=mba.roughness,this.metalness=mba.metalness,this.map=mba.map,this.lightMap=mba.lightMap,this.lightMapIntensity=mba.lightMapIntensity,this.aoMap=mba.aoMap,this.aoMapIntensity=mba.aoMapIntensity,this.emissive.copy(mba.emissive),this.emissiveMap=mba.emissiveMap,this.emissiveIntensity=mba.emissiveIntensity,this.bumpMap=mba.bumpMap,this.bumpScale=mba.bumpScale,this.normalMap=mba.normalMap,this.normalMapType=mba.normalMapType,this.normalScale.copy(mba.normalScale),this.displacementMap=mba.displacementMap,this.displacementScale=mba.displacementScale,this.displacementBias=mba.displacementBias,this.roughnessMap=mba.roughnessMap,this.metalnessMap=mba.metalnessMap,this.alphaMap=mba.alphaMap,this.envMap=mba.envMap,this.envMapIntensity=mba.envMapIntensity,this.refractionRatio=mba.refractionRatio,this.wireframe=mba.wireframe,this.wireframeLinewidth=mba.wireframeLinewidth,this.wireframeLinecap=mba.wireframeLinecap,this.wireframeLinejoin=mba.wireframeLinejoin,this.flatShading=mba.flatShading,this}}kba.prototype.isMeshStandardMaterial=!0;class nba extends kba{constructor(oba){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new ba(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return W(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(a){this.ior=(1+.4*a)/(1-.4*a)}}),this.sheenColor=new Dd(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Dd(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Dd(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(oba)}get sheen(){return this._sheen}set sheen(pba){this._sheen>0!=pba>0&&this.version++,this._sheen=pba}get clearcoat(){return this._clearcoat}set clearcoat(qba){this._clearcoat>0!=qba>0&&this.version++,this._clearcoat=qba}get transmission(){return this._transmission}set transmission(rba){this._transmission>0!=rba>0&&this.version++,this._transmission=rba}copy(sba){return super.copy(sba),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=sba.clearcoat,this.clearcoatMap=sba.clearcoatMap,this.clearcoatRoughness=sba.clearcoatRoughness,this.clearcoatRoughnessMap=sba.clearcoatRoughnessMap,this.clearcoatNormalMap=sba.clearcoatNormalMap,this.clearcoatNormalScale.copy(sba.clearcoatNormalScale),this.ior=sba.ior,this.sheen=sba.sheen,this.sheenColor.copy(sba.sheenColor),this.sheenColorMap=sba.sheenColorMap,this.sheenRoughness=sba.sheenRoughness,this.sheenRoughnessMap=sba.sheenRoughnessMap,this.transmission=sba.transmission,this.transmissionMap=sba.transmissionMap,this.thickness=sba.thickness,this.thicknessMap=sba.thicknessMap,this.attenuationDistance=sba.attenuationDistance,this.attenuationColor.copy(sba.attenuationColor),this.specularIntensity=sba.specularIntensity,this.specularIntensityMap=sba.specularIntensityMap,this.specularColor.copy(sba.specularColor),this.specularColorMap=sba.specularColorMap,this}}nba.prototype.isMeshPhysicalMaterial=!0;class tba extends wA{constructor(uba){super(),this.type="MeshPhongMaterial",this.color=new Dd(16777215),this.specular=new Dd(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dd(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=w,this.normalScale=new ba(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(uba)}copy(vba){return super.copy(vba),this.color.copy(vba.color),this.specular.copy(vba.specular),this.shininess=vba.shininess,this.map=vba.map,this.lightMap=vba.lightMap,this.lightMapIntensity=vba.lightMapIntensity,this.aoMap=vba.aoMap,this.aoMapIntensity=vba.aoMapIntensity,this.emissive.copy(vba.emissive),this.emissiveMap=vba.emissiveMap,this.emissiveIntensity=vba.emissiveIntensity,this.bumpMap=vba.bumpMap,this.bumpScale=vba.bumpScale,this.normalMap=vba.normalMap,this.normalMapType=vba.normalMapType,this.normalScale.copy(vba.normalScale),this.displacementMap=vba.displacementMap,this.displacementScale=vba.displacementScale,this.displacementBias=vba.displacementBias,this.specularMap=vba.specularMap,this.alphaMap=vba.alphaMap,this.envMap=vba.envMap,this.combine=vba.combine,this.reflectivity=vba.reflectivity,this.refractionRatio=vba.refractionRatio,this.wireframe=vba.wireframe,this.wireframeLinewidth=vba.wireframeLinewidth,this.wireframeLinecap=vba.wireframeLinecap,this.wireframeLinejoin=vba.wireframeLinejoin,this.flatShading=vba.flatShading,this}}tba.prototype.isMeshPhongMaterial=!0;class wba extends wA{constructor(xba){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Dd(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dd(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=w,this.normalScale=new ba(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(xba)}copy(yba){return super.copy(yba),this.color.copy(yba.color),this.map=yba.map,this.gradientMap=yba.gradientMap,this.lightMap=yba.lightMap,this.lightMapIntensity=yba.lightMapIntensity,this.aoMap=yba.aoMap,this.aoMapIntensity=yba.aoMapIntensity,this.emissive.copy(yba.emissive),this.emissiveMap=yba.emissiveMap,this.emissiveIntensity=yba.emissiveIntensity,this.bumpMap=yba.bumpMap,this.bumpScale=yba.bumpScale,this.normalMap=yba.normalMap,this.normalMapType=yba.normalMapType,this.normalScale.copy(yba.normalScale),this.displacementMap=yba.displacementMap,this.displacementScale=yba.displacementScale,this.displacementBias=yba.displacementBias,this.alphaMap=yba.alphaMap,this.wireframe=yba.wireframe,this.wireframeLinewidth=yba.wireframeLinewidth,this.wireframeLinecap=yba.wireframeLinecap,this.wireframeLinejoin=yba.wireframeLinejoin,this}}wba.prototype.isMeshToonMaterial=!0;class zba extends wA{constructor(Aba){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=w,this.normalScale=new ba(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(Aba)}copy(Bba){return super.copy(Bba),this.bumpMap=Bba.bumpMap,this.bumpScale=Bba.bumpScale,this.normalMap=Bba.normalMap,this.normalMapType=Bba.normalMapType,this.normalScale.copy(Bba.normalScale),this.displacementMap=Bba.displacementMap,this.displacementScale=Bba.displacementScale,this.displacementBias=Bba.displacementBias,this.wireframe=Bba.wireframe,this.wireframeLinewidth=Bba.wireframeLinewidth,this.flatShading=Bba.flatShading,this}}zba.prototype.isMeshNormalMaterial=!0;class Cba extends wA{constructor(Dba){super(),this.type="MeshLambertMaterial",this.color=new Dd(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dd(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(Dba)}copy(Eba){return super.copy(Eba),this.color.copy(Eba.color),this.map=Eba.map,this.lightMap=Eba.lightMap,this.lightMapIntensity=Eba.lightMapIntensity,this.aoMap=Eba.aoMap,this.aoMapIntensity=Eba.aoMapIntensity,this.emissive.copy(Eba.emissive),this.emissiveMap=Eba.emissiveMap,this.emissiveIntensity=Eba.emissiveIntensity,this.specularMap=Eba.specularMap,this.alphaMap=Eba.alphaMap,this.envMap=Eba.envMap,this.combine=Eba.combine,this.reflectivity=Eba.reflectivity,this.refractionRatio=Eba.refractionRatio,this.wireframe=Eba.wireframe,this.wireframeLinewidth=Eba.wireframeLinewidth,this.wireframeLinecap=Eba.wireframeLinecap,this.wireframeLinejoin=Eba.wireframeLinejoin,this}}Cba.prototype.isMeshLambertMaterial=!0;class Fba extends wA{constructor(Gba){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Dd(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=w,this.normalScale=new ba(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(Gba)}copy(Hba){return super.copy(Hba),this.defines={MATCAP:""},this.color.copy(Hba.color),this.matcap=Hba.matcap,this.map=Hba.map,this.bumpMap=Hba.bumpMap,this.bumpScale=Hba.bumpScale,this.normalMap=Hba.normalMap,this.normalMapType=Hba.normalMapType,this.normalScale.copy(Hba.normalScale),this.displacementMap=Hba.displacementMap,this.displacementScale=Hba.displacementScale,this.displacementBias=Hba.displacementBias,this.alphaMap=Hba.alphaMap,this.flatShading=Hba.flatShading,this}}Fba.prototype.isMeshMatcapMaterial=!0;class Iba extends yW{constructor(Jba){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(Jba)}copy(Kba){return super.copy(Kba),this.scale=Kba.scale,this.dashSize=Kba.dashSize,this.gapSize=Kba.gapSize,this}}Iba.prototype.isLineDashedMaterial=!0,Object.freeze({__proto__:null,ShadowMaterial:hba,SpriteMaterial:RT,RawShaderMaterial:MM,ShaderMaterial:XH,PointsMaterial:MX,MeshPhysicalMaterial:nba,MeshStandardMaterial:kba,MeshPhongMaterial:tba,MeshToonMaterial:wba,MeshNormalMaterial:zba,MeshLambertMaterial:Cba,MeshDepthMaterial:RQ,MeshDistanceMaterial:UQ,MeshBasicMaterial:OA,MeshMatcapMaterial:Fba,LineDashedMaterial:Iba,LineBasicMaterial:yW,Material:wA});const Lba={arraySlice:function(a,b,c){return Lba.isTypedArray(a)?new a.constructor(a.subarray(b,void 0!==c?c:a.length)):a.slice(b,c)},convertArray:function(a,b,c){return a&&(c||a.constructor!==b)?"number"==typeof b.BYTES_PER_ELEMENT?new b(a):Array.prototype.slice.call(a):a},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){const b=a.length,c=new Array(b);for(let d=0;d!==b;++d)c[d]=d;return c.sort(function(b,c){return a[b]-a[c]}),c},sortedArray:function(a,b,c){const d=a.length,e=new a.constructor(d);for(let f=0,g=0;g!==d;++f){const h=c[f]*b;for(let i=0;i!==b;++i)e[g++]=a[h+i]}return e},flattenJSON:function(a,b,c,d){let e=1,f=a[0];for(;void 0!==f&& void 0===f[d];)f=a[e++];if(void 0===f)return;let g=f[d];if(void 0!==g)if(Array.isArray(g))do void 0!==(g=f[d])&&(b.push(f.time),c.push.apply(c,g)),f=a[e++];while(void 0!==f);else if(void 0!==g.toArray)do void 0!==(g=f[d])&&(b.push(f.time),g.toArray(c,c.length)),f=a[e++];while(void 0!==f);else do void 0!==(g=f[d])&&(b.push(f.time),c.push(g)),f=a[e++];while(void 0!==f)},subclip:function(a,b,c,d,e=30){const f=a.clone();f.name=b;const g=[];for(let h=0;h<f.tracks.length;++h){const i=f.tracks[h],j=i.getValueSize(),k=[],l=[];for(let m=0;m<i.times.length;++m){const n=i.times[m]*e;if(!(n<c)&&!(n>=d)){k.push(i.times[m]);for(let o=0;o<j;++o)l.push(i.values[m*j+o])}}0!==k.length&&(i.times=Lba.convertArray(k,i.times.constructor),i.values=Lba.convertArray(l,i.values.constructor),g.push(i))}f.tracks=g;let p=1/0;for(let q=0;q<f.tracks.length;++q)p>f.tracks[q].times[0]&&(p=f.tracks[q].times[0]);for(let r=0;r<f.tracks.length;++r)f.tracks[r].shift(-1*p);return f.resetDuration(),f},makeClipAdditive:function(a,b=0,c=a,d=30){d<=0&&(d=30);const e=c.tracks.length,f=b/d;for(let g=0;g<e;++g){const h=c.tracks[g],i=h.ValueTypeName;if("bool"===i||"string"===i)continue;const j=a.tracks.find(function(a){return a.name===h.name&&a.ValueTypeName===i});if(void 0===j)continue;let k=0;const l=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(k=l/3);let m=0;const n=j.getValueSize();j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=n/3);const o=h.times.length-1;let p;if(f<=h.times[0]){const q=k,r=l-k;p=Lba.arraySlice(h.values,q,r)}else if(f>=h.times[o]){const s=o*l+k,t=s+l-k;p=Lba.arraySlice(h.values,s,t)}else{const u=h.createInterpolant(),v=k,w=l-k;u.evaluate(f),p=Lba.arraySlice(u.resultBuffer,v,w)}if("quaternion"===i){const x=new Ih().fromArray(p).normalize().conjugate();x.toArray(p)}const y=j.times.length;for(let z=0;z<y;++z){const A=z*n+m;if("quaternion"===i)Ih.multiplyQuaternionsFlat(j.values,A,p,0,j.values,A);else{const B=n-2*m;for(let C=0;C<B;++C)j.values[A+C]-=p[C]}}}return a.blendMode=2501,a}};class Mba{constructor(Nba,Oba,Pba,Qba){this.parameterPositions=Nba,this._cachedIndex=0,this.resultBuffer=void 0!==Qba?Qba:new Oba.constructor(Pba),this.sampleValues=Oba,this.valueSize=Pba,this.settings=null,this.DefaultSettings_={}}evaluate(Rba){const Sba=this.parameterPositions;let Tba=this._cachedIndex,Uba=Sba[Tba],Vba=Sba[Tba-1];validate_interval:{seek:{let Wba;linear_scan:{forward_scan:if(!(Rba<Uba)){for(let Xba=Tba+2;;){if(void 0===Uba){if(Rba<Vba)break forward_scan;return Tba=Sba.length,this._cachedIndex=Tba,this.afterEnd_(Tba-1,Rba,Vba)}if(Tba===Xba)break;if(Vba=Uba,Rba<(Uba=Sba[++Tba]))break seek}Wba=Sba.length;break linear_scan}if(!(Rba>=Vba)){const Yba=Sba[1];Rba<Yba&&(Tba=2,Vba=Yba);for(let Zba=Tba-2;;){if(void 0===Vba)return this._cachedIndex=0,this.beforeStart_(0,Rba,Uba);if(Tba===Zba)break;if(Uba=Vba,Rba>=(Vba=Sba[--Tba-1]))break seek}Wba=Tba,Tba=0;break linear_scan}break validate_interval}for(;Tba<Wba;){const $ba=Tba+Wba>>>1;Rba<Sba[$ba]?Wba=$ba:Tba=$ba+1}if(Uba=Sba[Tba],Vba=Sba[Tba-1],void 0===Vba)return this._cachedIndex=0,this.beforeStart_(0,Rba,Uba);if(void 0===Uba)return Tba=Sba.length,this._cachedIndex=Tba,this.afterEnd_(Tba-1,Vba,Rba)}this._cachedIndex=Tba,this.intervalChanged_(Tba,Vba,Uba)}return this.interpolate_(Tba,Vba,Rba,Uba)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(_ba){const aca=this.resultBuffer,bca=this.sampleValues,cca=this.valueSize,dca=_ba*cca;for(let eca=0;eca!==cca;++eca)aca[eca]=bca[dca+eca];return aca}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Mba.prototype.beforeStart_=Mba.prototype.copySampleValue_,Mba.prototype.afterEnd_=Mba.prototype.copySampleValue_;class fca extends Mba{constructor(gca,hca,ica,jca){super(gca,hca,ica,jca),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(kca,lca,mca){const nca=this.parameterPositions;let oca=kca-2,pca=kca+1,qca=nca[oca],rca=nca[pca];if(void 0===qca)switch(this.getSettings_().endingStart){case 2401:oca=kca,qca=2*lca-mca;break;case 2402:oca=nca.length-2,qca=lca+nca[oca]-nca[oca+1];break;default:oca=kca,qca=mca}if(void 0===rca)switch(this.getSettings_().endingEnd){case 2401:pca=kca,rca=2*mca-lca;break;case 2402:pca=1,rca=mca+nca[1]-nca[0];break;default:pca=kca-1,rca=lca}const sca=(mca-lca)*.5,tca=this.valueSize;this._weightPrev=sca/(lca-qca),this._weightNext=sca/(rca-mca),this._offsetPrev=oca*tca,this._offsetNext=pca*tca}interpolate_(uca,vca,wca,xca){const yca=this.resultBuffer,zca=this.sampleValues,Aca=this.valueSize,Bca=uca*Aca,Cca=Bca-Aca,Dca=this._offsetPrev,Eca=this._offsetNext,Fca=this._weightPrev,Gca=this._weightNext,Hca=(wca-vca)/(xca-vca),Ica=Hca*Hca,Jca=Ica*Hca,Kca=-Fca*Jca+2*Fca*Ica-Fca*Hca,Lca=(1+Fca)*Jca+(-1.5-2*Fca)*Ica+(-0.5+Fca)*Hca+1,Mca=(-1-Gca)*Jca+(1.5+Gca)*Ica+.5*Hca,Nca=Gca*Jca-Gca*Ica;for(let Oca=0;Oca!==Aca;++Oca)yca[Oca]=Kca*zca[Dca+Oca]+Lca*zca[Cca+Oca]+Mca*zca[Bca+Oca]+Nca*zca[Eca+Oca];return yca}}class Pca extends Mba{constructor(Qca,Rca,Sca,Tca){super(Qca,Rca,Sca,Tca)}interpolate_(Uca,Vca,Wca,Xca){const Yca=this.resultBuffer,Zca=this.sampleValues,$ca=this.valueSize,_ca=Uca*$ca,ada=_ca-$ca,bda=(Wca-Vca)/(Xca-Vca),cda=1-bda;for(let dda=0;dda!==$ca;++dda)Yca[dda]=Zca[ada+dda]*cda+Zca[_ca+dda]*bda;return Yca}}class eda extends Mba{constructor(fda,gda,hda,ida){super(fda,gda,hda,ida)}interpolate_(jda){return this.copySampleValue_(jda-1)}}class kda{constructor(lda,mda,nda,oda){if(void 0===lda)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===mda||0===mda.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+lda);this.name=lda,this.times=Lba.convertArray(mda,this.TimeBufferType),this.values=Lba.convertArray(nda,this.ValueBufferType),this.setInterpolation(oda||this.DefaultInterpolation)}static toJSON(pda){const qda=pda.constructor;let rda;if(qda.toJSON!==this.toJSON)rda=qda.toJSON(pda);else{rda={name:pda.name,times:Lba.convertArray(pda.times,Array),values:Lba.convertArray(pda.values,Array)};const sda=pda.getInterpolation();sda!==pda.DefaultInterpolation&&(rda.interpolation=sda)}return rda.type=pda.ValueTypeName,rda}InterpolantFactoryMethodDiscrete(tda){return new eda(this.times,this.values,this.getValueSize(),tda)}InterpolantFactoryMethodLinear(uda){return new Pca(this.times,this.values,this.getValueSize(),uda)}InterpolantFactoryMethodSmooth(vda){return new fca(this.times,this.values,this.getValueSize(),vda)}setInterpolation(wda){let xda;switch(wda){case r:xda=this.InterpolantFactoryMethodDiscrete;break;case s:xda=this.InterpolantFactoryMethodLinear;break;case 2302:xda=this.InterpolantFactoryMethodSmooth;break}if(void 0===xda){const yda="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant)if(wda!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(yda);return console.warn("THREE.KeyframeTrack:",yda),this}return this.createInterpolant=xda,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return r;case this.InterpolantFactoryMethodLinear:return s;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(zda){if(0!==zda){const Ada=this.times;for(let Bda=0,Cda=Ada.length;Bda!==Cda;++Bda)Ada[Bda]+=zda}return this}scale(Dda){if(1!==Dda){const Eda=this.times;for(let Fda=0,Gda=Eda.length;Fda!==Gda;++Fda)Eda[Fda]*=Dda}return this}trim(Hda,Ida){const Jda=this.times,Kda=Jda.length;let Lda=0,Mda=Kda-1;for(;Lda!==Kda&&Jda[Lda]<Hda;)++Lda;for(;-1!==Mda&&Jda[Mda]>Ida;)--Mda;if(++Mda,0!==Lda||Mda!==Kda){Lda>=Mda&&(Lda=(Mda=Math.max(Mda,1))-1);const Nda=this.getValueSize();this.times=Lba.arraySlice(Jda,Lda,Mda),this.values=Lba.arraySlice(this.values,Lda*Nda,Mda*Nda)}return this}validate(){let Oda=!0;const Pda=this.getValueSize();Pda-Math.floor(Pda)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),Oda=!1);const Qda=this.times,Rda=this.values,Sda=Qda.length;0===Sda&&(console.error("THREE.KeyframeTrack: Track is empty.",this),Oda=!1);let Tda=null;for(let Uda=0;Uda!==Sda;Uda++){const Vda=Qda[Uda];if("number"==typeof Vda&&isNaN(Vda)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,Uda,Vda),Oda=!1;break}if(null!==Tda&&Tda>Vda){console.error("THREE.KeyframeTrack: Out of order keys.",this,Uda,Vda,Tda),Oda=!1;break}Tda=Vda}if(void 0!==Rda&&Lba.isTypedArray(Rda))for(let Wda=0,Xda=Rda.length;Wda!==Xda;++Wda){const Yda=Rda[Wda];if(isNaN(Yda)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,Wda,Yda),Oda=!1;break}}return Oda}optimize(){const Zda=Lba.arraySlice(this.times),$da=Lba.arraySlice(this.values),_da=this.getValueSize(),aea=2302===this.getInterpolation(),bea=Zda.length-1;let cea=1;for(let dea=1;dea<bea;++dea){let eea=!1;const fea=Zda[dea],gea=Zda[dea+1];if(fea!==gea&&(1!==dea||fea!==Zda[0]))if(aea)eea=!0;else{const hea=dea*_da,iea=hea-_da,jea=hea+_da;for(let kea=0;kea!==_da;++kea){const lea=$da[hea+kea];if(lea!==$da[iea+kea]||lea!==$da[jea+kea]){eea=!0;break}}}if(eea){if(dea!==cea){Zda[cea]=Zda[dea];const mea=dea*_da,nea=cea*_da;for(let oea=0;oea!==_da;++oea)$da[nea+oea]=$da[mea+oea]}++cea}}if(bea>0){Zda[cea]=Zda[bea];for(let pea=bea*_da,qea=cea*_da,rea=0;rea!==_da;++rea)$da[qea+rea]=$da[pea+rea];++cea}return cea!==Zda.length?(this.times=Lba.arraySlice(Zda,0,cea),this.values=Lba.arraySlice($da,0,cea*_da)):(this.times=Zda,this.values=$da),this}clone(){const sea=Lba.arraySlice(this.times,0),tea=Lba.arraySlice(this.values,0),uea=this.constructor,vea=new uea(this.name,sea,tea);return vea.createInterpolant=this.createInterpolant,vea}}kda.prototype.TimeBufferType=Float32Array,kda.prototype.ValueBufferType=Float32Array,kda.prototype.DefaultInterpolation=s;class wea extends kda{}wea.prototype.ValueTypeName="bool",wea.prototype.ValueBufferType=Array,wea.prototype.DefaultInterpolation=r,wea.prototype.InterpolantFactoryMethodLinear=void 0,wea.prototype.InterpolantFactoryMethodSmooth=void 0;class xea extends kda{}xea.prototype.ValueTypeName="color";class yea extends kda{}yea.prototype.ValueTypeName="number";class zea extends Mba{constructor(Aea,Bea,Cea,Dea){super(Aea,Bea,Cea,Dea)}interpolate_(Eea,Fea,Gea,Hea){const Iea=this.resultBuffer,Jea=this.sampleValues,Kea=this.valueSize,Lea=(Gea-Fea)/(Hea-Fea);let Mea=Eea*Kea;for(let Nea=Mea+Kea;Mea!==Nea;Mea+=4)Ih.slerpFlat(Iea,0,Jea,Mea-Kea,Jea,Mea,Lea);return Iea}}class Oea extends kda{InterpolantFactoryMethodLinear(Pea){return new zea(this.times,this.values,this.getValueSize(),Pea)}}Oea.prototype.ValueTypeName="quaternion",Oea.prototype.DefaultInterpolation=s,Oea.prototype.InterpolantFactoryMethodSmooth=void 0;class Qea extends kda{}Qea.prototype.ValueTypeName="string",Qea.prototype.ValueBufferType=Array,Qea.prototype.DefaultInterpolation=r,Qea.prototype.InterpolantFactoryMethodLinear=void 0,Qea.prototype.InterpolantFactoryMethodSmooth=void 0;class Rea extends kda{}Rea.prototype.ValueTypeName="vector";class Sea{constructor(Tea,Uea=-1,Vea,Wea=2500){this.name=Tea,this.tracks=Vea,this.duration=Uea,this.blendMode=Wea,this.uuid=V(),this.duration<0&&this.resetDuration()}static parse(Xea){const Yea=[],Zea=Xea.tracks,$ea=1/(Xea.fps||1);for(let _ea=0,afa=Zea.length;_ea!==afa;++_ea)Yea.push(oga(Zea[_ea]).scale($ea));const bfa=new this(Xea.name,Xea.duration,Yea,Xea.blendMode);return bfa.uuid=Xea.uuid,bfa}static toJSON(cfa){const dfa=[],efa=cfa.tracks,ffa={name:cfa.name,duration:cfa.duration,tracks:dfa,uuid:cfa.uuid,blendMode:cfa.blendMode};for(let gfa=0,hfa=efa.length;gfa!==hfa;++gfa)dfa.push(kda.toJSON(efa[gfa]));return ffa}static CreateFromMorphTargetSequence(ifa,jfa,kfa,lfa){const mfa=jfa.length,nfa=[];for(let ofa=0;ofa<mfa;ofa++){let pfa=[],qfa=[];pfa.push((ofa+mfa-1)%mfa,ofa,(ofa+1)%mfa),qfa.push(0,1,0);const rfa=Lba.getKeyframeOrder(pfa);pfa=Lba.sortedArray(pfa,1,rfa),qfa=Lba.sortedArray(qfa,1,rfa),lfa||0!==pfa[0]||(pfa.push(mfa),qfa.push(qfa[0])),nfa.push(new yea(".morphTargetInfluences["+jfa[ofa].name+"]",pfa,qfa).scale(1/kfa))}return new this(ifa,-1,nfa)}static findByName(sfa,tfa){let ufa=sfa;if(!Array.isArray(sfa)){const vfa=sfa;ufa=vfa.geometry&&vfa.geometry.animations||vfa.animations}for(let wfa=0;wfa<ufa.length;wfa++)if(ufa[wfa].name===tfa)return ufa[wfa];return null}static CreateClipsFromMorphTargetSequences(xfa,yfa,zfa){const Afa={},Bfa=/^([\w-]*?)([\d]+)$/;for(let Cfa=0,Dfa=xfa.length;Cfa<Dfa;Cfa++){const Efa=xfa[Cfa],Ffa=Efa.name.match(Bfa);if(Ffa&&Ffa.length>1){const Gfa=Ffa[1];let Hfa=Afa[Gfa];Hfa||(Afa[Gfa]=Hfa=[]),Hfa.push(Efa)}}const Ifa=[];for(const Jfa in Afa)Ifa.push(this.CreateFromMorphTargetSequence(Jfa,Afa[Jfa],yfa,zfa));return Ifa}static parseAnimation(Kfa,Lfa){if(!Kfa)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const Mfa=function(a,b,c,d,e){if(0!==c.length){const f=[],g=[];Lba.flattenJSON(c,f,g,d),0!==f.length&&e.push(new a(b,f,g))}},Nfa=[],Ofa=Kfa.name||"default",Pfa=Kfa.fps||30,Qfa=Kfa.blendMode;let Rfa=Kfa.length|| -1;const Sfa=Kfa.hierarchy||[];for(let Tfa=0;Tfa<Sfa.length;Tfa++){const Ufa=Sfa[Tfa].keys;if(Ufa&&0!==Ufa.length)if(Ufa[0].morphTargets){const Vfa={};let Wfa;for(Wfa=0;Wfa<Ufa.length;Wfa++)if(Ufa[Wfa].morphTargets)for(let Xfa=0;Xfa<Ufa[Wfa].morphTargets.length;Xfa++)Vfa[Ufa[Wfa].morphTargets[Xfa]]=-1;for(const Yfa in Vfa){const Zfa=[],$fa=[];for(let _fa=0;_fa!==Ufa[Wfa].morphTargets.length;++_fa){const aga=Ufa[Wfa];Zfa.push(aga.time),$fa.push(aga.morphTarget===Yfa?1:0)}Nfa.push(new yea(".morphTargetInfluence["+Yfa+"]",Zfa,$fa))}Rfa=Vfa.length*(Pfa||1)}else{const bga=".bones["+Lfa[Tfa].name+"]";Mfa(Rea,bga+".position",Ufa,"pos",Nfa),Mfa(Oea,bga+".quaternion",Ufa,"rot",Nfa),Mfa(Rea,bga+".scale",Ufa,"scl",Nfa)}}if(0===Nfa.length)return null;const cga=new this(Ofa,Rfa,Nfa,Qfa);return cga}resetDuration(){const dga=this.tracks;let ega=0;for(let fga=0,gga=dga.length;fga!==gga;++fga){const hga=this.tracks[fga];ega=Math.max(ega,hga.times[hga.times.length-1])}return this.duration=ega,this}trim(){for(let iga=0;iga<this.tracks.length;iga++)this.tracks[iga].trim(0,this.duration);return this}validate(){let jga=!0;for(let kga=0;kga<this.tracks.length;kga++)jga=jga&&this.tracks[kga].validate();return jga}optimize(){for(let lga=0;lga<this.tracks.length;lga++)this.tracks[lga].optimize();return this}clone(){const mga=[];for(let nga=0;nga<this.tracks.length;nga++)mga.push(this.tracks[nga].clone());return new this.constructor(this.name,this.duration,mga,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function oga(a){if(void 0===a.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const b=function(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return yea;case"vector":case"vector2":case"vector3":case"vector4":return Rea;case"color":return xea;case"quaternion":return Oea;case"bool":case"boolean":return wea;case"string":return Qea}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}(a.type);if(void 0===a.times){const c=[],d=[];Lba.flattenJSON(a.keys,c,d,"value"),a.times=c,a.values=d}return void 0!==b.parse?b.parse(a):new b(a.name,a.times,a.values,a.interpolation)}const pga={enabled:!1,files:{},add:function(a,b){!1!==this.enabled&&(this.files[a]=b)},get:function(a){if(!1!==this.enabled)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}},qga=new class{constructor(rga,sga,tga){const uga=this;let vga=!1,wga=0,xga=0,yga;const zga=[];this.onStart=void 0,this.onLoad=rga,this.onProgress=sga,this.onError=tga,this.itemStart=function(a){xga++,!1===vga&& void 0!==uga.onStart&&uga.onStart(a,wga,xga),vga=!0},this.itemEnd=function(a){wga++,void 0!==uga.onProgress&&uga.onProgress(a,wga,xga),wga===xga&&(vga=!1,void 0!==uga.onLoad&&uga.onLoad())},this.itemError=function(a){void 0!==uga.onError&&uga.onError(a)},this.resolveURL=function(a){return yga?yga(a):a},this.setURLModifier=function(a){return yga=a,this},this.addHandler=function(a,b){return zga.push(a,b),this},this.removeHandler=function(a){const b=zga.indexOf(a);return -1!==b&&zga.splice(b,2),this},this.getHandler=function(a){for(let b=0,c=zga.length;b<c;b+=2){const d=zga[b],e=zga[b+1];if(d.global&&(d.lastIndex=0),d.test(a))return e}return null}}}();class Aga{constructor(Bga){this.manager=void 0!==Bga?Bga:qga,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(Cga,Dga){const Ega=this;return new Promise(function(a,b){Ega.load(Cga,a,Dga,b)})}parse(){}setCrossOrigin(Fga){return this.crossOrigin=Fga,this}setWithCredentials(Gga){return this.withCredentials=Gga,this}setPath(Hga){return this.path=Hga,this}setResourcePath(Iga){return this.resourcePath=Iga,this}setRequestHeader(Jga){return this.requestHeader=Jga,this}}const Kga={};class Lga extends Aga{constructor(Mga){super(Mga)}load(Nga,Oga,Pga,Qga){void 0===Nga&&(Nga=""),void 0!==this.path&&(Nga=this.path+Nga),Nga=this.manager.resolveURL(Nga);const Rga=pga.get(Nga);if(void 0!==Rga)return this.manager.itemStart(Nga),setTimeout(()=>{Oga&&Oga(Rga),this.manager.itemEnd(Nga)},0),Rga;if(void 0!==Kga[Nga]){Kga[Nga].push({onLoad:Oga,onProgress:Pga,onError:Qga});return}Kga[Nga]=[],Kga[Nga].push({onLoad:Oga,onProgress:Pga,onError:Qga});const Sga=new Request(Nga,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),Tga=this.mimeType,Uga=this.responseType;fetch(Sga).then(a=>{if(200===a.status||0===a.status){if(0===a.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream|| void 0===a.body.getReader)return a;const b=Kga[Nga],c=a.body.getReader(),d=a.headers.get("Content-Length"),e=d?parseInt(d):0,f=0!==e;let g=0;const h=new ReadableStream({start(a){d();function d(){c.read().then(({done:c,value:h})=>{if(c)a.close();else{g+=h.byteLength;const i=new ProgressEvent("progress",{lengthComputable:f,loaded:g,total:e});for(let j=0,k=b.length;j<k;j++){const l=b[j];l.onProgress&&l.onProgress(i)}a.enqueue(h),d()}})}}});return new Response(h)}throw Error(`fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`)}).then(a=>{switch(Uga){case"arraybuffer":return a.arrayBuffer();case"blob":return a.blob();case"document":return a.text().then(a=>{const b=new DOMParser();return b.parseFromString(a,Tga)});case"json":return a.json();default:if(void 0===Tga)return a.text();{const b=/charset="?([^;"\s]*)"?/i,c=b.exec(Tga),d=c&&c[1]?c[1].toLowerCase():void 0,e=new TextDecoder(d);return a.arrayBuffer().then(a=>e.decode(a))}}}).then(a=>{pga.add(Nga,a);const b=Kga[Nga];delete Kga[Nga];for(let c=0,d=b.length;c<d;c++){const e=b[c];e.onLoad&&e.onLoad(a)}}).catch(a=>{const b=Kga[Nga];if(void 0===b)throw this.manager.itemError(Nga),a;delete Kga[Nga];for(let c=0,d=b.length;c<d;c++){const e=b[c];e.onError&&e.onError(a)}this.manager.itemError(Nga)}).finally(()=>{this.manager.itemEnd(Nga)}),this.manager.itemStart(Nga)}setResponseType(Vga){return this.responseType=Vga,this}setMimeType(Wga){return this.mimeType=Wga,this}}class Xga extends Aga{constructor(Yga){super(Yga)}load(Zga,$ga,_ga,aha){void 0!==this.path&&(Zga=this.path+Zga),Zga=this.manager.resolveURL(Zga);const bha=this,cha=pga.get(Zga);if(void 0!==cha)return bha.manager.itemStart(Zga),setTimeout(function(){$ga&&$ga(cha),bha.manager.itemEnd(Zga)},0),cha;const dha=wd("img");function eha(){gha(),pga.add(Zga,this),$ga&&$ga(this),bha.manager.itemEnd(Zga)}function fha(a){gha(),aha&&aha(a),bha.manager.itemError(Zga),bha.manager.itemEnd(Zga)}function gha(){dha.removeEventListener("load",eha,!1),dha.removeEventListener("error",fha,!1)}return dha.addEventListener("load",eha,!1),dha.addEventListener("error",fha,!1),"data:"!==Zga.substr(0,5)&& void 0!==this.crossOrigin&&(dha.crossOrigin=this.crossOrigin),bha.manager.itemStart(Zga),dha.src=Zga,dha}}class hha extends Aga{constructor(iha){super(iha)}load(jha,kha,lha,mha){const nha=new iJ(),oha=new Xga(this.manager);oha.setCrossOrigin(this.crossOrigin),oha.setPath(this.path);let pha=0;function qha(a){oha.load(jha[a],function(b){nha.images[a]=b,pha++,6===pha&&(nha.needsUpdate=!0,kha&&kha(nha))},void 0,mha)}for(let rha=0;rha<jha.length;++rha)qha(rha);return nha}}class sha extends Aga{constructor(tha){super(tha)}load(uha,vha,wha,xha){const yha=new df(),zha=new Xga(this.manager);return zha.setCrossOrigin(this.crossOrigin),zha.setPath(this.path),zha.load(uha,function(a){yha.image=a,yha.needsUpdate=!0,void 0!==vha&&vha(yha)},wha,xha),yha}}class Aha extends Sw{constructor(Bha,Cha=1){super(),this.type="Light",this.color=new Dd(Bha),this.intensity=Cha}dispose(){}copy(Dha){return super.copy(Dha),this.color.copy(Dha.color),this.intensity=Dha.intensity,this}toJSON(Eha){const Fha=super.toJSON(Eha);return Fha.object.color=this.color.getHex(),Fha.object.intensity=this.intensity,void 0!==this.groundColor&&(Fha.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(Fha.object.distance=this.distance),void 0!==this.angle&&(Fha.object.angle=this.angle),void 0!==this.decay&&(Fha.object.decay=this.decay),void 0!==this.penumbra&&(Fha.object.penumbra=this.penumbra),void 0!==this.shadow&&(Fha.object.shadow=this.shadow.toJSON()),Fha}}Aha.prototype.isLight=!0,(class extends Aha{constructor(Gha,Hha,Iha){super(Gha,Iha),this.type="HemisphereLight",this.position.copy(Sw.DefaultUp),this.updateMatrix(),this.groundColor=new Dd(Hha)}copy(Jha){return Aha.prototype.copy.call(this,Jha),this.groundColor.copy(Jha.groundColor),this}}).prototype.isHemisphereLight=!0;const Kha=new Hq(),Lha=new nk(),Mha=new nk();class Nha{constructor(Oha){this.camera=Oha,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new ba(512,512),this.map=null,this.mapPass=null,this.matrix=new Hq(),this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new CK(),this._frameExtents=new ba(1,1),this._viewportCount=1,this._viewports=[new Af(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(Pha){const Qha=this.camera,Rha=this.matrix;Lha.setFromMatrixPosition(Pha.matrixWorld),Qha.position.copy(Lha),Mha.setFromMatrixPosition(Pha.target.matrixWorld),Qha.lookAt(Mha),Qha.updateMatrixWorld(),Kha.multiplyMatrices(Qha.projectionMatrix,Qha.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Kha),Rha.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),Rha.multiply(Qha.projectionMatrix),Rha.multiply(Qha.matrixWorldInverse)}getViewport(Sha){return this._viewports[Sha]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(Tha){return this.camera=Tha.camera.clone(),this.bias=Tha.bias,this.radius=Tha.radius,this.mapSize.copy(Tha.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const Uha={};return 0!==this.bias&&(Uha.bias=this.bias),0!==this.normalBias&&(Uha.normalBias=this.normalBias),1!==this.radius&&(Uha.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(Uha.mapSize=this.mapSize.toArray()),Uha.camera=this.camera.toJSON(!1).object,delete Uha.camera.matrix,Uha}}class Vha extends Nha{constructor(){super(new nI(50,1,.5,500)),this.focus=1}updateMatrices(Wha){const Xha=this.camera,Yha=2*U*Wha.angle*this.focus,Zha=this.mapSize.width/this.mapSize.height,$ha=Wha.distance||Xha.far;(Yha!==Xha.fov||Zha!==Xha.aspect||$ha!==Xha.far)&&(Xha.fov=Yha,Xha.aspect=Zha,Xha.far=$ha,Xha.updateProjectionMatrix()),super.updateMatrices(Wha)}copy(_ha){return super.copy(_ha),this.focus=_ha.focus,this}}Vha.prototype.isSpotLightShadow=!0;class aia extends Aha{constructor(bia,cia,dia=0,eia=Math.PI/3,fia=0,gia=1){super(bia,cia),this.type="SpotLight",this.position.copy(Sw.DefaultUp),this.updateMatrix(),this.target=new Sw(),this.distance=dia,this.angle=eia,this.penumbra=fia,this.decay=gia,this.shadow=new Vha()}get power(){return this.intensity*Math.PI}set power(hia){this.intensity=hia/Math.PI}dispose(){this.shadow.dispose()}copy(iia){return super.copy(iia),this.distance=iia.distance,this.angle=iia.angle,this.penumbra=iia.penumbra,this.decay=iia.decay,this.target=iia.target.clone(),this.shadow=iia.shadow.clone(),this}}aia.prototype.isSpotLight=!0;const jia=new Hq(),kia=new nk(),lia=new nk();class mia extends Nha{constructor(){super(new nI(90,1,.5,500)),this._frameExtents=new ba(4,2),this._viewportCount=6,this._viewports=[new Af(2,1,1,1),new Af(0,1,1,1),new Af(3,1,1,1),new Af(1,1,1,1),new Af(3,0,1,1),new Af(1,0,1,1)],this._cubeDirections=[new nk(1,0,0),new nk(-1,0,0),new nk(0,0,1),new nk(0,0,-1),new nk(0,1,0),new nk(0,-1,0)],this._cubeUps=[new nk(0,1,0),new nk(0,1,0),new nk(0,1,0),new nk(0,1,0),new nk(0,0,1),new nk(0,0,-1)]}updateMatrices(nia,oia=0){const pia=this.camera,qia=this.matrix,ria=nia.distance||pia.far;ria!==pia.far&&(pia.far=ria,pia.updateProjectionMatrix()),kia.setFromMatrixPosition(nia.matrixWorld),pia.position.copy(kia),lia.copy(pia.position),lia.add(this._cubeDirections[oia]),pia.up.copy(this._cubeUps[oia]),pia.lookAt(lia),pia.updateMatrixWorld(),qia.makeTranslation(-kia.x,-kia.y,-kia.z),jia.multiplyMatrices(pia.projectionMatrix,pia.matrixWorldInverse),this._frustum.setFromProjectionMatrix(jia)}}mia.prototype.isPointLightShadow=!0;class sia extends Aha{constructor(tia,uia,via=0,wia=1){super(tia,uia),this.type="PointLight",this.distance=via,this.decay=wia,this.shadow=new mia()}get power(){return 4*this.intensity*Math.PI}set power(xia){this.intensity=xia/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(yia){return super.copy(yia),this.distance=yia.distance,this.decay=yia.decay,this.shadow=yia.shadow.clone(),this}}sia.prototype.isPointLight=!0;class zia extends Nha{constructor(){super(new lM(-5,5,5,-5,.5,500))}}zia.prototype.isDirectionalLightShadow=!0;class Aia extends Aha{constructor(Bia,Cia){super(Bia,Cia),this.type="DirectionalLight",this.position.copy(Sw.DefaultUp),this.updateMatrix(),this.target=new Sw(),this.shadow=new zia()}dispose(){this.shadow.dispose()}copy(Dia){return super.copy(Dia),this.target=Dia.target.clone(),this.shadow=Dia.shadow.clone(),this}}Aia.prototype.isDirectionalLight=!0,(class extends Aha{constructor(Eia,Fia){super(Eia,Fia),this.type="AmbientLight"}}).prototype.isAmbientLight=!0,(class extends Aha{constructor(Gia,Hia,Iia=10,Jia=10){super(Gia,Hia),this.type="RectAreaLight",this.width=Iia,this.height=Jia}get power(){return this.intensity*this.width*this.height*Math.PI}set power(Kia){this.intensity=Kia/(this.width*this.height*Math.PI)}copy(Lia){return super.copy(Lia),this.width=Lia.width,this.height=Lia.height,this}toJSON(Mia){const Nia=super.toJSON(Mia);return Nia.object.width=this.width,Nia.object.height=this.height,Nia}}).prototype.isRectAreaLight=!0;class Oia{constructor(){this.coefficients=[];for(let Pia=0;Pia<9;Pia++)this.coefficients.push(new nk())}set(Qia){for(let Ria=0;Ria<9;Ria++)this.coefficients[Ria].copy(Qia[Ria]);return this}zero(){for(let Sia=0;Sia<9;Sia++)this.coefficients[Sia].set(0,0,0);return this}getAt(Tia,Uia){const Via=Tia.x,Wia=Tia.y,Xia=Tia.z,Yia=this.coefficients;return Uia.copy(Yia[0]).multiplyScalar(.282095),Uia.addScaledVector(Yia[1],.488603*Wia),Uia.addScaledVector(Yia[2],.488603*Xia),Uia.addScaledVector(Yia[3],.488603*Via),Uia.addScaledVector(Yia[4],1.092548*(Via*Wia)),Uia.addScaledVector(Yia[5],1.092548*(Wia*Xia)),Uia.addScaledVector(Yia[6],.315392*(3*Xia*Xia-1)),Uia.addScaledVector(Yia[7],1.092548*(Via*Xia)),Uia.addScaledVector(Yia[8],.546274*(Via*Via-Wia*Wia)),Uia}getIrradianceAt(Zia,$ia){const _ia=Zia.x,aja=Zia.y,bja=Zia.z,cja=this.coefficients;return $ia.copy(cja[0]).multiplyScalar(.886227),$ia.addScaledVector(cja[1],1.023328*aja),$ia.addScaledVector(cja[2],1.023328*bja),$ia.addScaledVector(cja[3],1.023328*_ia),$ia.addScaledVector(cja[4],.858086*_ia*aja),$ia.addScaledVector(cja[5],.858086*aja*bja),$ia.addScaledVector(cja[6],.743125*bja*bja-.247708),$ia.addScaledVector(cja[7],.858086*_ia*bja),$ia.addScaledVector(cja[8],.429043*(_ia*_ia-aja*aja)),$ia}add(dja){for(let eja=0;eja<9;eja++)this.coefficients[eja].add(dja.coefficients[eja]);return this}addScaledSH(fja,gja){for(let hja=0;hja<9;hja++)this.coefficients[hja].addScaledVector(fja.coefficients[hja],gja);return this}scale(ija){for(let jja=0;jja<9;jja++)this.coefficients[jja].multiplyScalar(ija);return this}lerp(kja,lja){for(let mja=0;mja<9;mja++)this.coefficients[mja].lerp(kja.coefficients[mja],lja);return this}equals(nja){for(let oja=0;oja<9;oja++)if(!this.coefficients[oja].equals(nja.coefficients[oja]))return!1;return!0}copy(pja){return this.set(pja.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(qja,rja=0){const sja=this.coefficients;for(let tja=0;tja<9;tja++)sja[tja].fromArray(qja,rja+3*tja);return this}toArray(uja=[],vja=0){const wja=this.coefficients;for(let xja=0;xja<9;xja++)wja[xja].toArray(uja,vja+3*xja);return uja}static getBasisAt(yja,zja){const Aja=yja.x,Bja=yja.y,Cja=yja.z;zja[0]=.282095,zja[1]=.488603*Bja,zja[2]=.488603*Cja,zja[3]=.488603*Aja,zja[4]=1.092548*Aja*Bja,zja[5]=1.092548*Bja*Cja,zja[6]=.315392*(3*Cja*Cja-1),zja[7]=1.092548*Aja*Cja,zja[8]=.546274*(Aja*Aja-Bja*Bja)}}Oia.prototype.isSphericalHarmonics3=!0;class Dja extends Aha{constructor(Eja=new Oia(),Fja=1){super(void 0,Fja),this.sh=Eja}copy(Gja){return super.copy(Gja),this.sh.copy(Gja.sh),this}fromJSON(Hja){return this.intensity=Hja.intensity,this.sh.fromArray(Hja.sh),this}toJSON(Ija){const Jja=super.toJSON(Ija);return Jja.object.sh=this.sh.toArray(),Jja}}Dja.prototype.isLightProbe=!0;class Kja{static decodeText(Lja){if("undefined"!=typeof TextDecoder)return new TextDecoder().decode(Lja);let Mja="";for(let Nja=0,Oja=Lja.length;Nja<Oja;Nja++)Mja+=String.fromCharCode(Lja[Nja]);try{return decodeURIComponent(escape(Mja))}catch(Pja){return Mja}}static extractUrlBase(Qja){const Rja=Qja.lastIndexOf("/");return -1===Rja?"./":Qja.substr(0,Rja+1)}static resolveURL(Sja,Tja){return"string"!=typeof Sja||""===Sja?"":(/^https?:\/\//i.test(Tja)&&/^\//.test(Sja)&&(Tja=Tja.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(Sja))?Sja:/^data:.*,.*$/i.test(Sja)?Sja:/^blob:.*$/i.test(Sja)?Sja:Tja+Sja}}(class extends MC{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(Uja){return super.copy(Uja),this.instanceCount=Uja.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const Vja=super.toJSON(this);return Vja.instanceCount=this.instanceCount,Vja.isInstancedBufferGeometry=!0,Vja}}).prototype.isInstancedBufferGeometry=!0;class Wja extends Aga{constructor(Xja){super(Xja),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(Yja){return this.options=Yja,this}load(Zja,$ja,_ja,aka){void 0===Zja&&(Zja=""),void 0!==this.path&&(Zja=this.path+Zja),Zja=this.manager.resolveURL(Zja);const bka=this,cka=pga.get(Zja);if(void 0!==cka)return bka.manager.itemStart(Zja),setTimeout(function(){$ja&&$ja(cka),bka.manager.itemEnd(Zja)},0),cka;const dka={};dka.credentials="anonymous"===this.crossOrigin?"same-origin":"include",dka.headers=this.requestHeader,fetch(Zja,dka).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,Object.assign(bka.options,{colorSpaceConversion:"none"}))}).then(function(a){pga.add(Zja,a),$ja&&$ja(a),bka.manager.itemEnd(Zja)}).catch(function(a){aka&&aka(a),bka.manager.itemError(Zja),bka.manager.itemEnd(Zja)}),bka.manager.itemStart(Zja)}}Wja.prototype.isImageBitmapLoader=!0;let eka;const fka={getContext:function(){return void 0===eka&&(eka=new(window.AudioContext||window.webkitAudioContext)()),eka},setContext:function(a){eka=a}};class gka extends Aga{constructor(hka){super(hka)}load(ika,jka,kka,lka){const mka=this,nka=new Lga(this.manager);nka.setResponseType("arraybuffer"),nka.setPath(this.path),nka.setRequestHeader(this.requestHeader),nka.setWithCredentials(this.withCredentials),nka.load(ika,function(a){try{const b=a.slice(0),c=fka.getContext();c.decodeAudioData(b,function(a){jka(a)})}catch(d){lka?lka(d):console.error(d),mka.manager.itemError(ika)}},kka,lka)}}(class extends Dja{constructor(oka,pka,qka=1){super(void 0,qka);const rka=new Dd().set(oka),ska=new Dd().set(pka),tka=new nk(rka.r,rka.g,rka.b),uka=new nk(ska.r,ska.g,ska.b),vka=Math.sqrt(Math.PI);this.sh.coefficients[0].copy(tka).add(uka).multiplyScalar(vka),this.sh.coefficients[1].copy(tka).sub(uka).multiplyScalar(vka*Math.sqrt(.75))}}).prototype.isHemisphereLightProbe=!0,(class extends Dja{constructor(wka,xka=1){super(void 0,xka);const yka=new Dd().set(wka);this.sh.coefficients[0].set(yka.r,yka.g,yka.b).multiplyScalar(2*Math.sqrt(Math.PI))}}).prototype.isAmbientLightProbe=!0,new Hq(),new Hq(),new Hq(),new nk(),new Ih(),new nk(),new nk(),new nk(),new Ih(),new nk(),new nk();class zka{constructor(Aka,Bka,Cka){this.binding=Aka,this.valueSize=Cka;let Dka,Eka,Fka;switch(Bka){case"quaternion":Dka=this._slerp,Eka=this._slerpAdditive,Fka=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*Cka),this._workIndex=5;break;case"string":case"bool":Dka=this._select,Eka=this._select,Fka=this._setAdditiveIdentityOther,this.buffer=new Array(5*Cka);break;default:Dka=this._lerp,Eka=this._lerpAdditive,Fka=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*Cka)}this._mixBufferRegion=Dka,this._mixBufferRegionAdditive=Eka,this._setIdentity=Fka,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(Gka,Hka){const Ika=this.buffer,Jka=this.valueSize,Kka=Gka*Jka+Jka;let Lka=this.cumulativeWeight;if(0===Lka){for(let Mka=0;Mka!==Jka;++Mka)Ika[Kka+Mka]=Ika[Mka];Lka=Hka}else{Lka+=Hka;const Nka=Hka/Lka;this._mixBufferRegion(Ika,Kka,0,Nka,Jka)}this.cumulativeWeight=Lka}accumulateAdditive(Oka){const Pka=this.buffer,Qka=this.valueSize,Rka=Qka*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(Pka,Rka,0,Oka,Qka),this.cumulativeWeightAdditive+=Oka}apply(Ska){const Tka=this.valueSize,Uka=this.buffer,Vka=Ska*Tka+Tka,Wka=this.cumulativeWeight,Xka=this.cumulativeWeightAdditive,Yka=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,Wka<1){const Zka=Tka*this._origIndex;this._mixBufferRegion(Uka,Vka,Zka,1-Wka,Tka)}Xka>0&&this._mixBufferRegionAdditive(Uka,Vka,this._addIndex*Tka,1,Tka);for(let $ka=Tka,_ka=Tka+Tka;$ka!==_ka;++$ka)if(Uka[$ka]!==Uka[$ka+Tka]){Yka.setValue(Uka,Vka);break}}saveOriginalState(){const ala=this.binding,bla=this.buffer,cla=this.valueSize,dla=cla*this._origIndex;ala.getValue(bla,dla);for(let ela=cla,fla=dla;ela!==fla;++ela)bla[ela]=bla[dla+ela%cla];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const gla=3*this.valueSize;this.binding.setValue(this.buffer,gla)}_setAdditiveIdentityNumeric(){const hla=this._addIndex*this.valueSize,ila=hla+this.valueSize;for(let jla=hla;jla<ila;jla++)this.buffer[jla]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const kla=this._origIndex*this.valueSize,lla=this._addIndex*this.valueSize;for(let mla=0;mla<this.valueSize;mla++)this.buffer[lla+mla]=this.buffer[kla+mla]}_select(nla,ola,pla,qla,rla){if(qla>=.5)for(let sla=0;sla!==rla;++sla)nla[ola+sla]=nla[pla+sla]}_slerp(tla,ula,vla,wla){Ih.slerpFlat(tla,ula,tla,ula,tla,vla,wla)}_slerpAdditive(xla,yla,zla,Ala,Bla){const Cla=this._workIndex*Bla;Ih.multiplyQuaternionsFlat(xla,Cla,xla,yla,xla,zla),Ih.slerpFlat(xla,yla,xla,yla,xla,Cla,Ala)}_lerp(Dla,Ela,Fla,Gla,Hla){const Ila=1-Gla;for(let Jla=0;Jla!==Hla;++Jla){const Kla=Ela+Jla;Dla[Kla]=Dla[Kla]*Ila+Dla[Fla+Jla]*Gla}}_lerpAdditive(Lla,Mla,Nla,Ola,Pla){for(let Qla=0;Qla!==Pla;++Qla){const Rla=Mla+Qla;Lla[Rla]=Lla[Rla]+Lla[Nla+Qla]*Ola}}}const Sla="\\[\\]\\.:\\/",Tla=new RegExp("["+Sla+"]","g"),Ula="[^"+Sla+"]",Vla="[^"+Sla.replace("\\.","")+"]",Wla=/((?:WC+[\/:])*)/.source.replace("WC",Ula),Xla=/(WCOD+)?/.source.replace("WCOD",Vla),Yla=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ula),Zla=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ula),$la=new RegExp("^"+Wla+Xla+Yla+Zla+"$"),_la=["material","materials","bones"];class ama{constructor(bma,cma,dma){this.path=cma,this.parsedPath=dma||ama.parseTrackName(cma),this.node=ama.findNode(bma,this.parsedPath.nodeName)||bma,this.rootNode=bma,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(ema,fma,gma){return ema&&ema.isAnimationObjectGroup?new ama.Composite(ema,fma,gma):new ama(ema,fma,gma)}static sanitizeNodeName(hma){return hma.replace(/\s/g,"_").replace(Tla,"")}static parseTrackName(ima){const jma=$la.exec(ima);if(!jma)throw new Error("PropertyBinding: Cannot parse trackName: "+ima);const kma={nodeName:jma[2],objectName:jma[3],objectIndex:jma[4],propertyName:jma[5],propertyIndex:jma[6]},lma=kma.nodeName&&kma.nodeName.lastIndexOf(".");if(void 0!==lma&& -1!==lma){const mma=kma.nodeName.substring(lma+1);-1!==_la.indexOf(mma)&&(kma.nodeName=kma.nodeName.substring(0,lma),kma.objectName=mma)}if(null===kma.propertyName||0===kma.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+ima);return kma}static findNode(nma,oma){if(!oma||""===oma||"."===oma|| -1===oma||oma===nma.name||oma===nma.uuid)return nma;if(nma.skeleton){const pma=nma.skeleton.getBoneByName(oma);if(void 0!==pma)return pma}if(nma.children){const qma=function(a){for(let b=0;b<a.length;b++){const c=a[b];if(c.name===oma||c.uuid===oma)return c;const d=qma(c.children);if(d)return d}return null},rma=qma(nma.children);if(rma)return rma}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(sma,tma){sma[tma]=this.targetObject[this.propertyName]}_getValue_array(uma,vma){const wma=this.resolvedProperty;for(let xma=0,yma=wma.length;xma!==yma;++xma)uma[vma++]=wma[xma]}_getValue_arrayElement(zma,Ama){zma[Ama]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(Bma,Cma){this.resolvedProperty.toArray(Bma,Cma)}_setValue_direct(Dma,Ema){this.targetObject[this.propertyName]=Dma[Ema]}_setValue_direct_setNeedsUpdate(Fma,Gma){this.targetObject[this.propertyName]=Fma[Gma],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(Hma,Ima){this.targetObject[this.propertyName]=Hma[Ima],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(Jma,Kma){const Lma=this.resolvedProperty;for(let Mma=0,Nma=Lma.length;Mma!==Nma;++Mma)Lma[Mma]=Jma[Kma++]}_setValue_array_setNeedsUpdate(Oma,Pma){const Qma=this.resolvedProperty;for(let Rma=0,Sma=Qma.length;Rma!==Sma;++Rma)Qma[Rma]=Oma[Pma++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(Tma,Uma){const Vma=this.resolvedProperty;for(let Wma=0,Xma=Vma.length;Wma!==Xma;++Wma)Vma[Wma]=Tma[Uma++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(Yma,Zma){this.resolvedProperty[this.propertyIndex]=Yma[Zma]}_setValue_arrayElement_setNeedsUpdate($ma,_ma){this.resolvedProperty[this.propertyIndex]=$ma[_ma],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(ana,bna){this.resolvedProperty[this.propertyIndex]=ana[bna],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(cna,dna){this.resolvedProperty.fromArray(cna,dna)}_setValue_fromArray_setNeedsUpdate(ena,fna){this.resolvedProperty.fromArray(ena,fna),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(gna,hna){this.resolvedProperty.fromArray(gna,hna),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(ina,jna){this.bind(),this.getValue(ina,jna)}_setValue_unbound(kna,lna){this.bind(),this.setValue(kna,lna)}bind(){let mna=this.node;const nna=this.parsedPath,ona=nna.objectName,pna=nna.propertyName;let qna=nna.propertyIndex;if(mna||(mna=ama.findNode(this.rootNode,nna.nodeName)||this.rootNode,this.node=mna),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!mna){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(ona){let rna=nna.objectIndex;switch(ona){case"materials":if(!mna.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!mna.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}mna=mna.material.materials;break;case"bones":if(!mna.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}mna=mna.skeleton.bones;for(let sna=0;sna<mna.length;sna++)if(mna[sna].name===rna){rna=sna;break}break;default:if(void 0===mna[ona]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}mna=mna[ona]}if(void 0!==rna){if(void 0===mna[rna]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,mna);return}mna=mna[rna]}}const tna=mna[pna];if(void 0===tna){const una=nna.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+una+"."+pna+" but it wasn't found.",mna);return}let vna=this.Versioning.None;this.targetObject=mna,void 0!==mna.needsUpdate?vna=this.Versioning.NeedsUpdate:void 0!==mna.matrixWorldNeedsUpdate&&(vna=this.Versioning.MatrixWorldNeedsUpdate);let wna=this.BindingType.Direct;if(void 0!==qna){if("morphTargetInfluences"===pna){if(!mna.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(mna.geometry.isBufferGeometry){if(!mna.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==mna.morphTargetDictionary[qna]&&(qna=mna.morphTargetDictionary[qna])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}wna=this.BindingType.ArrayElement,this.resolvedProperty=tna,this.propertyIndex=qna}else void 0!==tna.fromArray&& void 0!==tna.toArray?(wna=this.BindingType.HasFromToArray,this.resolvedProperty=tna):Array.isArray(tna)?(wna=this.BindingType.EntireArray,this.resolvedProperty=tna):this.propertyName=pna;this.getValue=this.GetterByBindingType[wna],this.setValue=this.SetterByBindingTypeAndVersioning[wna][vna]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ama.Composite=class{constructor(xna,yna,zna){const Ana=zna||ama.parseTrackName(yna);this._targetGroup=xna,this._bindings=xna.subscribe_(yna,Ana)}getValue(Bna,Cna){this.bind();const Dna=this._targetGroup.nCachedObjects_,Ena=this._bindings[Dna];void 0!==Ena&&Ena.getValue(Bna,Cna)}setValue(Fna,Gna){const Hna=this._bindings;for(let Ina=this._targetGroup.nCachedObjects_,Jna=Hna.length;Ina!==Jna;++Ina)Hna[Ina].setValue(Fna,Gna)}bind(){const Kna=this._bindings;for(let Lna=this._targetGroup.nCachedObjects_,Mna=Kna.length;Lna!==Mna;++Lna)Kna[Lna].bind()}unbind(){const Nna=this._bindings;for(let Ona=this._targetGroup.nCachedObjects_,Pna=Nna.length;Ona!==Pna;++Ona)Nna[Ona].unbind()}},ama.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},ama.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},ama.prototype.GetterByBindingType=[ama.prototype._getValue_direct,ama.prototype._getValue_array,ama.prototype._getValue_arrayElement,ama.prototype._getValue_toArray,],ama.prototype.SetterByBindingTypeAndVersioning=[[ama.prototype._setValue_direct,ama.prototype._setValue_direct_setNeedsUpdate,ama.prototype._setValue_direct_setMatrixWorldNeedsUpdate,],[ama.prototype._setValue_array,ama.prototype._setValue_array_setNeedsUpdate,ama.prototype._setValue_array_setMatrixWorldNeedsUpdate,],[ama.prototype._setValue_arrayElement,ama.prototype._setValue_arrayElement_setNeedsUpdate,ama.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,],[ama.prototype._setValue_fromArray,ama.prototype._setValue_fromArray_setNeedsUpdate,ama.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,]],(class{constructor(){this.uuid=V(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const Qna={};this._indicesByUUID=Qna;for(let Rna=0,Sna=arguments.length;Rna!==Sna;++Rna)Qna[arguments[Rna].uuid]=Rna;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={},this.stats={objects:{get total(){return this._objects.length},get inUse(){return this.total-this.nCachedObjects_}},get bindingsPerObject(){return this._bindings.length}}}add(){const Tna=this._objects,Una=this._indicesByUUID,Vna=this._paths,Wna=this._parsedPaths,Xna=this._bindings,Yna=Xna.length;let Zna,$na=Tna.length,_na=this.nCachedObjects_;for(let aoa=0,boa=arguments.length;aoa!==boa;++aoa){const coa=arguments[aoa],doa=coa.uuid;let eoa=Una[doa];if(void 0===eoa){eoa=$na++,Una[doa]=eoa,Tna.push(coa);for(let foa=0,goa=Yna;foa!==goa;++foa)Xna[foa].push(new ama(coa,Vna[foa],Wna[foa]))}else if(eoa<_na){Zna=Tna[eoa];const hoa=--_na,ioa=Tna[hoa];Una[ioa.uuid]=eoa,Tna[eoa]=ioa,Una[doa]=hoa,Tna[hoa]=coa;for(let joa=0,koa=Yna;joa!==koa;++joa){const loa=Xna[joa],moa=loa[hoa];let noa=loa[eoa];loa[eoa]=moa,void 0===noa&&(noa=new ama(coa,Vna[joa],Wna[joa])),loa[hoa]=noa}}else Tna[eoa]!==Zna&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=_na}remove(){const ooa=this._objects,poa=this._indicesByUUID,qoa=this._bindings,roa=qoa.length;let soa=this.nCachedObjects_;for(let toa=0,uoa=arguments.length;toa!==uoa;++toa){const voa=arguments[toa],woa=voa.uuid,xoa=poa[woa];if(void 0!==xoa&&xoa>=soa){const yoa=soa++,zoa=ooa[yoa];poa[zoa.uuid]=xoa,ooa[xoa]=zoa,poa[woa]=yoa,ooa[yoa]=voa;for(let Aoa=0,Boa=roa;Aoa!==Boa;++Aoa){const Coa=qoa[Aoa],Doa=Coa[yoa],Eoa=Coa[xoa];Coa[xoa]=Doa,Coa[yoa]=Eoa}}}this.nCachedObjects_=soa}uncache(){const Foa=this._objects,Goa=this._indicesByUUID,Hoa=this._bindings,Ioa=Hoa.length;let Joa=this.nCachedObjects_,Koa=Foa.length;for(let Loa=0,Moa=arguments.length;Loa!==Moa;++Loa){const Noa=arguments[Loa],Ooa=Noa.uuid,Poa=Goa[Ooa];if(void 0!==Poa)if(delete Goa[Ooa],Poa<Joa){const Qoa=--Joa,Roa=Foa[Qoa],Soa=--Koa,Toa=Foa[Soa];Goa[Roa.uuid]=Poa,Foa[Poa]=Roa,Goa[Toa.uuid]=Qoa,Foa[Qoa]=Toa,Foa.pop();for(let Uoa=0,Voa=Ioa;Uoa!==Voa;++Uoa){const Woa=Hoa[Uoa],Xoa=Woa[Qoa],Yoa=Woa[Soa];Woa[Poa]=Xoa,Woa[Qoa]=Yoa,Woa.pop()}}else{const Zoa=--Koa,$oa=Foa[Zoa];Zoa>0&&(Goa[$oa.uuid]=Poa),Foa[Poa]=$oa,Foa.pop();for(let _oa=0,apa=Ioa;_oa!==apa;++_oa){const bpa=Hoa[_oa];bpa[Poa]=bpa[Zoa],bpa.pop()}}}this.nCachedObjects_=Joa}subscribe_(cpa,dpa){const epa=this._bindingsIndicesByPath;let fpa=epa[cpa];const gpa=this._bindings;if(void 0!==fpa)return gpa[fpa];const hpa=this._paths,ipa=this._parsedPaths,jpa=this._objects,kpa=jpa.length,lpa=this.nCachedObjects_,mpa=new Array(kpa);fpa=gpa.length,epa[cpa]=fpa,hpa.push(cpa),ipa.push(dpa),gpa.push(mpa);for(let npa=lpa,opa=jpa.length;npa!==opa;++npa){const ppa=jpa[npa];mpa[npa]=new ama(ppa,cpa,dpa)}return mpa}unsubscribe_(qpa){const rpa=this._bindingsIndicesByPath,spa=rpa[qpa];if(void 0!==spa){const tpa=this._paths,upa=this._parsedPaths,vpa=this._bindings,wpa=vpa.length-1,xpa=vpa[wpa],ypa=qpa[wpa];rpa[ypa]=spa,vpa[spa]=xpa,vpa.pop(),upa[spa]=upa[wpa],upa.pop(),tpa[spa]=tpa[wpa],tpa.pop()}}}).prototype.isAnimationObjectGroup=!0;class zpa{constructor(Apa,Bpa,Cpa=null,Dpa=Bpa.blendMode){this._mixer=Apa,this._clip=Bpa,this._localRoot=Cpa,this.blendMode=Dpa;const Epa=Bpa.tracks,Fpa=Epa.length,Gpa=new Array(Fpa),Hpa={endingStart:2400,endingEnd:2400};for(let Ipa=0;Ipa!==Fpa;++Ipa){const Jpa=Epa[Ipa].createInterpolant(null);Gpa[Ipa]=Jpa,Jpa.settings=Hpa}this._interpolantSettings=Hpa,this._interpolants=Gpa,this._propertyBindings=new Array(Fpa),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(Kpa){return this._startTime=Kpa,this}setLoop(Lpa,Mpa){return this.loop=Lpa,this.repetitions=Mpa,this}setEffectiveWeight(Npa){return this.weight=Npa,this._effectiveWeight=this.enabled?Npa:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(Opa){return this._scheduleFading(Opa,0,1)}fadeOut(Ppa){return this._scheduleFading(Ppa,1,0)}crossFadeFrom(Qpa,Rpa,Spa){if(Qpa.fadeOut(Rpa),this.fadeIn(Rpa),Spa){const Tpa=this._clip.duration,Upa=Qpa._clip.duration,Vpa=Upa/Tpa,Wpa=Tpa/Upa;Qpa.warp(1,Vpa,Rpa),this.warp(Wpa,1,Rpa)}return this}crossFadeTo(Xpa,Ypa,Zpa){return Xpa.crossFadeFrom(this,Ypa,Zpa)}stopFading(){const $pa=this._weightInterpolant;return null!==$pa&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant($pa)),this}setEffectiveTimeScale(_pa){return this.timeScale=_pa,this._effectiveTimeScale=this.paused?0:_pa,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(aqa){return this.timeScale=this._clip.duration/aqa,this.stopWarping()}syncWith(bqa){return this.time=bqa.time,this.timeScale=bqa.timeScale,this.stopWarping()}halt(cqa){return this.warp(this._effectiveTimeScale,0,cqa)}warp(dqa,eqa,fqa){const gqa=this._mixer,hqa=gqa.time,iqa=this.timeScale;let jqa=this._timeScaleInterpolant;null===jqa&&(jqa=gqa._lendControlInterpolant(),this._timeScaleInterpolant=jqa);const kqa=jqa.parameterPositions,lqa=jqa.sampleValues;return kqa[0]=hqa,kqa[1]=hqa+fqa,lqa[0]=dqa/iqa,lqa[1]=eqa/iqa,this}stopWarping(){const mqa=this._timeScaleInterpolant;return null!==mqa&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(mqa)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(nqa,oqa,pqa,qqa){if(!this.enabled){this._updateWeight(nqa);return}const rqa=this._startTime;if(null!==rqa){const sqa=(nqa-rqa)*pqa;if(sqa<0||0===pqa)return;this._startTime=null,oqa=pqa*sqa}oqa*=this._updateTimeScale(nqa);const tqa=this._updateTime(oqa),uqa=this._updateWeight(nqa);if(uqa>0){const vqa=this._interpolants,wqa=this._propertyBindings;switch(this.blendMode){case 2501:for(let xqa=0,yqa=vqa.length;xqa!==yqa;++xqa)vqa[xqa].evaluate(tqa),wqa[xqa].accumulateAdditive(uqa);break;case 2500:default:for(let zqa=0,Aqa=vqa.length;zqa!==Aqa;++zqa)vqa[zqa].evaluate(tqa),wqa[zqa].accumulate(qqa,uqa)}}}_updateWeight(Bqa){let Cqa=0;if(this.enabled){Cqa=this.weight;const Dqa=this._weightInterpolant;if(null!==Dqa){const Eqa=Dqa.evaluate(Bqa)[0];Cqa*=Eqa,Bqa>Dqa.parameterPositions[1]&&(this.stopFading(),0===Eqa&&(this.enabled=!1))}}return this._effectiveWeight=Cqa,Cqa}_updateTimeScale(Fqa){let Gqa=0;if(!this.paused){Gqa=this.timeScale;const Hqa=this._timeScaleInterpolant;if(null!==Hqa){const Iqa=Hqa.evaluate(Fqa)[0];Gqa*=Iqa,Fqa>Hqa.parameterPositions[1]&&(this.stopWarping(),0===Gqa?this.paused=!0:this.timeScale=Gqa)}}return this._effectiveTimeScale=Gqa,Gqa}_updateTime(Jqa){const Kqa=this._clip.duration,Lqa=this.loop;let Mqa=this.time+Jqa,Nqa=this._loopCount;const Oqa=2202===Lqa;if(0===Jqa)return -1===Nqa?Mqa:Oqa&&(1&Nqa)==1?Kqa-Mqa:Mqa;if(2200===Lqa){-1===Nqa&&(this._loopCount=0,this._setEndings(!0,!0,!1));handle_stop:{if(Mqa>=Kqa)Mqa=Kqa;else if(Mqa<0)Mqa=0;else{this.time=Mqa;break handle_stop}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=Mqa,this._mixer.dispatchEvent({type:"finished",action:this,direction:Jqa<0?-1:1})}}else{if(-1===Nqa&&(Jqa>=0?(Nqa=0,this._setEndings(!0,0===this.repetitions,Oqa)):this._setEndings(0===this.repetitions,!0,Oqa)),Mqa>=Kqa||Mqa<0){const Pqa=Math.floor(Mqa/Kqa);Mqa-=Kqa*Pqa,Nqa+=Math.abs(Pqa);const Qqa=this.repetitions-Nqa;if(Qqa<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,Mqa=Jqa>0?Kqa:0,this.time=Mqa,this._mixer.dispatchEvent({type:"finished",action:this,direction:Jqa>0?1:-1});else{if(1===Qqa){const Rqa=Jqa<0;this._setEndings(Rqa,!Rqa,Oqa)}else this._setEndings(!1,!1,Oqa);this._loopCount=Nqa,this.time=Mqa,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:Pqa})}}else this.time=Mqa;if(Oqa&&(1&Nqa)==1)return Kqa-Mqa}return Mqa}_setEndings(Sqa,Tqa,Uqa){const Vqa=this._interpolantSettings;Uqa?(Vqa.endingStart=2401,Vqa.endingEnd=2401):(Sqa?Vqa.endingStart=this.zeroSlopeAtStart?2401:2400:Vqa.endingStart=2402,Tqa?Vqa.endingEnd=this.zeroSlopeAtEnd?2401:2400:Vqa.endingEnd=2402)}_scheduleFading(Wqa,Xqa,Yqa){const Zqa=this._mixer,$qa=Zqa.time;let _qa=this._weightInterpolant;null===_qa&&(_qa=Zqa._lendControlInterpolant(),this._weightInterpolant=_qa);const ara=_qa.parameterPositions,bra=_qa.sampleValues;return ara[0]=$qa,bra[0]=Xqa,ara[1]=$qa+Wqa,bra[1]=Yqa,this}}(class extends y{constructor(cra){super(),this._root=cra,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(dra,era){const fra=dra._localRoot||this._root,gra=dra._clip.tracks,hra=gra.length,ira=dra._propertyBindings,jra=dra._interpolants,kra=fra.uuid,lra=this._bindingsByRootAndName;let mra=lra[kra];void 0===mra&&(mra={},lra[kra]=mra);for(let nra=0;nra!==hra;++nra){const ora=gra[nra],pra=ora.name;let qra=mra[pra];if(void 0!==qra)++qra.referenceCount,ira[nra]=qra;else{if(void 0!==(qra=ira[nra])){null===qra._cacheIndex&&(++qra.referenceCount,this._addInactiveBinding(qra,kra,pra));continue}const rra=era&&era._propertyBindings[nra].binding.parsedPath;qra=new zka(ama.create(fra,pra,rra),ora.ValueTypeName,ora.getValueSize()),++qra.referenceCount,this._addInactiveBinding(qra,kra,pra),ira[nra]=qra}jra[nra].resultBuffer=qra.buffer}}_activateAction(sra){if(!this._isActiveAction(sra)){if(null===sra._cacheIndex){const tra=(sra._localRoot||this._root).uuid,ura=sra._clip.uuid,vra=this._actionsByClip[ura];this._bindAction(sra,vra&&vra.knownActions[0]),this._addInactiveAction(sra,ura,tra)}const wra=sra._propertyBindings;for(let xra=0,yra=wra.length;xra!==yra;++xra){const zra=wra[xra];0==zra.useCount++&&(this._lendBinding(zra),zra.saveOriginalState())}this._lendAction(sra)}}_deactivateAction(Ara){if(this._isActiveAction(Ara)){const Bra=Ara._propertyBindings;for(let Cra=0,Dra=Bra.length;Cra!==Dra;++Cra){const Era=Bra[Cra];0== --Era.useCount&&(Era.restoreOriginalState(),this._takeBackBinding(Era))}this._takeBackAction(Ara)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0,this.stats={actions:{get total(){return this._actions.length},get inUse(){return this._nActiveActions}},bindings:{get total(){return this._bindings.length},get inUse(){return this._nActiveBindings}},controlInterpolants:{get total(){return this._controlInterpolants.length},get inUse(){return this._nActiveControlInterpolants}}}}_isActiveAction(Fra){const Gra=Fra._cacheIndex;return null!==Gra&&Gra<this._nActiveActions}_addInactiveAction(Hra,Ira,Jra){const Kra=this._actions,Lra=this._actionsByClip;let Mra=Lra[Ira];if(void 0===Mra)Mra={knownActions:[Hra],actionByRoot:{}},Hra._byClipCacheIndex=0,Lra[Ira]=Mra;else{const Nra=Mra.knownActions;Hra._byClipCacheIndex=Nra.length,Nra.push(Hra)}Hra._cacheIndex=Kra.length,Kra.push(Hra),Mra.actionByRoot[Jra]=Hra}_removeInactiveAction(Ora){const Pra=this._actions,Qra=Pra[Pra.length-1],Rra=Ora._cacheIndex;Qra._cacheIndex=Rra,Pra[Rra]=Qra,Pra.pop(),Ora._cacheIndex=null;const Sra=Ora._clip.uuid,Tra=this._actionsByClip,Ura=Tra[Sra],Vra=Ura.knownActions,Wra=Vra[Vra.length-1],Xra=Ora._byClipCacheIndex;Wra._byClipCacheIndex=Xra,Vra[Xra]=Wra,Vra.pop(),Ora._byClipCacheIndex=null;const Yra=Ura.actionByRoot,Zra=(Ora._localRoot||this._root).uuid;delete Yra[Zra],0===Vra.length&&delete Tra[Sra],this._removeInactiveBindingsForAction(Ora)}_removeInactiveBindingsForAction($ra){const _ra=$ra._propertyBindings;for(let asa=0,bsa=_ra.length;asa!==bsa;++asa){const csa=_ra[asa];0== --csa.referenceCount&&this._removeInactiveBinding(csa)}}_lendAction(dsa){const esa=this._actions,fsa=dsa._cacheIndex,gsa=this._nActiveActions++,hsa=esa[gsa];dsa._cacheIndex=gsa,esa[gsa]=dsa,hsa._cacheIndex=fsa,esa[fsa]=hsa}_takeBackAction(isa){const jsa=this._actions,ksa=isa._cacheIndex,lsa=--this._nActiveActions,msa=jsa[lsa];isa._cacheIndex=lsa,jsa[lsa]=isa,msa._cacheIndex=ksa,jsa[ksa]=msa}_addInactiveBinding(nsa,osa,psa){const qsa=this._bindingsByRootAndName,rsa=this._bindings;let ssa=qsa[osa];void 0===ssa&&(ssa={},qsa[osa]=ssa),ssa[psa]=nsa,nsa._cacheIndex=rsa.length,rsa.push(nsa)}_removeInactiveBinding(tsa){const usa=this._bindings,vsa=tsa.binding,wsa=vsa.rootNode.uuid,xsa=vsa.path,ysa=this._bindingsByRootAndName,zsa=ysa[wsa],Asa=usa[usa.length-1],Bsa=tsa._cacheIndex;Asa._cacheIndex=Bsa,usa[Bsa]=Asa,usa.pop(),delete zsa[xsa],0===Object.keys(zsa).length&&delete ysa[wsa]}_lendBinding(Csa){const Dsa=this._bindings,Esa=Csa._cacheIndex,Fsa=this._nActiveBindings++,Gsa=Dsa[Fsa];Csa._cacheIndex=Fsa,Dsa[Fsa]=Csa,Gsa._cacheIndex=Esa,Dsa[Esa]=Gsa}_takeBackBinding(Hsa){const Isa=this._bindings,Jsa=Hsa._cacheIndex,Ksa=--this._nActiveBindings,Lsa=Isa[Ksa];Hsa._cacheIndex=Ksa,Isa[Ksa]=Hsa,Lsa._cacheIndex=Jsa,Isa[Jsa]=Lsa}_lendControlInterpolant(){const Msa=this._controlInterpolants,Nsa=this._nActiveControlInterpolants++;let Osa=Msa[Nsa];return void 0===Osa&&((Osa=new Pca(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=Nsa,Msa[Nsa]=Osa),Osa}_takeBackControlInterpolant(Psa){const Qsa=this._controlInterpolants,Rsa=Psa.__cacheIndex,Ssa=--this._nActiveControlInterpolants,Tsa=Qsa[Ssa];Psa.__cacheIndex=Ssa,Qsa[Ssa]=Psa,Tsa.__cacheIndex=Rsa,Qsa[Rsa]=Tsa}clipAction(Usa,Vsa,Wsa){const Xsa=Vsa||this._root,Ysa=Xsa.uuid;let Zsa="string"==typeof Usa?Sea.findByName(Xsa,Usa):Usa;const $sa=null!==Zsa?Zsa.uuid:Usa,_sa=this._actionsByClip[$sa];let ata=null;if(void 0===Wsa&&(Wsa=null!==Zsa?Zsa.blendMode:2500),void 0!==_sa){const bta=_sa.actionByRoot[Ysa];if(void 0!==bta&&bta.blendMode===Wsa)return bta;ata=_sa.knownActions[0],null===Zsa&&(Zsa=ata._clip)}if(null===Zsa)return null;const cta=new zpa(this,Zsa,Vsa,Wsa);return this._bindAction(cta,ata),this._addInactiveAction(cta,$sa,Ysa),cta}existingAction(dta,eta){const fta=eta||this._root,gta=fta.uuid,hta="string"==typeof dta?Sea.findByName(fta,dta):dta,ita=hta?hta.uuid:dta,jta=this._actionsByClip[ita];return void 0!==jta?jta.actionByRoot[gta]||null:null}stopAllAction(){const kta=this._actions,lta=this._nActiveActions;for(let mta=lta-1;mta>=0;--mta)kta[mta].stop();return this}update(nta){nta*=this.timeScale;const ota=this._actions,pta=this._nActiveActions,qta=this.time+=nta,rta=Math.sign(nta),sta=this._accuIndex^=1;for(let tta=0;tta!==pta;++tta){const uta=ota[tta];uta._update(qta,nta,rta,sta)}const vta=this._bindings,wta=this._nActiveBindings;for(let xta=0;xta!==wta;++xta)vta[xta].apply(sta);return this}setTime(yta){this.time=0;for(let zta=0;zta<this._actions.length;zta++)this._actions[zta].time=0;return this.update(yta)}getRoot(){return this._root}uncacheClip(Ata){const Bta=this._actions,Cta=Ata.uuid,Dta=this._actionsByClip,Eta=Dta[Cta];if(void 0!==Eta){const Fta=Eta.knownActions;for(let Gta=0,Hta=Fta.length;Gta!==Hta;++Gta){const Ita=Fta[Gta];this._deactivateAction(Ita);const Jta=Ita._cacheIndex,Kta=Bta[Bta.length-1];Ita._cacheIndex=null,Ita._byClipCacheIndex=null,Kta._cacheIndex=Jta,Bta[Jta]=Kta,Bta.pop(),this._removeInactiveBindingsForAction(Ita)}delete Dta[Cta]}}uncacheRoot(Lta){const Mta=Lta.uuid,Nta=this._actionsByClip;for(const Ota in Nta){const Pta=Nta[Ota].actionByRoot,Qta=Pta[Mta];void 0!==Qta&&(this._deactivateAction(Qta),this._removeInactiveAction(Qta))}const Rta=this._bindingsByRootAndName,Sta=Rta[Mta];if(void 0!==Sta)for(const Tta in Sta){const Uta=Sta[Tta];Uta.restoreOriginalState(),this._removeInactiveBinding(Uta)}}uncacheAction(Vta,Wta){const Xta=this.existingAction(Vta,Wta);null!==Xta&&(this._deactivateAction(Xta),this._removeInactiveAction(Xta))}}).prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Yta{constructor(Zta){"string"==typeof Zta&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),Zta=arguments[1]),this.value=Zta}clone(){return new Yta(void 0===this.value.clone?this.value:this.value.clone())}}function $ta(a,b,c,d){if(a.layers.test(b.layers)&&a.raycast(b,c),!0===d){const e=a.children;for(let f=0,g=e.length;f<g;f++)$ta(e[f],b,c,!0)}}(class extends DS{constructor(_ta,aua,bua=1){super(_ta,aua),this.meshPerAttribute=bua}copy(cua){return super.copy(cua),this.meshPerAttribute=cua.meshPerAttribute,this}clone(dua){const eua=super.clone(dua);return eua.meshPerAttribute=this.meshPerAttribute,eua}toJSON(fua){const gua=super.toJSON(fua);return gua.isInstancedInterleavedBuffer=!0,gua.meshPerAttribute=this.meshPerAttribute,gua}}).prototype.isInstancedInterleavedBuffer=!0,(class{constructor(hua,iua,jua,kua,lua){this.buffer=hua,this.type=iua,this.itemSize=jua,this.elementSize=kua,this.count=lua,this.version=0}set needsUpdate(mua){!0===mua&&this.version++}setBuffer(nua){return this.buffer=nua,this}setType(oua,pua){return this.type=oua,this.elementSize=pua,this}setItemSize(qua){return this.itemSize=qua,this}setCount(rua){return this.count=rua,this}}).prototype.isGLBufferAttribute=!0;class sua{constructor(tua=1,uua=0,vua=0){return this.radius=tua,this.phi=uua,this.theta=vua,this}set(wua,xua,yua){return this.radius=wua,this.phi=xua,this.theta=yua,this}copy(zua){return this.radius=zua.radius,this.phi=zua.phi,this.theta=zua.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(Aua){return this.setFromCartesianCoords(Aua.x,Aua.y,Aua.z)}setFromCartesianCoords(Bua,Cua,Dua){return this.radius=Math.sqrt(Bua*Bua+Cua*Cua+Dua*Dua),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(Bua,Dua),this.phi=Math.acos(W(Cua/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const Eua=new ba();class Fua{constructor(Gua=new ba(Infinity,Infinity),Hua=new ba(-1/0,-1/0)){this.min=Gua,this.max=Hua}set(Iua,Jua){return this.min.copy(Iua),this.max.copy(Jua),this}setFromPoints(Kua){this.makeEmpty();for(let Lua=0,Mua=Kua.length;Lua<Mua;Lua++)this.expandByPoint(Kua[Lua]);return this}setFromCenterAndSize(Nua,Oua){const Pua=Eua.copy(Oua).multiplyScalar(.5);return this.min.copy(Nua).sub(Pua),this.max.copy(Nua).add(Pua),this}clone(){return new this.constructor().copy(this)}copy(Qua){return this.min.copy(Qua.min),this.max.copy(Qua.max),this}makeEmpty(){return this.min.x=this.min.y=Infinity,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(Rua){return this.isEmpty()?Rua.set(0,0):Rua.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(Sua){return this.isEmpty()?Sua.set(0,0):Sua.subVectors(this.max,this.min)}expandByPoint(Tua){return this.min.min(Tua),this.max.max(Tua),this}expandByVector(Uua){return this.min.sub(Uua),this.max.add(Uua),this}expandByScalar(Vua){return this.min.addScalar(-Vua),this.max.addScalar(Vua),this}containsPoint(Wua){return!(Wua.x<this.min.x)&&!(Wua.x>this.max.x)&&!(Wua.y<this.min.y)&&!(Wua.y>this.max.y)}containsBox(Xua){return this.min.x<=Xua.min.x&&Xua.max.x<=this.max.x&&this.min.y<=Xua.min.y&&Xua.max.y<=this.max.y}getParameter(Yua,Zua){return Zua.set((Yua.x-this.min.x)/(this.max.x-this.min.x),(Yua.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox($ua){return!($ua.max.x<this.min.x)&&!($ua.min.x>this.max.x)&&!($ua.max.y<this.min.y)&&!($ua.min.y>this.max.y)}clampPoint(_ua,ava){return ava.copy(_ua).clamp(this.min,this.max)}distanceToPoint(bva){const cva=Eua.copy(bva).clamp(this.min,this.max);return cva.sub(bva).length()}intersect(dva){return this.min.max(dva.min),this.max.min(dva.max),this}union(eva){return this.min.min(eva.min),this.max.max(eva.max),this}translate(fva){return this.min.add(fva),this.max.add(fva),this}equals(gva){return gva.min.equals(this.min)&&gva.max.equals(this.max)}}Fua.prototype.isBox2=!0;const hva=new nk(),iva=new nk(),jva=new nk(),kva=new nk(),lva=new Hq(),mva=new Hq();function nva(a){const b=[];a&&a.isBone&&b.push(a);for(let c=0;c<a.children.length;c++)b.push.apply(b,nva(a.children[c]));return b}new nk(),new Dd(),new Dd(),new nk(),new nk(),new nk(),new nk(),new fI(),new Tm(),new nk();const ova=new Float32Array(1);new Int32Array(ova.buffer),v$.create=function(a,b){return console.log("THREE.Curve.create() has been deprecated"),a.prototype=Object.create(v$.prototype),a.prototype.constructor=a,a.prototype.getPoint=b,a},H3.prototype.fromPoints=function(a){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(a)},(class extends BX{constructor(pva=10,qva=10,rva=4473924,sva=8947848){rva=new Dd(rva),sva=new Dd(sva);const tva=qva/2,uva=pva/qva,vva=pva/2,wva=[],xva=[];for(let yva=0,zva=0,Ava=-vva;yva<=qva;yva++,Ava+=uva){wva.push(-vva,0,Ava,vva,0,Ava),wva.push(Ava,0,-vva,Ava,0,vva);const Bva=yva===tva?rva:sva;Bva.toArray(xva,zva),zva+=3,Bva.toArray(xva,zva),zva+=3,Bva.toArray(xva,zva),zva+=3,Bva.toArray(xva,zva),zva+=3}const Cva=new MC();Cva.setAttribute("position",new BC(wva,3)),Cva.setAttribute("color",new BC(xva,3));const Dva=new yW({vertexColors:!0,toneMapped:!1});super(Cva,Dva),this.type="GridHelper"}}).prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},(class extends BX{constructor(Eva){const Fva=nva(Eva),Gva=new MC(),Hva=[],Iva=[],Jva=new Dd(0,0,1),Kva=new Dd(0,1,0);for(let Lva=0;Lva<Fva.length;Lva++){const Mva=Fva[Lva];Mva.parent&&Mva.parent.isBone&&(Hva.push(0,0,0),Hva.push(0,0,0),Iva.push(Jva.r,Jva.g,Jva.b),Iva.push(Kva.r,Kva.g,Kva.b))}Gva.setAttribute("position",new BC(Hva,3)),Gva.setAttribute("color",new BC(Iva,3));const Nva=new yW({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(Gva,Nva),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=Eva,this.bones=Fva,this.matrix=Eva.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(Ova){const Pva=this.bones,Qva=this.geometry,Rva=Qva.getAttribute("position");mva.copy(this.root.matrixWorld).invert();for(let Sva=0,Tva=0;Sva<Pva.length;Sva++){const Uva=Pva[Sva];Uva.parent&&Uva.parent.isBone&&(lva.multiplyMatrices(mva,Uva.matrixWorld),kva.setFromMatrixPosition(lva),Rva.setXYZ(Tva,kva.x,kva.y,kva.z),lva.multiplyMatrices(mva,Uva.parent.matrixWorld),kva.setFromMatrixPosition(lva),Rva.setXYZ(Tva+1,kva.x,kva.y,kva.z),Tva+=2)}Qva.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(Ova)}}).prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Aga.prototype.extractUrlBase=function(a){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Kja.extractUrlBase(a)},Aga.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Fua.prototype.center=function(a){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(a)},Fua.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Fua.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},Fua.prototype.size=function(a){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(a)},Tm.prototype.center=function(a){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(a)},Tm.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Tm.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},Tm.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)},Tm.prototype.size=function(a){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(a)},Eo.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},CK.prototype.setFromMatrix=function(a){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(a)},(class{constructor(Vva=new nk(),Wva=new nk()){this.start=Vva,this.end=Wva}set(Xva,Yva){return this.start.copy(Xva),this.end.copy(Yva),this}copy(Zva){return this.start.copy(Zva.start),this.end.copy(Zva.end),this}getCenter($va){return $va.addVectors(this.start,this.end).multiplyScalar(.5)}delta(_va){return _va.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(awa,bwa){return this.delta(bwa).multiplyScalar(awa).add(this.start)}closestPointToPointParameter(cwa,dwa){hva.subVectors(cwa,this.start),iva.subVectors(this.end,this.start);const ewa=iva.dot(iva),fwa=iva.dot(hva);let gwa=fwa/ewa;return dwa&&(gwa=W(gwa,0,1)),gwa}closestPointToPoint(hwa,iwa,jwa){const kwa=this.closestPointToPointParameter(hwa,iwa);return this.delta(jwa).multiplyScalar(kwa).add(this.start)}applyMatrix4(lwa){return this.start.applyMatrix4(lwa),this.end.applyMatrix4(lwa),this}equals(mwa){return mwa.start.equals(this.start)&&mwa.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}).prototype.center=function(a){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(a)},sb.prototype.flattenToArrayOffset=function(a,b){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,b)},sb.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)},sb.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},sb.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)},sb.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},sb.prototype.getInverse=function(a){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()},Hq.prototype.extractPosition=function(a){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(a)},Hq.prototype.flattenToArrayOffset=function(a,b){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,b)},Hq.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new nk().setFromMatrixColumn(this,3)},Hq.prototype.setRotationFromQuaternion=function(a){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(a)},Hq.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Hq.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},Hq.prototype.multiplyVector4=function(a){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},Hq.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Hq.prototype.rotateAxis=function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),a.transformDirection(this)},Hq.prototype.crossVector=function(a){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},Hq.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Hq.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Hq.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Hq.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Hq.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Hq.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},Hq.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Hq.prototype.makeFrustum=function(a,b,c,d,e,f){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(a,b,d,c,e,f)},Hq.prototype.getInverse=function(a){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()},PJ.prototype.isIntersectionLine=function(a){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(a)},Ih.prototype.multiplyVector3=function(a){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),a.applyQuaternion(this)},Ih.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},np.prototype.isIntersectionBox=function(a){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},np.prototype.isIntersectionPlane=function(a){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(a)},np.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)},Vy.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Vy.prototype.barycoordFromPoint=function(a,b){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(a,b)},Vy.prototype.midpoint=function(a){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(a)},Vy.prototypenormal=function(a){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(a)},Vy.prototype.plane=function(a){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(a)},Vy.barycoordFromPoint=function(a,b,c,d,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Vy.getBarycoord(a,b,c,d,e)},Vy.normal=function(a,b,c,d){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Vy.getNormal(a,b,c,d)},Q4.prototype.extractAllPoints=function(a){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(a)},Q4.prototype.extrude=function(a){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new d6(this,a)},Q4.prototype.makeGeometry=function(a){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Q7(this,a)},ba.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},ba.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)},ba.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},nk.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},nk.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},nk.prototype.getPositionFromMatrix=function(a){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(a)},nk.prototype.getScaleFromMatrix=function(a){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(a)},nk.prototype.getColumnFromMatrix=function(a,b){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(b,a)},nk.prototype.applyProjection=function(a){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(a)},nk.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},nk.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)},nk.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Af.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},Af.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Sw.prototype.getChildByName=function(a){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(a)},Sw.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},Sw.prototype.translate=function(a,b){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(b,a)},Sw.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},Sw.prototype.applyMatrix=function(a){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)},Object.defineProperties(Sw.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),vG.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(vG.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),xU.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},nI.prototype.setLens=function(a,b){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==b&&(this.filmGauge=b),this.setFocalLength(a)},Object.defineProperties(Aha.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=a}}}),Object.defineProperties(TA.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),35048===this.usage},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),TA.prototype.setDynamic=function(a){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===a?35048:35044),this},TA.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},TA.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},MC.prototype.addIndex=function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(a)},MC.prototype.addAttribute=function(a,b){return(console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),b&&b.isBufferAttribute||b&&b.isInterleavedBufferAttribute)?"index"===a?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(b),this):this.setAttribute(a,b):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(a,new TA(arguments[1],arguments[2])))},MC.prototype.addDrawCall=function(a,b,c){void 0!==c&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(a,b)},MC.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},MC.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},MC.prototype.removeAttribute=function(a){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(a)},MC.prototype.applyMatrix=function(a){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)},Object.defineProperties(MC.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),DS.prototype.setDynamic=function(a){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===a?35048:35044),this},DS.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},d6.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},d6.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},d6.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},yS.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Yta.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(wA.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Dd()}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===a}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(a){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=a}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(XH.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=a}}}),qS.prototype.clearTarget=function(a,b,c,d){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(a),this.clear(b,c,d)},qS.prototype.animate=function(a){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(a)},qS.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},qS.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},qS.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},qS.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},qS.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},qS.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},qS.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},qS.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},qS.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},qS.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},qS.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},qS.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},qS.prototype.enableScissorTest=function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(a)},qS.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},qS.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},qS.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},qS.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},qS.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},qS.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},qS.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},qS.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},qS.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},qS.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(qS.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(a){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===a?v:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}}),Object.defineProperties(XQ.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(hh.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=a}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=a}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=a}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=a}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=a}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=a}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=a}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=a}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=a}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=a}}}),(class extends Sw{constructor(nwa){super(),this.type="Audio",this.listener=nwa,this.context=nwa.context,this.gain=this.context.createGain(),this.gain.connect(nwa.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(owa){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=owa,this.connect(),this}setMediaElementSource(pwa){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(pwa),this.connect(),this}setMediaStreamSource(qwa){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(qwa),this.connect(),this}setBuffer(rwa){return this.buffer=rwa,this.sourceType="buffer",this.autoplay&&this.play(),this}play(swa=0){if(!0===this.isPlaying){console.warn("THREE.Audio: Audio is already playing.");return}if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+swa;const twa=this.context.createBufferSource();return twa.buffer=this.buffer,twa.loop=this.loop,twa.loopStart=this.loopStart,twa.loopEnd=this.loopEnd,twa.onended=this.onEnded.bind(this),twa.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=twa,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let uwa=1,vwa=this.filters.length;uwa<vwa;uwa++)this.filters[uwa-1].connect(this.filters[uwa]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let wwa=1,xwa=this.filters.length;wwa<xwa;wwa++)this.filters[wwa-1].disconnect(this.filters[wwa]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(ywa){return ywa||(ywa=[]),!0===this._connected?(this.disconnect(),this.filters=ywa.slice(),this.connect()):this.filters=ywa.slice(),this}setDetune(zwa){if(this.detune=zwa,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(Awa){return this.setFilters(Awa?[Awa]:[])}setPlaybackRate(Bwa){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=Bwa,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(Cwa){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=Cwa,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(Dwa){return this.loopStart=Dwa,this}setLoopEnd(Ewa){return this.loopEnd=Ewa,this}getVolume(){return this.gain.gain.value}setVolume(Fwa){return this.gain.gain.setTargetAtTime(Fwa,this.context.currentTime,.01),this}}).prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const b=this,c=new gka();return c.load(a,function(a){b.setBuffer(a)}),this},(class{constructor(Gwa,Hwa=2048){this.analyser=Gwa.context.createAnalyser(),this.analyser.fftSize=Hwa,this.data=new Uint8Array(this.analyser.frequencyBinCount),Gwa.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let Iwa=0;const Jwa=this.getFrequencyData();for(let Kwa=0;Kwa<Jwa.length;Kwa++)Iwa+=Jwa[Kwa];return Iwa/Jwa.length}}).prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},OI.prototype.updateCubeMap=function(a,b){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(a,b)},OI.prototype.clear=function(a,b,c,d){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(a,b,c,d)},Se.crossOrigin=void 0,Se.loadTexture=function(a,b,c,d){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const e=new sha();e.setCrossOrigin(this.crossOrigin);const f=e.load(a,c,void 0,d);return b&&(f.mapping=b),f},Se.loadTextureCube=function(a,b,c,d){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const e=new hha();e.setCrossOrigin(this.crossOrigin);const f=e.load(a,c,void 0,d);return b&&(f.mapping=b),f},Se.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Se.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"137"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="137")}}])